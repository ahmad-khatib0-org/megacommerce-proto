syntax = "proto3";

package uploader.v1;

option cc_enable_arenas = true;
option go_package = "github.com/ahmad-khatib0-org/megacommerce-proto/gen/go/uploader/v1;v1";
option java_outer_classname = "ConfigProto";
option java_package = "org.megacommerce.uploader.v1";

////////////////////////////////////////////////////////////////////////////////
// Enums (mirror Rust enums)
////////////////////////////////////////////////////////////////////////////////

enum AvailableDataStorages {
  AVAILABLE_DATA_STORAGES_UNSPECIFIED = 0;
  FILE_STORAGE = 1;
  S3 = 2;
  HYBRID_S3 = 3;
}

enum AvailableInfoStorages {
  AVAILABLE_INFO_STORAGES_UNSPECIFIED = 0;
  FILES = 1;
  REDIS = 2;
  POSTGRES = 3;
}

enum Hook {
  HOOK_UNSPECIFIED = 0;
  PRE_CREATE = 1;
  POST_CREATE = 2;
  POST_RECEIVE = 3;
  PRE_TERMINATE = 4;
  POST_TERMINATE = 5;
  POST_FINISH = 6;
}

enum Format {
  FORMAT_UNSPECIFIED = 0;
  DEFAULT = 1;
  V2 = 2;
}

enum Extension {
  EXTENSION_UNSPECIFIED = 0;
  GETTING = 1;
  CREATION = 2;
  CREATION_WITH_UPLOAD = 3;
  CREATION_DEFER_LENGTH = 4;
  TERMINATION = 5;
  CONCATENATION = 6;
  CHECKSUM = 7;
}

////////////////////////////////////////////////////////////////////////////////
// Messages (mirror Rust structs & comments)
////////////////////////////////////////////////////////////////////////////////

message DataStorageOptions {
  // Rustus storage type.
  //
  // Storages are used to store uploads.
  AvailableDataStorages storage = 1;
  // NOTE: Rust default is `default_storage()` -> FileStorage. Apply this default if field absent.

  // Rustus data directory
  //
  // This directory is used to store files for all `file_storage` storages.
  // PathBuf in Rust -> string path here.
  string data_dir = 2;
  // NOTE: Rust default is `./data`.

  // Storage directory structure. This template shows inner directory structure.
  // You can use following variables: day, month, year or even environment variables.
  // Example: "/year/month/day/env[HOSTNAME]/".
  string dir_structure = 3;

  // Forces fsync call after writing chunk to filesystem. Useful for network filesystems.
  bool force_fsync = 4;

  // S3 bucket to upload files to.
  //
  // This parameter is required for s3-based storages.
  optional string s3_bucket = 10;

  // S3 region.
  //
  // This parameter is required for s3-based storages.
  optional string s3_region = 11;

  // S3 access key.
  //
  // This parameter is required for s3-based storages.
  optional string s3_access_key = 12;

  // S3 access key path.
  //
  // path to file that has s3-access-key inside.
  //
  // This parameter is used for s3-based storages.
  optional string s3_access_key_path = 13;

  // S3 secret key.
  //
  // This parameter is required for s3-based storages.
  optional string s3_secret_key = 14;

  // S3 secret key path.
  //
  // path to file that has s3-secret-key inside.
  //
  // This parameter is required for s3-based storages.
  optional string s3_secret_key_path = 15;

  // S3 URL.
  //
  // This parameter is required for s3-based storages.
  optional string s3_url = 16;

  // S3 force path style.
  //
  // This parameter is required for some s3-based storages (e.g. MinIO).
  bool s3_force_path_style = 17;

  // S3 security token.
  //
  // This parameter is used for temporary credentials.
  optional string s3_security_token = 18;

  // S3 session token.
  optional string s3_session_token = 19;

  // S3 profile.
  optional string s3_profile = 20;

  // Additional S3 headers. These headers are passed to every request to s3.
  // Useful for configuring ACLs.
  optional string s3_headers = 21;

  // Number of concurrent downloads of partial files from S3.
  // When performing concatenation, Rustus downloads all partial files
  // from S3 and concatenates them into a single file.
  //
  // This parameter controls the number of concurrent downloads.
  uint32 s3_concat_concurrent_downloads = 22;
  // NOTE: Rust default = 10
}

message InfoStoreOptions {
  /// Type of info storage.
  ///
  /// Info storages are used to store information about uploads.
  ///
  /// This information is used in HEAD requests.
  AvailableInfoStorages info_storage = 1;
  // NOTE: Rust default = Files

  /// Rustus info directory
  ///
  /// This directory is used to store .info files for `file_info_storage`.
  string info_dir = 2;
  // NOTE: Rust default = "./data"

  /// Connection string for remote info storages.
  ///
  /// This connection string is used for storages which require connection.
  /// Examples of such storages are `Postgres`, `MySQL` or `Redis`.
  ///
  /// Value must include all connection details.
  optional string info_db_dsn = 3;

  // redis_info_expiration: Option<usize> in Rust -> optional uint64 here
  optional uint64 redis_info_expiration = 4;
}

message AMQPHooksOptions {
  /// Url for AMQP server.
  optional string url = 1;

  /// Rustus will create exchange if enabled.
  bool declare_exchange = 2;

  /// Rustus will create all queues for communication and bind them
  /// to exchange if enabled.
  bool declare_queues = 3;

  /// Durability type of exchange.
  bool durable_exchange = 4;

  /// Durability type of queues.
  bool durable_queues = 5;

  /// Adds celery specific headers.
  bool celery = 6;

  /// Name of amqp exchange.
  string exchange = 10; // default "rustus" in Rust

  /// Exchange kind.
  string exchange_kind = 11; // default "topic" in Rust

  /// Routing key to use when sending message to an exchange.
  optional string routing_key = 12;

  /// Prefix for all AMQP queues.
  string queues_prefix = 13; // default "rustus" in Rust

  /// Maximum number of connections for `RabbitMQ`.
  uint64 connection_pool_size = 14; // default 10

  /// Maximum number of opened channels for each connection.
  uint64 channel_pool_size = 15; // default 10

  /// After this amount of time the connection will be dropped.
  optional uint64 idle_connection_timeout = 16;

  /// After this amount of time in seconds, the channel will be closed.
  optional uint64 idle_channels_timeout = 17;

  /// Declares all objects with auto-delete property set.
  bool auto_delete = 18;
}

message KafkaHookOptions {
  /// Kafka urls.
  /// List of brokers to connect to in the format `host:port`.
  /// If you have multiple brokers, separate them with commas.
  /// Corresponds to `bootstrap.servers` in Kafka configuration.
  optional string urls = 1;

  /// Kafka producer client.id.
  optional string client_id = 2;

  // Mutual exclusion: topic OR prefix (Rust validate enforces this).
  oneof topic_or_prefix {
    string topic = 3;
    string prefix = 4;
  }

  /// Kafka required acks.
  optional string required_acks = 5;

  /// Compression codec.
  optional string compression = 6;

  /// Kafka idle timeout in seconds.
  optional uint64 idle_timeout = 7;

  /// Kafka send timeout in seconds.
  optional uint64 send_timeout = 8;

  /// Extra options for Kafka.
  /// In Rust this is ExtraKafkaOptions; here it's a map of strings.
  map<string, string> extra_kafka_opts = 20;
}

message NatsHookOptions {
  /// List of URLs to connect to NATS. Commas are used as delimiters.
  repeated string urls = 1;

  // Mutual exclusion: subject OR prefix (Rust validate enforces this).
  oneof subject_or_prefix {
    string subject = 2;
    string prefix = 3;
  }

  /// Wait for replies from NATS.
  bool wait_for_replies = 4;

  /// NATS user to connect to the server.
  optional string username = 10;

  /// NATS password to connect to the server.
  optional string password = 11;

  /// NATS token to connect to the server.
  optional string token = 12;
}

message NotificationsOptions {
  /// Notifications format.
  ///
  /// This format will be used in all messages about hooks.
  Format hooks_format = 1; // default Format::Default in Rust

  /// Enabled hooks for notifications.
  repeated Hook hooks = 2; // default set in Rust (pre-create, post-create, ...)

  /// Use this option if you use rustus behind any proxy. Like Nginx or Traefik.
  bool behind_proxy = 3;

  /// List of URLS to send webhooks to.
  repeated string hooks_http_urls = 4;

  /// Timeout for all HTTP requests in seconds.
  optional uint64 http_hook_timeout = 5;

  // List of headers to forward from client.
  repeated string hooks_http_proxy_headers = 6;

  /// Directory for executable hook files.
  optional string hooks_dir = 10;

  /// Executable file which must be called for notifying about upload status.
  optional string hooks_file = 11;

  AMQPHooksOptions amqp_hook_opts = 20;
  KafkaHookOptions kafka_hook_opts = 21;
  NatsHookOptions nats_hook_opts = 22;
}

message SentryOptions {
  optional string dsn = 1;

  // sample_rate: f32 in Rust -> float here (no presence tracking for float in proto3
  // unless you use wrapper; we keep it as scalar and document default)
  float sample_rate = 2; // Rust default = 1.0; consumers should apply if zero/absent
}

message RustusConf {
  /// Rustus server host
  string host = 1;

  /// Rustus server port
  uint32 port = 2;

  bool disable_health_access_log = 3;

  /// Rustus base API url
  string url = 4;

  /// Allowed hosts for CORS protocol.
  repeated string cors = 10;

  /// Maximum payload size.
  uint64 max_body_size = 11;

  /// Rustus maximum log level (string; maps to log::LevelFilter in Rust)
  string log_level = 12;

  /// Number of actix workers (optional: None -> auto)
  optional uint64 workers = 13;

  /// Enabled extensions for TUS protocol.
  repeated Extension tus_extensions = 14;

  /// Allow creation of empty files when Upload-Length header equals 0.
  bool allow_empty = 15;

  /// Remove part files after concatenation is done.
  bool remove_parts = 16;

  /// Maximum size of file that can be uploaded. Optional -> presence matters.
  optional uint64 max_file_size = 17;

  // Nested option messages
  DataStorageOptions storage_opts = 20;
  InfoStoreOptions info_storage_opts = 21;
  NotificationsOptions notification_opts = 22;
  SentryOptions sentry_opts = 23;
}
