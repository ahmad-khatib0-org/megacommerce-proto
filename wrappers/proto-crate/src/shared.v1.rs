// This file is @generated by prost-build.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringMap {
    #[prost(map = "string, string", tag = "1")]
    pub data: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NestedStringMap {
    #[prost(map = "string, message", tag = "1")]
    pub data: ::std::collections::HashMap<::prost::alloc::string::String, StringMap>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OrderDirection {
    #[prost(oneof = "order_direction::Order", tags = "1, 2")]
    pub order: ::core::option::Option<order_direction::Order>,
}
/// Nested message and enum types in `OrderDirection`.
pub mod order_direction {
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Order {
        #[prost(bool, tag = "1")]
        Asc(bool),
        #[prost(bool, tag = "2")]
        Desc(bool),
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuccessResponseData {
    #[prost(string, optional, tag = "1")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "2")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Custom Any message to avoid google.protobuf.Any issues
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Any {
    /// Identifies the type of the serialized message
    #[prost(string, tag = "1")]
    pub type_url: ::prost::alloc::string::String,
    /// Serialized proto data
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Empty {}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppError {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// displayed to the end user without debugging info
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Internal debug info
    #[prost(string, tag = "3")]
    pub detailed_error: ::prost::alloc::string::String,
    /// For correlation
    #[prost(string, tag = "4")]
    pub request_id: ::prost::alloc::string::String,
    /// grpc status code
    #[prost(int32, tag = "5")]
    pub status_code: i32,
    /// Code path or func name
    #[prost(string, tag = "6")]
    pub r#where: ::prost::alloc::string::String,
    /// If false, i18n may not apply
    #[prost(bool, tag = "7")]
    pub skip_translation: bool,
    #[prost(message, optional, tag = "8")]
    pub errors: ::core::option::Option<StringMap>,
    #[prost(message, optional, tag = "9")]
    pub errors_nested: ::core::option::Option<NestedStringMap>,
}
/// `Struct` represents a structured data value, consisting of fields
/// which map to dynamically typed values. In some languages, `Struct`
/// might be supported by a native representation. For example, in
/// scripting languages like JS a struct is represented as an
/// object. The details of that representation are described together
/// with the proto support for the language.
///
/// The JSON representation for `Struct` is JSON object.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Struct {
    /// Unordered map of dynamically typed values.
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
/// `Value` represents a dynamically typed value which can be either
/// null, a number, a string, a boolean, a recursive struct value, or a
/// list of values. A producer of value is expected to set one of these
/// variants. Absence of any variant indicates an error.
///
/// The JSON representation for `Value` is JSON value.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    /// The kind of value.
    #[prost(oneof = "value::Kind", tags = "1, 2, 3, 4, 5, 6")]
    pub kind: ::core::option::Option<value::Kind>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    /// The kind of value.
    #[derive(serde::Serialize, serde::Deserialize)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Represents a null value.
        #[prost(enumeration = "super::NullValue", tag = "1")]
        NullValue(i32),
        /// Represents a double value.
        #[prost(double, tag = "2")]
        NumberValue(f64),
        /// Represents a string value.
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        /// Represents a boolean value.
        #[prost(bool, tag = "4")]
        BoolValue(bool),
        /// Represents a structured value.
        #[prost(message, tag = "5")]
        StructValue(super::Struct),
        /// Represents a repeated `Value`.
        #[prost(message, tag = "6")]
        ListValue(super::ListValue),
    }
}
/// `ListValue` is a wrapper around a repeated field of values.
///
/// The JSON representation for `ListValue` is JSON array.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListValue {
    /// Repeated field of dynamically typed values.
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
/// `NullValue` is a singleton enumeration to represent the null value for the
/// `Value` type union.
///
/// The JSON representation for `NullValue` is JSON `null`.
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NullValue {
    /// Null value.
    NullValue = 0,
}
impl NullValue {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NullValue => "NULL_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NULL_VALUE" => Some(Self::NullValue),
            _ => None,
        }
    }
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attachment {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub file_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub file_size: i64,
    #[prost(string, tag = "5")]
    pub file_extension: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub base64: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub exif_orientation: i32,
    #[prost(message, optional, tag = "8")]
    pub crop: ::core::option::Option<Crop>,
    /// arbitrary JSON-like object
    #[prost(message, optional, tag = "9")]
    pub metadata: ::core::option::Option<Struct>,
    /// usually set by the backend
    #[prost(bytes = "vec", tag = "10")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// usually set by the backend
    #[prost(string, tag = "11")]
    pub mime: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Crop {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub width: f32,
    #[prost(float, tag = "4")]
    pub height: f32,
    #[prost(float, tag = "5")]
    pub aspect_ratio: f32,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachmentError {
    /// the attachment id
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "AttachmentErrorType", tag = "2")]
    pub r#type: i32,
    /// shown to the user
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
    /// used for the backend
    #[prost(string, tag = "4")]
    pub error: ::prost::alloc::string::String,
}
#[derive(serde::Serialize, serde::Deserialize)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AttachmentErrorType {
    Unspecified = 0,
    InvalidBase64 = 1,
    InvalidFileType = 2,
    BigFile = 3,
    DecodeImg = 4,
    BigDimensionsImg = 5,
    UnsupportedFileType = 6,
}
impl AttachmentErrorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UNSPECIFIED",
            Self::InvalidBase64 => "INVALID_BASE64",
            Self::InvalidFileType => "INVALID_FILE_TYPE",
            Self::BigFile => "BIG_FILE",
            Self::DecodeImg => "DECODE_IMG",
            Self::BigDimensionsImg => "BIG_DIMENSIONS_IMG",
            Self::UnsupportedFileType => "UNSUPPORTED_FILE_TYPE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "INVALID_BASE64" => Some(Self::InvalidBase64),
            "INVALID_FILE_TYPE" => Some(Self::InvalidFileType),
            "BIG_FILE" => Some(Self::BigFile),
            "DECODE_IMG" => Some(Self::DecodeImg),
            "BIG_DIMENSIONS_IMG" => Some(Self::BigDimensionsImg),
            "UNSUPPORTED_FILE_TYPE" => Some(Self::UnsupportedFileType),
            _ => None,
        }
    }
}
