// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: uploader/v1/config.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "uploader.v1";

export enum AvailableDataStorages {
  AVAILABLE_DATA_STORAGES_UNSPECIFIED = 0,
  FILE_STORAGE = 1,
  S3 = 2,
  HYBRID_S3 = 3,
  UNRECOGNIZED = -1,
}

export function availableDataStoragesFromJSON(object: any): AvailableDataStorages {
  switch (object) {
    case 0:
    case "AVAILABLE_DATA_STORAGES_UNSPECIFIED":
      return AvailableDataStorages.AVAILABLE_DATA_STORAGES_UNSPECIFIED;
    case 1:
    case "FILE_STORAGE":
      return AvailableDataStorages.FILE_STORAGE;
    case 2:
    case "S3":
      return AvailableDataStorages.S3;
    case 3:
    case "HYBRID_S3":
      return AvailableDataStorages.HYBRID_S3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AvailableDataStorages.UNRECOGNIZED;
  }
}

export function availableDataStoragesToJSON(object: AvailableDataStorages): string {
  switch (object) {
    case AvailableDataStorages.AVAILABLE_DATA_STORAGES_UNSPECIFIED:
      return "AVAILABLE_DATA_STORAGES_UNSPECIFIED";
    case AvailableDataStorages.FILE_STORAGE:
      return "FILE_STORAGE";
    case AvailableDataStorages.S3:
      return "S3";
    case AvailableDataStorages.HYBRID_S3:
      return "HYBRID_S3";
    case AvailableDataStorages.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum AvailableInfoStorages {
  AVAILABLE_INFO_STORAGES_UNSPECIFIED = 0,
  FILES = 1,
  REDIS = 2,
  POSTGRES = 3,
  UNRECOGNIZED = -1,
}

export function availableInfoStoragesFromJSON(object: any): AvailableInfoStorages {
  switch (object) {
    case 0:
    case "AVAILABLE_INFO_STORAGES_UNSPECIFIED":
      return AvailableInfoStorages.AVAILABLE_INFO_STORAGES_UNSPECIFIED;
    case 1:
    case "FILES":
      return AvailableInfoStorages.FILES;
    case 2:
    case "REDIS":
      return AvailableInfoStorages.REDIS;
    case 3:
    case "POSTGRES":
      return AvailableInfoStorages.POSTGRES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AvailableInfoStorages.UNRECOGNIZED;
  }
}

export function availableInfoStoragesToJSON(object: AvailableInfoStorages): string {
  switch (object) {
    case AvailableInfoStorages.AVAILABLE_INFO_STORAGES_UNSPECIFIED:
      return "AVAILABLE_INFO_STORAGES_UNSPECIFIED";
    case AvailableInfoStorages.FILES:
      return "FILES";
    case AvailableInfoStorages.REDIS:
      return "REDIS";
    case AvailableInfoStorages.POSTGRES:
      return "POSTGRES";
    case AvailableInfoStorages.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Hook {
  HOOK_UNSPECIFIED = 0,
  PRE_CREATE = 1,
  POST_CREATE = 2,
  POST_RECEIVE = 3,
  PRE_TERMINATE = 4,
  POST_TERMINATE = 5,
  POST_FINISH = 6,
  UNRECOGNIZED = -1,
}

export function hookFromJSON(object: any): Hook {
  switch (object) {
    case 0:
    case "HOOK_UNSPECIFIED":
      return Hook.HOOK_UNSPECIFIED;
    case 1:
    case "PRE_CREATE":
      return Hook.PRE_CREATE;
    case 2:
    case "POST_CREATE":
      return Hook.POST_CREATE;
    case 3:
    case "POST_RECEIVE":
      return Hook.POST_RECEIVE;
    case 4:
    case "PRE_TERMINATE":
      return Hook.PRE_TERMINATE;
    case 5:
    case "POST_TERMINATE":
      return Hook.POST_TERMINATE;
    case 6:
    case "POST_FINISH":
      return Hook.POST_FINISH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Hook.UNRECOGNIZED;
  }
}

export function hookToJSON(object: Hook): string {
  switch (object) {
    case Hook.HOOK_UNSPECIFIED:
      return "HOOK_UNSPECIFIED";
    case Hook.PRE_CREATE:
      return "PRE_CREATE";
    case Hook.POST_CREATE:
      return "POST_CREATE";
    case Hook.POST_RECEIVE:
      return "POST_RECEIVE";
    case Hook.PRE_TERMINATE:
      return "PRE_TERMINATE";
    case Hook.POST_TERMINATE:
      return "POST_TERMINATE";
    case Hook.POST_FINISH:
      return "POST_FINISH";
    case Hook.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Format {
  FORMAT_UNSPECIFIED = 0,
  DEFAULT = 1,
  V2 = 2,
  UNRECOGNIZED = -1,
}

export function formatFromJSON(object: any): Format {
  switch (object) {
    case 0:
    case "FORMAT_UNSPECIFIED":
      return Format.FORMAT_UNSPECIFIED;
    case 1:
    case "DEFAULT":
      return Format.DEFAULT;
    case 2:
    case "V2":
      return Format.V2;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Format.UNRECOGNIZED;
  }
}

export function formatToJSON(object: Format): string {
  switch (object) {
    case Format.FORMAT_UNSPECIFIED:
      return "FORMAT_UNSPECIFIED";
    case Format.DEFAULT:
      return "DEFAULT";
    case Format.V2:
      return "V2";
    case Format.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Extension {
  EXTENSION_UNSPECIFIED = 0,
  GETTING = 1,
  CREATION = 2,
  CREATION_WITH_UPLOAD = 3,
  CREATION_DEFER_LENGTH = 4,
  TERMINATION = 5,
  CONCATENATION = 6,
  CHECKSUM = 7,
  UNRECOGNIZED = -1,
}

export function extensionFromJSON(object: any): Extension {
  switch (object) {
    case 0:
    case "EXTENSION_UNSPECIFIED":
      return Extension.EXTENSION_UNSPECIFIED;
    case 1:
    case "GETTING":
      return Extension.GETTING;
    case 2:
    case "CREATION":
      return Extension.CREATION;
    case 3:
    case "CREATION_WITH_UPLOAD":
      return Extension.CREATION_WITH_UPLOAD;
    case 4:
    case "CREATION_DEFER_LENGTH":
      return Extension.CREATION_DEFER_LENGTH;
    case 5:
    case "TERMINATION":
      return Extension.TERMINATION;
    case 6:
    case "CONCATENATION":
      return Extension.CONCATENATION;
    case 7:
    case "CHECKSUM":
      return Extension.CHECKSUM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Extension.UNRECOGNIZED;
  }
}

export function extensionToJSON(object: Extension): string {
  switch (object) {
    case Extension.EXTENSION_UNSPECIFIED:
      return "EXTENSION_UNSPECIFIED";
    case Extension.GETTING:
      return "GETTING";
    case Extension.CREATION:
      return "CREATION";
    case Extension.CREATION_WITH_UPLOAD:
      return "CREATION_WITH_UPLOAD";
    case Extension.CREATION_DEFER_LENGTH:
      return "CREATION_DEFER_LENGTH";
    case Extension.TERMINATION:
      return "TERMINATION";
    case Extension.CONCATENATION:
      return "CONCATENATION";
    case Extension.CHECKSUM:
      return "CHECKSUM";
    case Extension.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DataStorageOptions {
  /**
   * Rustus storage type.
   *
   * Storages are used to store uploads.
   */
  storage: AvailableDataStorages;
  /**
   * Rustus data directory
   *
   * This directory is used to store files for all `file_storage` storages.
   * PathBuf in Rust -> string path here.
   */
  dataDir: string;
  /**
   * Storage directory structure. This template shows inner directory structure.
   * You can use following variables: day, month, year or even environment variables.
   * Example: "/year/month/day/env[HOSTNAME]/".
   */
  dirStructure: string;
  /** Forces fsync call after writing chunk to filesystem. Useful for network filesystems. */
  forceFsync: boolean;
  /**
   * S3 bucket to upload files to.
   *
   * This parameter is required for s3-based storages.
   */
  s3Bucket?:
    | string
    | undefined;
  /**
   * S3 region.
   *
   * This parameter is required for s3-based storages.
   */
  s3Region?:
    | string
    | undefined;
  /**
   * S3 access key.
   *
   * This parameter is required for s3-based storages.
   */
  s3AccessKey?:
    | string
    | undefined;
  /**
   * S3 access key path.
   *
   * path to file that has s3-access-key inside.
   *
   * This parameter is used for s3-based storages.
   */
  s3AccessKeyPath?:
    | string
    | undefined;
  /**
   * S3 secret key.
   *
   * This parameter is required for s3-based storages.
   */
  s3SecretKey?:
    | string
    | undefined;
  /**
   * S3 secret key path.
   *
   * path to file that has s3-secret-key inside.
   *
   * This parameter is required for s3-based storages.
   */
  s3SecretKeyPath?:
    | string
    | undefined;
  /**
   * S3 URL.
   *
   * This parameter is required for s3-based storages.
   */
  s3Url?:
    | string
    | undefined;
  /**
   * S3 force path style.
   *
   * This parameter is required for some s3-based storages (e.g. MinIO).
   */
  s3ForcePathStyle: boolean;
  /**
   * S3 security token.
   *
   * This parameter is used for temporary credentials.
   */
  s3SecurityToken?:
    | string
    | undefined;
  /** S3 session token. */
  s3SessionToken?:
    | string
    | undefined;
  /** S3 profile. */
  s3Profile?:
    | string
    | undefined;
  /**
   * Additional S3 headers. These headers are passed to every request to s3.
   * Useful for configuring ACLs.
   */
  s3Headers?:
    | string
    | undefined;
  /**
   * Number of concurrent downloads of partial files from S3.
   * When performing concatenation, Rustus downloads all partial files
   * from S3 and concatenates them into a single file.
   *
   * This parameter controls the number of concurrent downloads.
   */
  s3ConcatConcurrentDownloads: number;
}

export interface InfoStoreOptions {
  /**
   * / Type of info storage.
   * /
   * / Info storages are used to store information about uploads.
   * /
   * / This information is used in HEAD requests.
   */
  infoStorage: AvailableInfoStorages;
  /**
   * / Rustus info directory
   * /
   * / This directory is used to store .info files for `file_info_storage`.
   */
  infoDir: string;
  /**
   * / Connection string for remote info storages.
   * /
   * / This connection string is used for storages which require connection.
   * / Examples of such storages are `Postgres`, `MySQL` or `Redis`.
   * /
   * / Value must include all connection details.
   */
  infoDbDsn?:
    | string
    | undefined;
  /** redis_info_expiration: Option<usize> in Rust -> optional uint64 here */
  redisInfoExpiration?: string | undefined;
}

export interface AMQPHooksOptions {
  /** / Url for AMQP server. */
  url?:
    | string
    | undefined;
  /** / Rustus will create exchange if enabled. */
  declareExchange: boolean;
  /**
   * / Rustus will create all queues for communication and bind them
   * / to exchange if enabled.
   */
  declareQueues: boolean;
  /** / Durability type of exchange. */
  durableExchange: boolean;
  /** / Durability type of queues. */
  durableQueues: boolean;
  /** / Adds celery specific headers. */
  celery: boolean;
  /** / Name of amqp exchange. */
  exchange: string;
  /** / Exchange kind. */
  exchangeKind: string;
  /** / Routing key to use when sending message to an exchange. */
  routingKey?:
    | string
    | undefined;
  /** / Prefix for all AMQP queues. */
  queuesPrefix: string;
  /** / Maximum number of connections for `RabbitMQ`. */
  connectionPoolSize: string;
  /** / Maximum number of opened channels for each connection. */
  channelPoolSize: string;
  /** / After this amount of time the connection will be dropped. */
  idleConnectionTimeout?:
    | string
    | undefined;
  /** / After this amount of time in seconds, the channel will be closed. */
  idleChannelsTimeout?:
    | string
    | undefined;
  /** / Declares all objects with auto-delete property set. */
  autoDelete: boolean;
}

export interface KafkaHookOptions {
  /**
   * / Kafka urls.
   * / List of brokers to connect to in the format `host:port`.
   * / If you have multiple brokers, separate them with commas.
   * / Corresponds to `bootstrap.servers` in Kafka configuration.
   */
  urls?:
    | string
    | undefined;
  /** / Kafka producer client.id. */
  clientId?: string | undefined;
  topic?: string | undefined;
  prefix?:
    | string
    | undefined;
  /** / Kafka required acks. */
  requiredAcks?:
    | string
    | undefined;
  /** / Compression codec. */
  compression?:
    | string
    | undefined;
  /** / Kafka idle timeout in seconds. */
  idleTimeout?:
    | string
    | undefined;
  /** / Kafka send timeout in seconds. */
  sendTimeout?:
    | string
    | undefined;
  /**
   * / Extra options for Kafka.
   * / In Rust this is ExtraKafkaOptions; here it's a map of strings.
   */
  extraKafkaOpts: { [key: string]: string };
}

export interface KafkaHookOptions_ExtraKafkaOptsEntry {
  key: string;
  value: string;
}

export interface NatsHookOptions {
  /** / List of URLs to connect to NATS. Commas are used as delimiters. */
  urls: string[];
  subject?: string | undefined;
  prefix?:
    | string
    | undefined;
  /** / Wait for replies from NATS. */
  waitForReplies: boolean;
  /** / NATS user to connect to the server. */
  username?:
    | string
    | undefined;
  /** / NATS password to connect to the server. */
  password?:
    | string
    | undefined;
  /** / NATS token to connect to the server. */
  token?: string | undefined;
}

export interface NotificationsOptions {
  /**
   * / Notifications format.
   * /
   * / This format will be used in all messages about hooks.
   */
  hooksFormat: Format;
  /** / Enabled hooks for notifications. */
  hooks: Hook[];
  /** / Use this option if you use rustus behind any proxy. Like Nginx or Traefik. */
  behindProxy: boolean;
  /** / List of URLS to send webhooks to. */
  hooksHttpUrls: string[];
  /** / Timeout for all HTTP requests in seconds. */
  httpHookTimeout?:
    | string
    | undefined;
  /** List of headers to forward from client. */
  hooksHttpProxyHeaders: string[];
  /** / Directory for executable hook files. */
  hooksDir?:
    | string
    | undefined;
  /** / Executable file which must be called for notifying about upload status. */
  hooksFile?: string | undefined;
  amqpHookOpts?: AMQPHooksOptions | undefined;
  kafkaHookOpts?: KafkaHookOptions | undefined;
  natsHookOpts?: NatsHookOptions | undefined;
}

export interface SentryOptions {
  dsn?:
    | string
    | undefined;
  /**
   * sample_rate: f32 in Rust -> float here (no presence tracking for float in proto3
   * unless you use wrapper; we keep it as scalar and document default)
   */
  sampleRate: number;
}

export interface RustusConf {
  /** / Rustus server host */
  host: string;
  /** / Rustus server port */
  port: number;
  disableHealthAccessLog: boolean;
  /** / Rustus base API url */
  url: string;
  /** / Allowed hosts for CORS protocol. */
  cors: string[];
  /** / Maximum payload size. */
  maxBodySize: string;
  /** / Rustus maximum log level (string; maps to log::LevelFilter in Rust) */
  logLevel: string;
  /** / Number of actix workers (optional: None -> auto) */
  workers?:
    | string
    | undefined;
  /** / Enabled extensions for TUS protocol. */
  tusExtensions: Extension[];
  /** / Allow creation of empty files when Upload-Length header equals 0. */
  allowEmpty: boolean;
  /** / Remove part files after concatenation is done. */
  removeParts: boolean;
  /** / Maximum size of file that can be uploaded. Optional -> presence matters. */
  maxFileSize?:
    | string
    | undefined;
  /** Nested option messages */
  storageOpts?: DataStorageOptions | undefined;
  infoStorageOpts?: InfoStoreOptions | undefined;
  notificationOpts?: NotificationsOptions | undefined;
  sentryOpts?: SentryOptions | undefined;
}

function createBaseDataStorageOptions(): DataStorageOptions {
  return {
    storage: 0,
    dataDir: "",
    dirStructure: "",
    forceFsync: false,
    s3Bucket: undefined,
    s3Region: undefined,
    s3AccessKey: undefined,
    s3AccessKeyPath: undefined,
    s3SecretKey: undefined,
    s3SecretKeyPath: undefined,
    s3Url: undefined,
    s3ForcePathStyle: false,
    s3SecurityToken: undefined,
    s3SessionToken: undefined,
    s3Profile: undefined,
    s3Headers: undefined,
    s3ConcatConcurrentDownloads: 0,
  };
}

export const DataStorageOptions: MessageFns<DataStorageOptions> = {
  encode(message: DataStorageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.storage !== 0) {
      writer.uint32(8).int32(message.storage);
    }
    if (message.dataDir !== "") {
      writer.uint32(18).string(message.dataDir);
    }
    if (message.dirStructure !== "") {
      writer.uint32(26).string(message.dirStructure);
    }
    if (message.forceFsync !== false) {
      writer.uint32(32).bool(message.forceFsync);
    }
    if (message.s3Bucket !== undefined) {
      writer.uint32(82).string(message.s3Bucket);
    }
    if (message.s3Region !== undefined) {
      writer.uint32(90).string(message.s3Region);
    }
    if (message.s3AccessKey !== undefined) {
      writer.uint32(98).string(message.s3AccessKey);
    }
    if (message.s3AccessKeyPath !== undefined) {
      writer.uint32(106).string(message.s3AccessKeyPath);
    }
    if (message.s3SecretKey !== undefined) {
      writer.uint32(114).string(message.s3SecretKey);
    }
    if (message.s3SecretKeyPath !== undefined) {
      writer.uint32(122).string(message.s3SecretKeyPath);
    }
    if (message.s3Url !== undefined) {
      writer.uint32(130).string(message.s3Url);
    }
    if (message.s3ForcePathStyle !== false) {
      writer.uint32(136).bool(message.s3ForcePathStyle);
    }
    if (message.s3SecurityToken !== undefined) {
      writer.uint32(146).string(message.s3SecurityToken);
    }
    if (message.s3SessionToken !== undefined) {
      writer.uint32(154).string(message.s3SessionToken);
    }
    if (message.s3Profile !== undefined) {
      writer.uint32(162).string(message.s3Profile);
    }
    if (message.s3Headers !== undefined) {
      writer.uint32(170).string(message.s3Headers);
    }
    if (message.s3ConcatConcurrentDownloads !== 0) {
      writer.uint32(176).uint32(message.s3ConcatConcurrentDownloads);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataStorageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataStorageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.storage = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataDir = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dirStructure = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.forceFsync = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.s3Bucket = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.s3Region = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.s3AccessKey = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.s3AccessKeyPath = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.s3SecretKey = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.s3SecretKeyPath = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.s3Url = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.s3ForcePathStyle = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.s3SecurityToken = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.s3SessionToken = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.s3Profile = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.s3Headers = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.s3ConcatConcurrentDownloads = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataStorageOptions {
    return {
      storage: isSet(object.storage) ? availableDataStoragesFromJSON(object.storage) : 0,
      dataDir: isSet(object.dataDir) ? globalThis.String(object.dataDir) : "",
      dirStructure: isSet(object.dirStructure) ? globalThis.String(object.dirStructure) : "",
      forceFsync: isSet(object.forceFsync) ? globalThis.Boolean(object.forceFsync) : false,
      s3Bucket: isSet(object.s3Bucket) ? globalThis.String(object.s3Bucket) : undefined,
      s3Region: isSet(object.s3Region) ? globalThis.String(object.s3Region) : undefined,
      s3AccessKey: isSet(object.s3AccessKey) ? globalThis.String(object.s3AccessKey) : undefined,
      s3AccessKeyPath: isSet(object.s3AccessKeyPath) ? globalThis.String(object.s3AccessKeyPath) : undefined,
      s3SecretKey: isSet(object.s3SecretKey) ? globalThis.String(object.s3SecretKey) : undefined,
      s3SecretKeyPath: isSet(object.s3SecretKeyPath) ? globalThis.String(object.s3SecretKeyPath) : undefined,
      s3Url: isSet(object.s3Url) ? globalThis.String(object.s3Url) : undefined,
      s3ForcePathStyle: isSet(object.s3ForcePathStyle) ? globalThis.Boolean(object.s3ForcePathStyle) : false,
      s3SecurityToken: isSet(object.s3SecurityToken) ? globalThis.String(object.s3SecurityToken) : undefined,
      s3SessionToken: isSet(object.s3SessionToken) ? globalThis.String(object.s3SessionToken) : undefined,
      s3Profile: isSet(object.s3Profile) ? globalThis.String(object.s3Profile) : undefined,
      s3Headers: isSet(object.s3Headers) ? globalThis.String(object.s3Headers) : undefined,
      s3ConcatConcurrentDownloads: isSet(object.s3ConcatConcurrentDownloads)
        ? globalThis.Number(object.s3ConcatConcurrentDownloads)
        : 0,
    };
  },

  toJSON(message: DataStorageOptions): unknown {
    const obj: any = {};
    if (message.storage !== 0) {
      obj.storage = availableDataStoragesToJSON(message.storage);
    }
    if (message.dataDir !== "") {
      obj.dataDir = message.dataDir;
    }
    if (message.dirStructure !== "") {
      obj.dirStructure = message.dirStructure;
    }
    if (message.forceFsync !== false) {
      obj.forceFsync = message.forceFsync;
    }
    if (message.s3Bucket !== undefined) {
      obj.s3Bucket = message.s3Bucket;
    }
    if (message.s3Region !== undefined) {
      obj.s3Region = message.s3Region;
    }
    if (message.s3AccessKey !== undefined) {
      obj.s3AccessKey = message.s3AccessKey;
    }
    if (message.s3AccessKeyPath !== undefined) {
      obj.s3AccessKeyPath = message.s3AccessKeyPath;
    }
    if (message.s3SecretKey !== undefined) {
      obj.s3SecretKey = message.s3SecretKey;
    }
    if (message.s3SecretKeyPath !== undefined) {
      obj.s3SecretKeyPath = message.s3SecretKeyPath;
    }
    if (message.s3Url !== undefined) {
      obj.s3Url = message.s3Url;
    }
    if (message.s3ForcePathStyle !== false) {
      obj.s3ForcePathStyle = message.s3ForcePathStyle;
    }
    if (message.s3SecurityToken !== undefined) {
      obj.s3SecurityToken = message.s3SecurityToken;
    }
    if (message.s3SessionToken !== undefined) {
      obj.s3SessionToken = message.s3SessionToken;
    }
    if (message.s3Profile !== undefined) {
      obj.s3Profile = message.s3Profile;
    }
    if (message.s3Headers !== undefined) {
      obj.s3Headers = message.s3Headers;
    }
    if (message.s3ConcatConcurrentDownloads !== 0) {
      obj.s3ConcatConcurrentDownloads = Math.round(message.s3ConcatConcurrentDownloads);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataStorageOptions>, I>>(base?: I): DataStorageOptions {
    return DataStorageOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataStorageOptions>, I>>(object: I): DataStorageOptions {
    const message = createBaseDataStorageOptions();
    message.storage = object.storage ?? 0;
    message.dataDir = object.dataDir ?? "";
    message.dirStructure = object.dirStructure ?? "";
    message.forceFsync = object.forceFsync ?? false;
    message.s3Bucket = object.s3Bucket ?? undefined;
    message.s3Region = object.s3Region ?? undefined;
    message.s3AccessKey = object.s3AccessKey ?? undefined;
    message.s3AccessKeyPath = object.s3AccessKeyPath ?? undefined;
    message.s3SecretKey = object.s3SecretKey ?? undefined;
    message.s3SecretKeyPath = object.s3SecretKeyPath ?? undefined;
    message.s3Url = object.s3Url ?? undefined;
    message.s3ForcePathStyle = object.s3ForcePathStyle ?? false;
    message.s3SecurityToken = object.s3SecurityToken ?? undefined;
    message.s3SessionToken = object.s3SessionToken ?? undefined;
    message.s3Profile = object.s3Profile ?? undefined;
    message.s3Headers = object.s3Headers ?? undefined;
    message.s3ConcatConcurrentDownloads = object.s3ConcatConcurrentDownloads ?? 0;
    return message;
  },
};

function createBaseInfoStoreOptions(): InfoStoreOptions {
  return { infoStorage: 0, infoDir: "", infoDbDsn: undefined, redisInfoExpiration: undefined };
}

export const InfoStoreOptions: MessageFns<InfoStoreOptions> = {
  encode(message: InfoStoreOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.infoStorage !== 0) {
      writer.uint32(8).int32(message.infoStorage);
    }
    if (message.infoDir !== "") {
      writer.uint32(18).string(message.infoDir);
    }
    if (message.infoDbDsn !== undefined) {
      writer.uint32(26).string(message.infoDbDsn);
    }
    if (message.redisInfoExpiration !== undefined) {
      writer.uint32(32).uint64(message.redisInfoExpiration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InfoStoreOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoStoreOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.infoStorage = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.infoDir = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.infoDbDsn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.redisInfoExpiration = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InfoStoreOptions {
    return {
      infoStorage: isSet(object.infoStorage) ? availableInfoStoragesFromJSON(object.infoStorage) : 0,
      infoDir: isSet(object.infoDir) ? globalThis.String(object.infoDir) : "",
      infoDbDsn: isSet(object.infoDbDsn) ? globalThis.String(object.infoDbDsn) : undefined,
      redisInfoExpiration: isSet(object.redisInfoExpiration)
        ? globalThis.String(object.redisInfoExpiration)
        : undefined,
    };
  },

  toJSON(message: InfoStoreOptions): unknown {
    const obj: any = {};
    if (message.infoStorage !== 0) {
      obj.infoStorage = availableInfoStoragesToJSON(message.infoStorage);
    }
    if (message.infoDir !== "") {
      obj.infoDir = message.infoDir;
    }
    if (message.infoDbDsn !== undefined) {
      obj.infoDbDsn = message.infoDbDsn;
    }
    if (message.redisInfoExpiration !== undefined) {
      obj.redisInfoExpiration = message.redisInfoExpiration;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InfoStoreOptions>, I>>(base?: I): InfoStoreOptions {
    return InfoStoreOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InfoStoreOptions>, I>>(object: I): InfoStoreOptions {
    const message = createBaseInfoStoreOptions();
    message.infoStorage = object.infoStorage ?? 0;
    message.infoDir = object.infoDir ?? "";
    message.infoDbDsn = object.infoDbDsn ?? undefined;
    message.redisInfoExpiration = object.redisInfoExpiration ?? undefined;
    return message;
  },
};

function createBaseAMQPHooksOptions(): AMQPHooksOptions {
  return {
    url: undefined,
    declareExchange: false,
    declareQueues: false,
    durableExchange: false,
    durableQueues: false,
    celery: false,
    exchange: "",
    exchangeKind: "",
    routingKey: undefined,
    queuesPrefix: "",
    connectionPoolSize: "0",
    channelPoolSize: "0",
    idleConnectionTimeout: undefined,
    idleChannelsTimeout: undefined,
    autoDelete: false,
  };
}

export const AMQPHooksOptions: MessageFns<AMQPHooksOptions> = {
  encode(message: AMQPHooksOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.url !== undefined) {
      writer.uint32(10).string(message.url);
    }
    if (message.declareExchange !== false) {
      writer.uint32(16).bool(message.declareExchange);
    }
    if (message.declareQueues !== false) {
      writer.uint32(24).bool(message.declareQueues);
    }
    if (message.durableExchange !== false) {
      writer.uint32(32).bool(message.durableExchange);
    }
    if (message.durableQueues !== false) {
      writer.uint32(40).bool(message.durableQueues);
    }
    if (message.celery !== false) {
      writer.uint32(48).bool(message.celery);
    }
    if (message.exchange !== "") {
      writer.uint32(82).string(message.exchange);
    }
    if (message.exchangeKind !== "") {
      writer.uint32(90).string(message.exchangeKind);
    }
    if (message.routingKey !== undefined) {
      writer.uint32(98).string(message.routingKey);
    }
    if (message.queuesPrefix !== "") {
      writer.uint32(106).string(message.queuesPrefix);
    }
    if (message.connectionPoolSize !== "0") {
      writer.uint32(112).uint64(message.connectionPoolSize);
    }
    if (message.channelPoolSize !== "0") {
      writer.uint32(120).uint64(message.channelPoolSize);
    }
    if (message.idleConnectionTimeout !== undefined) {
      writer.uint32(128).uint64(message.idleConnectionTimeout);
    }
    if (message.idleChannelsTimeout !== undefined) {
      writer.uint32(136).uint64(message.idleChannelsTimeout);
    }
    if (message.autoDelete !== false) {
      writer.uint32(144).bool(message.autoDelete);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AMQPHooksOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAMQPHooksOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.declareExchange = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.declareQueues = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.durableExchange = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.durableQueues = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.celery = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.exchangeKind = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.routingKey = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.queuesPrefix = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.connectionPoolSize = reader.uint64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.channelPoolSize = reader.uint64().toString();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.idleConnectionTimeout = reader.uint64().toString();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.idleChannelsTimeout = reader.uint64().toString();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.autoDelete = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AMQPHooksOptions {
    return {
      url: isSet(object.url) ? globalThis.String(object.url) : undefined,
      declareExchange: isSet(object.declareExchange) ? globalThis.Boolean(object.declareExchange) : false,
      declareQueues: isSet(object.declareQueues) ? globalThis.Boolean(object.declareQueues) : false,
      durableExchange: isSet(object.durableExchange) ? globalThis.Boolean(object.durableExchange) : false,
      durableQueues: isSet(object.durableQueues) ? globalThis.Boolean(object.durableQueues) : false,
      celery: isSet(object.celery) ? globalThis.Boolean(object.celery) : false,
      exchange: isSet(object.exchange) ? globalThis.String(object.exchange) : "",
      exchangeKind: isSet(object.exchangeKind) ? globalThis.String(object.exchangeKind) : "",
      routingKey: isSet(object.routingKey) ? globalThis.String(object.routingKey) : undefined,
      queuesPrefix: isSet(object.queuesPrefix) ? globalThis.String(object.queuesPrefix) : "",
      connectionPoolSize: isSet(object.connectionPoolSize) ? globalThis.String(object.connectionPoolSize) : "0",
      channelPoolSize: isSet(object.channelPoolSize) ? globalThis.String(object.channelPoolSize) : "0",
      idleConnectionTimeout: isSet(object.idleConnectionTimeout)
        ? globalThis.String(object.idleConnectionTimeout)
        : undefined,
      idleChannelsTimeout: isSet(object.idleChannelsTimeout)
        ? globalThis.String(object.idleChannelsTimeout)
        : undefined,
      autoDelete: isSet(object.autoDelete) ? globalThis.Boolean(object.autoDelete) : false,
    };
  },

  toJSON(message: AMQPHooksOptions): unknown {
    const obj: any = {};
    if (message.url !== undefined) {
      obj.url = message.url;
    }
    if (message.declareExchange !== false) {
      obj.declareExchange = message.declareExchange;
    }
    if (message.declareQueues !== false) {
      obj.declareQueues = message.declareQueues;
    }
    if (message.durableExchange !== false) {
      obj.durableExchange = message.durableExchange;
    }
    if (message.durableQueues !== false) {
      obj.durableQueues = message.durableQueues;
    }
    if (message.celery !== false) {
      obj.celery = message.celery;
    }
    if (message.exchange !== "") {
      obj.exchange = message.exchange;
    }
    if (message.exchangeKind !== "") {
      obj.exchangeKind = message.exchangeKind;
    }
    if (message.routingKey !== undefined) {
      obj.routingKey = message.routingKey;
    }
    if (message.queuesPrefix !== "") {
      obj.queuesPrefix = message.queuesPrefix;
    }
    if (message.connectionPoolSize !== "0") {
      obj.connectionPoolSize = message.connectionPoolSize;
    }
    if (message.channelPoolSize !== "0") {
      obj.channelPoolSize = message.channelPoolSize;
    }
    if (message.idleConnectionTimeout !== undefined) {
      obj.idleConnectionTimeout = message.idleConnectionTimeout;
    }
    if (message.idleChannelsTimeout !== undefined) {
      obj.idleChannelsTimeout = message.idleChannelsTimeout;
    }
    if (message.autoDelete !== false) {
      obj.autoDelete = message.autoDelete;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AMQPHooksOptions>, I>>(base?: I): AMQPHooksOptions {
    return AMQPHooksOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AMQPHooksOptions>, I>>(object: I): AMQPHooksOptions {
    const message = createBaseAMQPHooksOptions();
    message.url = object.url ?? undefined;
    message.declareExchange = object.declareExchange ?? false;
    message.declareQueues = object.declareQueues ?? false;
    message.durableExchange = object.durableExchange ?? false;
    message.durableQueues = object.durableQueues ?? false;
    message.celery = object.celery ?? false;
    message.exchange = object.exchange ?? "";
    message.exchangeKind = object.exchangeKind ?? "";
    message.routingKey = object.routingKey ?? undefined;
    message.queuesPrefix = object.queuesPrefix ?? "";
    message.connectionPoolSize = object.connectionPoolSize ?? "0";
    message.channelPoolSize = object.channelPoolSize ?? "0";
    message.idleConnectionTimeout = object.idleConnectionTimeout ?? undefined;
    message.idleChannelsTimeout = object.idleChannelsTimeout ?? undefined;
    message.autoDelete = object.autoDelete ?? false;
    return message;
  },
};

function createBaseKafkaHookOptions(): KafkaHookOptions {
  return {
    urls: undefined,
    clientId: undefined,
    topic: undefined,
    prefix: undefined,
    requiredAcks: undefined,
    compression: undefined,
    idleTimeout: undefined,
    sendTimeout: undefined,
    extraKafkaOpts: {},
  };
}

export const KafkaHookOptions: MessageFns<KafkaHookOptions> = {
  encode(message: KafkaHookOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.urls !== undefined) {
      writer.uint32(10).string(message.urls);
    }
    if (message.clientId !== undefined) {
      writer.uint32(18).string(message.clientId);
    }
    if (message.topic !== undefined) {
      writer.uint32(26).string(message.topic);
    }
    if (message.prefix !== undefined) {
      writer.uint32(34).string(message.prefix);
    }
    if (message.requiredAcks !== undefined) {
      writer.uint32(42).string(message.requiredAcks);
    }
    if (message.compression !== undefined) {
      writer.uint32(50).string(message.compression);
    }
    if (message.idleTimeout !== undefined) {
      writer.uint32(56).uint64(message.idleTimeout);
    }
    if (message.sendTimeout !== undefined) {
      writer.uint32(64).uint64(message.sendTimeout);
    }
    Object.entries(message.extraKafkaOpts).forEach(([key, value]) => {
      KafkaHookOptions_ExtraKafkaOptsEntry.encode({ key: key as any, value }, writer.uint32(162).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KafkaHookOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKafkaHookOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.requiredAcks = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.compression = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.idleTimeout = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.sendTimeout = reader.uint64().toString();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          const entry20 = KafkaHookOptions_ExtraKafkaOptsEntry.decode(reader, reader.uint32());
          if (entry20.value !== undefined) {
            message.extraKafkaOpts[entry20.key] = entry20.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KafkaHookOptions {
    return {
      urls: isSet(object.urls) ? globalThis.String(object.urls) : undefined,
      clientId: isSet(object.clientId) ? globalThis.String(object.clientId) : undefined,
      topic: isSet(object.topic) ? globalThis.String(object.topic) : undefined,
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      requiredAcks: isSet(object.requiredAcks) ? globalThis.String(object.requiredAcks) : undefined,
      compression: isSet(object.compression) ? globalThis.String(object.compression) : undefined,
      idleTimeout: isSet(object.idleTimeout) ? globalThis.String(object.idleTimeout) : undefined,
      sendTimeout: isSet(object.sendTimeout) ? globalThis.String(object.sendTimeout) : undefined,
      extraKafkaOpts: isObject(object.extraKafkaOpts)
        ? Object.entries(object.extraKafkaOpts).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: KafkaHookOptions): unknown {
    const obj: any = {};
    if (message.urls !== undefined) {
      obj.urls = message.urls;
    }
    if (message.clientId !== undefined) {
      obj.clientId = message.clientId;
    }
    if (message.topic !== undefined) {
      obj.topic = message.topic;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.requiredAcks !== undefined) {
      obj.requiredAcks = message.requiredAcks;
    }
    if (message.compression !== undefined) {
      obj.compression = message.compression;
    }
    if (message.idleTimeout !== undefined) {
      obj.idleTimeout = message.idleTimeout;
    }
    if (message.sendTimeout !== undefined) {
      obj.sendTimeout = message.sendTimeout;
    }
    if (message.extraKafkaOpts) {
      const entries = Object.entries(message.extraKafkaOpts);
      if (entries.length > 0) {
        obj.extraKafkaOpts = {};
        entries.forEach(([k, v]) => {
          obj.extraKafkaOpts[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KafkaHookOptions>, I>>(base?: I): KafkaHookOptions {
    return KafkaHookOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KafkaHookOptions>, I>>(object: I): KafkaHookOptions {
    const message = createBaseKafkaHookOptions();
    message.urls = object.urls ?? undefined;
    message.clientId = object.clientId ?? undefined;
    message.topic = object.topic ?? undefined;
    message.prefix = object.prefix ?? undefined;
    message.requiredAcks = object.requiredAcks ?? undefined;
    message.compression = object.compression ?? undefined;
    message.idleTimeout = object.idleTimeout ?? undefined;
    message.sendTimeout = object.sendTimeout ?? undefined;
    message.extraKafkaOpts = Object.entries(object.extraKafkaOpts ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseKafkaHookOptions_ExtraKafkaOptsEntry(): KafkaHookOptions_ExtraKafkaOptsEntry {
  return { key: "", value: "" };
}

export const KafkaHookOptions_ExtraKafkaOptsEntry: MessageFns<KafkaHookOptions_ExtraKafkaOptsEntry> = {
  encode(message: KafkaHookOptions_ExtraKafkaOptsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KafkaHookOptions_ExtraKafkaOptsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKafkaHookOptions_ExtraKafkaOptsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KafkaHookOptions_ExtraKafkaOptsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: KafkaHookOptions_ExtraKafkaOptsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KafkaHookOptions_ExtraKafkaOptsEntry>, I>>(
    base?: I,
  ): KafkaHookOptions_ExtraKafkaOptsEntry {
    return KafkaHookOptions_ExtraKafkaOptsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KafkaHookOptions_ExtraKafkaOptsEntry>, I>>(
    object: I,
  ): KafkaHookOptions_ExtraKafkaOptsEntry {
    const message = createBaseKafkaHookOptions_ExtraKafkaOptsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNatsHookOptions(): NatsHookOptions {
  return {
    urls: [],
    subject: undefined,
    prefix: undefined,
    waitForReplies: false,
    username: undefined,
    password: undefined,
    token: undefined,
  };
}

export const NatsHookOptions: MessageFns<NatsHookOptions> = {
  encode(message: NatsHookOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.urls) {
      writer.uint32(10).string(v!);
    }
    if (message.subject !== undefined) {
      writer.uint32(18).string(message.subject);
    }
    if (message.prefix !== undefined) {
      writer.uint32(26).string(message.prefix);
    }
    if (message.waitForReplies !== false) {
      writer.uint32(32).bool(message.waitForReplies);
    }
    if (message.username !== undefined) {
      writer.uint32(82).string(message.username);
    }
    if (message.password !== undefined) {
      writer.uint32(90).string(message.password);
    }
    if (message.token !== undefined) {
      writer.uint32(98).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NatsHookOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNatsHookOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.waitForReplies = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NatsHookOptions {
    return {
      urls: globalThis.Array.isArray(object?.urls) ? object.urls.map((e: any) => globalThis.String(e)) : [],
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : undefined,
      waitForReplies: isSet(object.waitForReplies) ? globalThis.Boolean(object.waitForReplies) : false,
      username: isSet(object.username) ? globalThis.String(object.username) : undefined,
      password: isSet(object.password) ? globalThis.String(object.password) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : undefined,
    };
  },

  toJSON(message: NatsHookOptions): unknown {
    const obj: any = {};
    if (message.urls?.length) {
      obj.urls = message.urls;
    }
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.prefix !== undefined) {
      obj.prefix = message.prefix;
    }
    if (message.waitForReplies !== false) {
      obj.waitForReplies = message.waitForReplies;
    }
    if (message.username !== undefined) {
      obj.username = message.username;
    }
    if (message.password !== undefined) {
      obj.password = message.password;
    }
    if (message.token !== undefined) {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NatsHookOptions>, I>>(base?: I): NatsHookOptions {
    return NatsHookOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NatsHookOptions>, I>>(object: I): NatsHookOptions {
    const message = createBaseNatsHookOptions();
    message.urls = object.urls?.map((e) => e) || [];
    message.subject = object.subject ?? undefined;
    message.prefix = object.prefix ?? undefined;
    message.waitForReplies = object.waitForReplies ?? false;
    message.username = object.username ?? undefined;
    message.password = object.password ?? undefined;
    message.token = object.token ?? undefined;
    return message;
  },
};

function createBaseNotificationsOptions(): NotificationsOptions {
  return {
    hooksFormat: 0,
    hooks: [],
    behindProxy: false,
    hooksHttpUrls: [],
    httpHookTimeout: undefined,
    hooksHttpProxyHeaders: [],
    hooksDir: undefined,
    hooksFile: undefined,
    amqpHookOpts: undefined,
    kafkaHookOpts: undefined,
    natsHookOpts: undefined,
  };
}

export const NotificationsOptions: MessageFns<NotificationsOptions> = {
  encode(message: NotificationsOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hooksFormat !== 0) {
      writer.uint32(8).int32(message.hooksFormat);
    }
    writer.uint32(18).fork();
    for (const v of message.hooks) {
      writer.int32(v);
    }
    writer.join();
    if (message.behindProxy !== false) {
      writer.uint32(24).bool(message.behindProxy);
    }
    for (const v of message.hooksHttpUrls) {
      writer.uint32(34).string(v!);
    }
    if (message.httpHookTimeout !== undefined) {
      writer.uint32(40).uint64(message.httpHookTimeout);
    }
    for (const v of message.hooksHttpProxyHeaders) {
      writer.uint32(50).string(v!);
    }
    if (message.hooksDir !== undefined) {
      writer.uint32(82).string(message.hooksDir);
    }
    if (message.hooksFile !== undefined) {
      writer.uint32(90).string(message.hooksFile);
    }
    if (message.amqpHookOpts !== undefined) {
      AMQPHooksOptions.encode(message.amqpHookOpts, writer.uint32(162).fork()).join();
    }
    if (message.kafkaHookOpts !== undefined) {
      KafkaHookOptions.encode(message.kafkaHookOpts, writer.uint32(170).fork()).join();
    }
    if (message.natsHookOpts !== undefined) {
      NatsHookOptions.encode(message.natsHookOpts, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NotificationsOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotificationsOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hooksFormat = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.hooks.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.hooks.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.behindProxy = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hooksHttpUrls.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.httpHookTimeout = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.hooksHttpProxyHeaders.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.hooksDir = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.hooksFile = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.amqpHookOpts = AMQPHooksOptions.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.kafkaHookOpts = KafkaHookOptions.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.natsHookOpts = NatsHookOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NotificationsOptions {
    return {
      hooksFormat: isSet(object.hooksFormat) ? formatFromJSON(object.hooksFormat) : 0,
      hooks: globalThis.Array.isArray(object?.hooks) ? object.hooks.map((e: any) => hookFromJSON(e)) : [],
      behindProxy: isSet(object.behindProxy) ? globalThis.Boolean(object.behindProxy) : false,
      hooksHttpUrls: globalThis.Array.isArray(object?.hooksHttpUrls)
        ? object.hooksHttpUrls.map((e: any) => globalThis.String(e))
        : [],
      httpHookTimeout: isSet(object.httpHookTimeout) ? globalThis.String(object.httpHookTimeout) : undefined,
      hooksHttpProxyHeaders: globalThis.Array.isArray(object?.hooksHttpProxyHeaders)
        ? object.hooksHttpProxyHeaders.map((e: any) => globalThis.String(e))
        : [],
      hooksDir: isSet(object.hooksDir) ? globalThis.String(object.hooksDir) : undefined,
      hooksFile: isSet(object.hooksFile) ? globalThis.String(object.hooksFile) : undefined,
      amqpHookOpts: isSet(object.amqpHookOpts) ? AMQPHooksOptions.fromJSON(object.amqpHookOpts) : undefined,
      kafkaHookOpts: isSet(object.kafkaHookOpts) ? KafkaHookOptions.fromJSON(object.kafkaHookOpts) : undefined,
      natsHookOpts: isSet(object.natsHookOpts) ? NatsHookOptions.fromJSON(object.natsHookOpts) : undefined,
    };
  },

  toJSON(message: NotificationsOptions): unknown {
    const obj: any = {};
    if (message.hooksFormat !== 0) {
      obj.hooksFormat = formatToJSON(message.hooksFormat);
    }
    if (message.hooks?.length) {
      obj.hooks = message.hooks.map((e) => hookToJSON(e));
    }
    if (message.behindProxy !== false) {
      obj.behindProxy = message.behindProxy;
    }
    if (message.hooksHttpUrls?.length) {
      obj.hooksHttpUrls = message.hooksHttpUrls;
    }
    if (message.httpHookTimeout !== undefined) {
      obj.httpHookTimeout = message.httpHookTimeout;
    }
    if (message.hooksHttpProxyHeaders?.length) {
      obj.hooksHttpProxyHeaders = message.hooksHttpProxyHeaders;
    }
    if (message.hooksDir !== undefined) {
      obj.hooksDir = message.hooksDir;
    }
    if (message.hooksFile !== undefined) {
      obj.hooksFile = message.hooksFile;
    }
    if (message.amqpHookOpts !== undefined) {
      obj.amqpHookOpts = AMQPHooksOptions.toJSON(message.amqpHookOpts);
    }
    if (message.kafkaHookOpts !== undefined) {
      obj.kafkaHookOpts = KafkaHookOptions.toJSON(message.kafkaHookOpts);
    }
    if (message.natsHookOpts !== undefined) {
      obj.natsHookOpts = NatsHookOptions.toJSON(message.natsHookOpts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NotificationsOptions>, I>>(base?: I): NotificationsOptions {
    return NotificationsOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NotificationsOptions>, I>>(object: I): NotificationsOptions {
    const message = createBaseNotificationsOptions();
    message.hooksFormat = object.hooksFormat ?? 0;
    message.hooks = object.hooks?.map((e) => e) || [];
    message.behindProxy = object.behindProxy ?? false;
    message.hooksHttpUrls = object.hooksHttpUrls?.map((e) => e) || [];
    message.httpHookTimeout = object.httpHookTimeout ?? undefined;
    message.hooksHttpProxyHeaders = object.hooksHttpProxyHeaders?.map((e) => e) || [];
    message.hooksDir = object.hooksDir ?? undefined;
    message.hooksFile = object.hooksFile ?? undefined;
    message.amqpHookOpts = (object.amqpHookOpts !== undefined && object.amqpHookOpts !== null)
      ? AMQPHooksOptions.fromPartial(object.amqpHookOpts)
      : undefined;
    message.kafkaHookOpts = (object.kafkaHookOpts !== undefined && object.kafkaHookOpts !== null)
      ? KafkaHookOptions.fromPartial(object.kafkaHookOpts)
      : undefined;
    message.natsHookOpts = (object.natsHookOpts !== undefined && object.natsHookOpts !== null)
      ? NatsHookOptions.fromPartial(object.natsHookOpts)
      : undefined;
    return message;
  },
};

function createBaseSentryOptions(): SentryOptions {
  return { dsn: undefined, sampleRate: 0 };
}

export const SentryOptions: MessageFns<SentryOptions> = {
  encode(message: SentryOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dsn !== undefined) {
      writer.uint32(10).string(message.dsn);
    }
    if (message.sampleRate !== 0) {
      writer.uint32(21).float(message.sampleRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SentryOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSentryOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dsn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.sampleRate = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SentryOptions {
    return {
      dsn: isSet(object.dsn) ? globalThis.String(object.dsn) : undefined,
      sampleRate: isSet(object.sampleRate) ? globalThis.Number(object.sampleRate) : 0,
    };
  },

  toJSON(message: SentryOptions): unknown {
    const obj: any = {};
    if (message.dsn !== undefined) {
      obj.dsn = message.dsn;
    }
    if (message.sampleRate !== 0) {
      obj.sampleRate = message.sampleRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SentryOptions>, I>>(base?: I): SentryOptions {
    return SentryOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SentryOptions>, I>>(object: I): SentryOptions {
    const message = createBaseSentryOptions();
    message.dsn = object.dsn ?? undefined;
    message.sampleRate = object.sampleRate ?? 0;
    return message;
  },
};

function createBaseRustusConf(): RustusConf {
  return {
    host: "",
    port: 0,
    disableHealthAccessLog: false,
    url: "",
    cors: [],
    maxBodySize: "0",
    logLevel: "",
    workers: undefined,
    tusExtensions: [],
    allowEmpty: false,
    removeParts: false,
    maxFileSize: undefined,
    storageOpts: undefined,
    infoStorageOpts: undefined,
    notificationOpts: undefined,
    sentryOpts: undefined,
  };
}

export const RustusConf: MessageFns<RustusConf> = {
  encode(message: RustusConf, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.host !== "") {
      writer.uint32(10).string(message.host);
    }
    if (message.port !== 0) {
      writer.uint32(16).uint32(message.port);
    }
    if (message.disableHealthAccessLog !== false) {
      writer.uint32(24).bool(message.disableHealthAccessLog);
    }
    if (message.url !== "") {
      writer.uint32(34).string(message.url);
    }
    for (const v of message.cors) {
      writer.uint32(82).string(v!);
    }
    if (message.maxBodySize !== "0") {
      writer.uint32(88).uint64(message.maxBodySize);
    }
    if (message.logLevel !== "") {
      writer.uint32(98).string(message.logLevel);
    }
    if (message.workers !== undefined) {
      writer.uint32(104).uint64(message.workers);
    }
    writer.uint32(114).fork();
    for (const v of message.tusExtensions) {
      writer.int32(v);
    }
    writer.join();
    if (message.allowEmpty !== false) {
      writer.uint32(120).bool(message.allowEmpty);
    }
    if (message.removeParts !== false) {
      writer.uint32(128).bool(message.removeParts);
    }
    if (message.maxFileSize !== undefined) {
      writer.uint32(136).uint64(message.maxFileSize);
    }
    if (message.storageOpts !== undefined) {
      DataStorageOptions.encode(message.storageOpts, writer.uint32(162).fork()).join();
    }
    if (message.infoStorageOpts !== undefined) {
      InfoStoreOptions.encode(message.infoStorageOpts, writer.uint32(170).fork()).join();
    }
    if (message.notificationOpts !== undefined) {
      NotificationsOptions.encode(message.notificationOpts, writer.uint32(178).fork()).join();
    }
    if (message.sentryOpts !== undefined) {
      SentryOptions.encode(message.sentryOpts, writer.uint32(186).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RustusConf {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRustusConf();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disableHealthAccessLog = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.cors.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxBodySize = reader.uint64().toString();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.logLevel = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.workers = reader.uint64().toString();
          continue;
        }
        case 14: {
          if (tag === 112) {
            message.tusExtensions.push(reader.int32() as any);

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.tusExtensions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.allowEmpty = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.removeParts = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.maxFileSize = reader.uint64().toString();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.storageOpts = DataStorageOptions.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.infoStorageOpts = InfoStoreOptions.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.notificationOpts = NotificationsOptions.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.sentryOpts = SentryOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RustusConf {
    return {
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      disableHealthAccessLog: isSet(object.disableHealthAccessLog)
        ? globalThis.Boolean(object.disableHealthAccessLog)
        : false,
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      cors: globalThis.Array.isArray(object?.cors) ? object.cors.map((e: any) => globalThis.String(e)) : [],
      maxBodySize: isSet(object.maxBodySize) ? globalThis.String(object.maxBodySize) : "0",
      logLevel: isSet(object.logLevel) ? globalThis.String(object.logLevel) : "",
      workers: isSet(object.workers) ? globalThis.String(object.workers) : undefined,
      tusExtensions: globalThis.Array.isArray(object?.tusExtensions)
        ? object.tusExtensions.map((e: any) => extensionFromJSON(e))
        : [],
      allowEmpty: isSet(object.allowEmpty) ? globalThis.Boolean(object.allowEmpty) : false,
      removeParts: isSet(object.removeParts) ? globalThis.Boolean(object.removeParts) : false,
      maxFileSize: isSet(object.maxFileSize) ? globalThis.String(object.maxFileSize) : undefined,
      storageOpts: isSet(object.storageOpts) ? DataStorageOptions.fromJSON(object.storageOpts) : undefined,
      infoStorageOpts: isSet(object.infoStorageOpts) ? InfoStoreOptions.fromJSON(object.infoStorageOpts) : undefined,
      notificationOpts: isSet(object.notificationOpts)
        ? NotificationsOptions.fromJSON(object.notificationOpts)
        : undefined,
      sentryOpts: isSet(object.sentryOpts) ? SentryOptions.fromJSON(object.sentryOpts) : undefined,
    };
  },

  toJSON(message: RustusConf): unknown {
    const obj: any = {};
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.disableHealthAccessLog !== false) {
      obj.disableHealthAccessLog = message.disableHealthAccessLog;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.cors?.length) {
      obj.cors = message.cors;
    }
    if (message.maxBodySize !== "0") {
      obj.maxBodySize = message.maxBodySize;
    }
    if (message.logLevel !== "") {
      obj.logLevel = message.logLevel;
    }
    if (message.workers !== undefined) {
      obj.workers = message.workers;
    }
    if (message.tusExtensions?.length) {
      obj.tusExtensions = message.tusExtensions.map((e) => extensionToJSON(e));
    }
    if (message.allowEmpty !== false) {
      obj.allowEmpty = message.allowEmpty;
    }
    if (message.removeParts !== false) {
      obj.removeParts = message.removeParts;
    }
    if (message.maxFileSize !== undefined) {
      obj.maxFileSize = message.maxFileSize;
    }
    if (message.storageOpts !== undefined) {
      obj.storageOpts = DataStorageOptions.toJSON(message.storageOpts);
    }
    if (message.infoStorageOpts !== undefined) {
      obj.infoStorageOpts = InfoStoreOptions.toJSON(message.infoStorageOpts);
    }
    if (message.notificationOpts !== undefined) {
      obj.notificationOpts = NotificationsOptions.toJSON(message.notificationOpts);
    }
    if (message.sentryOpts !== undefined) {
      obj.sentryOpts = SentryOptions.toJSON(message.sentryOpts);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RustusConf>, I>>(base?: I): RustusConf {
    return RustusConf.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RustusConf>, I>>(object: I): RustusConf {
    const message = createBaseRustusConf();
    message.host = object.host ?? "";
    message.port = object.port ?? 0;
    message.disableHealthAccessLog = object.disableHealthAccessLog ?? false;
    message.url = object.url ?? "";
    message.cors = object.cors?.map((e) => e) || [];
    message.maxBodySize = object.maxBodySize ?? "0";
    message.logLevel = object.logLevel ?? "";
    message.workers = object.workers ?? undefined;
    message.tusExtensions = object.tusExtensions?.map((e) => e) || [];
    message.allowEmpty = object.allowEmpty ?? false;
    message.removeParts = object.removeParts ?? false;
    message.maxFileSize = object.maxFileSize ?? undefined;
    message.storageOpts = (object.storageOpts !== undefined && object.storageOpts !== null)
      ? DataStorageOptions.fromPartial(object.storageOpts)
      : undefined;
    message.infoStorageOpts = (object.infoStorageOpts !== undefined && object.infoStorageOpts !== null)
      ? InfoStoreOptions.fromPartial(object.infoStorageOpts)
      : undefined;
    message.notificationOpts = (object.notificationOpts !== undefined && object.notificationOpts !== null)
      ? NotificationsOptions.fromPartial(object.notificationOpts)
      : undefined;
    message.sentryOpts = (object.sentryOpts !== undefined && object.sentryOpts !== null)
      ? SentryOptions.fromPartial(object.sentryOpts)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
