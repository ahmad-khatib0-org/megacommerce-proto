// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: uploader/v1/config.proto
// Protobuf C++ Version: 6.31.1

#ifndef uploader_2fv1_2fconfig_2eproto_2epb_2eh
#define uploader_2fv1_2fconfig_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 6031001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/map.h"  // IWYU pragma: export
#include "google/protobuf/map_type_handler.h"  // IWYU pragma: export
#include "google/protobuf/map_entry.h"
#include "google/protobuf/map_field.h"
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_uploader_2fv1_2fconfig_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_uploader_2fv1_2fconfig_2eproto {
  static const ::uint32_t offsets[];
};
extern "C" {
extern const ::google::protobuf::internal::DescriptorTable descriptor_table_uploader_2fv1_2fconfig_2eproto;
}  // extern "C"
namespace uploader {
namespace v1 {
enum AvailableDataStorages : int;
extern const uint32_t AvailableDataStorages_internal_data_[];
enum AvailableInfoStorages : int;
extern const uint32_t AvailableInfoStorages_internal_data_[];
enum Extensions : int;
extern const uint32_t Extensions_internal_data_[];
enum Format : int;
extern const uint32_t Format_internal_data_[];
enum Hook : int;
extern const uint32_t Hook_internal_data_[];
class AMQPHooksOptions;
struct AMQPHooksOptionsDefaultTypeInternal;
extern AMQPHooksOptionsDefaultTypeInternal _AMQPHooksOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull AMQPHooksOptions_class_data_;
class DataStorageOptions;
struct DataStorageOptionsDefaultTypeInternal;
extern DataStorageOptionsDefaultTypeInternal _DataStorageOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull DataStorageOptions_class_data_;
class ExtraKafkaOptions;
struct ExtraKafkaOptionsDefaultTypeInternal;
extern ExtraKafkaOptionsDefaultTypeInternal _ExtraKafkaOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExtraKafkaOptions_class_data_;
class ExtraKafkaOptions_OptsEntry_DoNotUse;
struct ExtraKafkaOptions_OptsEntry_DoNotUseDefaultTypeInternal;
extern ExtraKafkaOptions_OptsEntry_DoNotUseDefaultTypeInternal _ExtraKafkaOptions_OptsEntry_DoNotUse_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull ExtraKafkaOptions_OptsEntry_DoNotUse_class_data_;
class InfoStoreOptions;
struct InfoStoreOptionsDefaultTypeInternal;
extern InfoStoreOptionsDefaultTypeInternal _InfoStoreOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull InfoStoreOptions_class_data_;
class KafkaHookOptions;
struct KafkaHookOptionsDefaultTypeInternal;
extern KafkaHookOptionsDefaultTypeInternal _KafkaHookOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull KafkaHookOptions_class_data_;
class NatsHookOptions;
struct NatsHookOptionsDefaultTypeInternal;
extern NatsHookOptionsDefaultTypeInternal _NatsHookOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NatsHookOptions_class_data_;
class NotificationsOptions;
struct NotificationsOptionsDefaultTypeInternal;
extern NotificationsOptionsDefaultTypeInternal _NotificationsOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull NotificationsOptions_class_data_;
class RustusConf;
struct RustusConfDefaultTypeInternal;
extern RustusConfDefaultTypeInternal _RustusConf_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull RustusConf_class_data_;
class SentryOptions;
struct SentryOptionsDefaultTypeInternal;
extern SentryOptionsDefaultTypeInternal _SentryOptions_default_instance_;
extern const ::google::protobuf::internal::ClassDataFull SentryOptions_class_data_;
}  // namespace v1
}  // namespace uploader
namespace google {
namespace protobuf {
template <>
internal::EnumTraitsT<::uploader::v1::AvailableDataStorages_internal_data_>
    internal::EnumTraitsImpl::value<::uploader::v1::AvailableDataStorages>;
template <>
internal::EnumTraitsT<::uploader::v1::AvailableInfoStorages_internal_data_>
    internal::EnumTraitsImpl::value<::uploader::v1::AvailableInfoStorages>;
template <>
internal::EnumTraitsT<::uploader::v1::Extensions_internal_data_>
    internal::EnumTraitsImpl::value<::uploader::v1::Extensions>;
template <>
internal::EnumTraitsT<::uploader::v1::Format_internal_data_>
    internal::EnumTraitsImpl::value<::uploader::v1::Format>;
template <>
internal::EnumTraitsT<::uploader::v1::Hook_internal_data_>
    internal::EnumTraitsImpl::value<::uploader::v1::Hook>;
}  // namespace protobuf
}  // namespace google

namespace uploader {
namespace v1 {
enum AvailableDataStorages : int {
  FILE_STORAGE = 0,
  HYBRID_S3 = 1,
  S3 = 2,
  AvailableDataStorages_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AvailableDataStorages_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AvailableDataStorages_internal_data_[];
inline constexpr AvailableDataStorages AvailableDataStorages_MIN =
    static_cast<AvailableDataStorages>(0);
inline constexpr AvailableDataStorages AvailableDataStorages_MAX =
    static_cast<AvailableDataStorages>(2);
inline bool AvailableDataStorages_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int AvailableDataStorages_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AvailableDataStorages_descriptor();
template <typename T>
const ::std::string& AvailableDataStorages_Name(T value) {
  static_assert(::std::is_same<T, AvailableDataStorages>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AvailableDataStorages_Name().");
  return AvailableDataStorages_Name(static_cast<AvailableDataStorages>(value));
}
template <>
inline const ::std::string& AvailableDataStorages_Name(AvailableDataStorages value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AvailableDataStorages_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool AvailableDataStorages_Parse(
    ::absl::string_view name, AvailableDataStorages* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AvailableDataStorages>(AvailableDataStorages_descriptor(), name,
                                           value);
}
enum AvailableInfoStorages : int {
  FILES = 0,
  REDIS = 1,
  AvailableInfoStorages_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  AvailableInfoStorages_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t AvailableInfoStorages_internal_data_[];
inline constexpr AvailableInfoStorages AvailableInfoStorages_MIN =
    static_cast<AvailableInfoStorages>(0);
inline constexpr AvailableInfoStorages AvailableInfoStorages_MAX =
    static_cast<AvailableInfoStorages>(1);
inline bool AvailableInfoStorages_IsValid(int value) {
  return 0 <= value && value <= 1;
}
inline constexpr int AvailableInfoStorages_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AvailableInfoStorages_descriptor();
template <typename T>
const ::std::string& AvailableInfoStorages_Name(T value) {
  static_assert(::std::is_same<T, AvailableInfoStorages>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to AvailableInfoStorages_Name().");
  return AvailableInfoStorages_Name(static_cast<AvailableInfoStorages>(value));
}
template <>
inline const ::std::string& AvailableInfoStorages_Name(AvailableInfoStorages value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AvailableInfoStorages_descriptor, 0, 1>(
      static_cast<int>(value));
}
inline bool AvailableInfoStorages_Parse(
    ::absl::string_view name, AvailableInfoStorages* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<AvailableInfoStorages>(AvailableInfoStorages_descriptor(), name,
                                           value);
}
enum Format : int {
  DEFAULT = 0,
  TUSD = 1,
  V2 = 2,
  Format_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Format_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Format_internal_data_[];
inline constexpr Format Format_MIN =
    static_cast<Format>(0);
inline constexpr Format Format_MAX =
    static_cast<Format>(2);
inline bool Format_IsValid(int value) {
  return 0 <= value && value <= 2;
}
inline constexpr int Format_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Format_descriptor();
template <typename T>
const ::std::string& Format_Name(T value) {
  static_assert(::std::is_same<T, Format>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Format_Name().");
  return Format_Name(static_cast<Format>(value));
}
template <>
inline const ::std::string& Format_Name(Format value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Format_descriptor, 0, 2>(
      static_cast<int>(value));
}
inline bool Format_Parse(
    ::absl::string_view name, Format* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Format>(Format_descriptor(), name,
                                           value);
}
enum Hook : int {
  PRE_CREATE = 0,
  POST_CREATE = 1,
  POST_RECEIVE = 2,
  PRE_TERMINATE = 3,
  POST_TERMINATE = 4,
  POST_FINISH = 5,
  Hook_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Hook_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Hook_internal_data_[];
inline constexpr Hook Hook_MIN =
    static_cast<Hook>(0);
inline constexpr Hook Hook_MAX =
    static_cast<Hook>(5);
inline bool Hook_IsValid(int value) {
  return 0 <= value && value <= 5;
}
inline constexpr int Hook_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Hook_descriptor();
template <typename T>
const ::std::string& Hook_Name(T value) {
  static_assert(::std::is_same<T, Hook>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Hook_Name().");
  return Hook_Name(static_cast<Hook>(value));
}
template <>
inline const ::std::string& Hook_Name(Hook value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hook_descriptor, 0, 5>(
      static_cast<int>(value));
}
inline bool Hook_Parse(
    ::absl::string_view name, Hook* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hook>(Hook_descriptor(), name,
                                           value);
}
enum Extensions : int {
  GETTING = 0,
  CREATION = 1,
  TERMINATION = 2,
  CREATION_WITH_UPLOAD = 3,
  CREATION_DEFER_LENGTH = 4,
  CONCATENATION = 5,
  CHECKSUM = 6,
  Extensions_INT_MIN_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::min(),
  Extensions_INT_MAX_SENTINEL_DO_NOT_USE_ =
      ::std::numeric_limits<::int32_t>::max(),
};

extern const uint32_t Extensions_internal_data_[];
inline constexpr Extensions Extensions_MIN =
    static_cast<Extensions>(0);
inline constexpr Extensions Extensions_MAX =
    static_cast<Extensions>(6);
inline bool Extensions_IsValid(int value) {
  return 0 <= value && value <= 6;
}
inline constexpr int Extensions_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Extensions_descriptor();
template <typename T>
const ::std::string& Extensions_Name(T value) {
  static_assert(::std::is_same<T, Extensions>::value ||
                    ::std::is_integral<T>::value,
                "Incorrect type passed to Extensions_Name().");
  return Extensions_Name(static_cast<Extensions>(value));
}
template <>
inline const ::std::string& Extensions_Name(Extensions value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Extensions_descriptor, 0, 6>(
      static_cast<int>(value));
}
inline bool Extensions_Parse(
    ::absl::string_view name, Extensions* PROTOBUF_NONNULL value) {
  return ::google::protobuf::internal::ParseNamedEnum<Extensions>(Extensions_descriptor(), name,
                                           value);
}

// ===================================================================


// -------------------------------------------------------------------

class SentryOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.SentryOptions) */ {
 public:
  inline SentryOptions() : SentryOptions(nullptr) {}
  ~SentryOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SentryOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SentryOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SentryOptions(::google::protobuf::internal::ConstantInitialized);

  inline SentryOptions(const SentryOptions& from) : SentryOptions(nullptr, from) {}
  inline SentryOptions(SentryOptions&& from) noexcept
      : SentryOptions(nullptr, ::std::move(from)) {}
  inline SentryOptions& operator=(const SentryOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline SentryOptions& operator=(SentryOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SentryOptions& default_instance() {
    return *reinterpret_cast<const SentryOptions*>(
        &_SentryOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SentryOptions& a, SentryOptions& b) { a.Swap(&b); }
  inline void Swap(SentryOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SentryOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SentryOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SentryOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SentryOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SentryOptions& from) { SentryOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SentryOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.SentryOptions"; }

 protected:
  explicit SentryOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  SentryOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const SentryOptions& from);
  SentryOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, SentryOptions&& from) noexcept
      : SentryOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDsnFieldNumber = 1,
    kSampleRateFieldNumber = 2,
  };
  // optional string dsn = 1 [json_name = "dsn"];
  bool has_dsn() const;
  void clear_dsn() ;
  const ::std::string& dsn() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dsn(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dsn();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dsn();
  void set_allocated_dsn(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dsn() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dsn(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dsn();

  public:
  // float sample_rate = 2 [json_name = "sampleRate"];
  void clear_sample_rate() ;
  float sample_rate() const;
  void set_sample_rate(float value);

  private:
  float _internal_sample_rate() const;
  void _internal_set_sample_rate(float value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.SentryOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 37,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const SentryOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr dsn_;
    float sample_rate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull SentryOptions_class_data_;
// -------------------------------------------------------------------

class NatsHookOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.NatsHookOptions) */ {
 public:
  inline NatsHookOptions() : NatsHookOptions(nullptr) {}
  ~NatsHookOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NatsHookOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NatsHookOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NatsHookOptions(::google::protobuf::internal::ConstantInitialized);

  inline NatsHookOptions(const NatsHookOptions& from) : NatsHookOptions(nullptr, from) {}
  inline NatsHookOptions(NatsHookOptions&& from) noexcept
      : NatsHookOptions(nullptr, ::std::move(from)) {}
  inline NatsHookOptions& operator=(const NatsHookOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline NatsHookOptions& operator=(NatsHookOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NatsHookOptions& default_instance() {
    return *reinterpret_cast<const NatsHookOptions*>(
        &_NatsHookOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(NatsHookOptions& a, NatsHookOptions& b) { a.Swap(&b); }
  inline void Swap(NatsHookOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NatsHookOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NatsHookOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NatsHookOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NatsHookOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NatsHookOptions& from) { NatsHookOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NatsHookOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.NatsHookOptions"; }

 protected:
  explicit NatsHookOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NatsHookOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NatsHookOptions& from);
  NatsHookOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NatsHookOptions&& from) noexcept
      : NatsHookOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlsFieldNumber = 1,
    kSubjectFieldNumber = 2,
    kPrefixFieldNumber = 3,
    kUsernameFieldNumber = 5,
    kPasswordFieldNumber = 6,
    kTokenFieldNumber = 7,
    kWaitForRepliesFieldNumber = 4,
  };
  // repeated string urls = 1 [json_name = "urls"];
  int urls_size() const;
  private:
  int _internal_urls_size() const;

  public:
  void clear_urls() ;
  const ::std::string& urls(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_urls(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_urls(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_urls();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_urls(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& urls() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_urls() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_urls();

  public:
  // optional string subject = 2 [json_name = "subject"];
  bool has_subject() const;
  void clear_subject() ;
  const ::std::string& subject() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_subject(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_subject();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_subject();
  void set_allocated_subject(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_subject() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_subject(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_subject();

  public:
  // optional string prefix = 3 [json_name = "prefix"];
  bool has_prefix() const;
  void clear_prefix() ;
  const ::std::string& prefix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_prefix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_prefix();
  void set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_prefix();

  public:
  // optional string username = 5 [json_name = "username"];
  bool has_username() const;
  void clear_username() ;
  const ::std::string& username() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_username(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_username();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_username();
  void set_allocated_username(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_username() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_username(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_username();

  public:
  // optional string password = 6 [json_name = "password"];
  bool has_password() const;
  void clear_password() ;
  const ::std::string& password() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_password(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_password();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_password();
  void set_allocated_password(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_password() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_password(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_password();

  public:
  // optional string token = 7 [json_name = "token"];
  bool has_token() const;
  void clear_token() ;
  const ::std::string& token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_token();
  void set_allocated_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_token();

  public:
  // bool wait_for_replies = 4 [json_name = "waitForReplies"];
  void clear_wait_for_replies() ;
  bool wait_for_replies() const;
  void set_wait_for_replies(bool value);

  private:
  bool _internal_wait_for_replies() const;
  void _internal_set_wait_for_replies(bool value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.NatsHookOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 7,
                                   0, 74,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NatsHookOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> urls_;
    ::google::protobuf::internal::ArenaStringPtr subject_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr username_;
    ::google::protobuf::internal::ArenaStringPtr password_;
    ::google::protobuf::internal::ArenaStringPtr token_;
    bool wait_for_replies_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NatsHookOptions_class_data_;
// -------------------------------------------------------------------

class InfoStoreOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.InfoStoreOptions) */ {
 public:
  inline InfoStoreOptions() : InfoStoreOptions(nullptr) {}
  ~InfoStoreOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(InfoStoreOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(InfoStoreOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InfoStoreOptions(::google::protobuf::internal::ConstantInitialized);

  inline InfoStoreOptions(const InfoStoreOptions& from) : InfoStoreOptions(nullptr, from) {}
  inline InfoStoreOptions(InfoStoreOptions&& from) noexcept
      : InfoStoreOptions(nullptr, ::std::move(from)) {}
  inline InfoStoreOptions& operator=(const InfoStoreOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline InfoStoreOptions& operator=(InfoStoreOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InfoStoreOptions& default_instance() {
    return *reinterpret_cast<const InfoStoreOptions*>(
        &_InfoStoreOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(InfoStoreOptions& a, InfoStoreOptions& b) { a.Swap(&b); }
  inline void Swap(InfoStoreOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InfoStoreOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InfoStoreOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<InfoStoreOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InfoStoreOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InfoStoreOptions& from) { InfoStoreOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(InfoStoreOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.InfoStoreOptions"; }

 protected:
  explicit InfoStoreOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  InfoStoreOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const InfoStoreOptions& from);
  InfoStoreOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, InfoStoreOptions&& from) noexcept
      : InfoStoreOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInfoDirFieldNumber = 2,
    kInfoDbDsnFieldNumber = 3,
    kInfoStorageFieldNumber = 1,
    kRedisInfoExpirationFieldNumber = 4,
  };
  // string info_dir = 2 [json_name = "infoDir"];
  void clear_info_dir() ;
  const ::std::string& info_dir() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_info_dir(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_info_dir();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_info_dir();
  void set_allocated_info_dir(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_info_dir() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_info_dir(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_info_dir();

  public:
  // optional string info_db_dsn = 3 [json_name = "infoDbDsn"];
  bool has_info_db_dsn() const;
  void clear_info_db_dsn() ;
  const ::std::string& info_db_dsn() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_info_db_dsn(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_info_db_dsn();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_info_db_dsn();
  void set_allocated_info_db_dsn(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_info_db_dsn() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_info_db_dsn(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_info_db_dsn();

  public:
  // .uploader.v1.AvailableInfoStorages info_storage = 1 [json_name = "infoStorage"];
  void clear_info_storage() ;
  ::uploader::v1::AvailableInfoStorages info_storage() const;
  void set_info_storage(::uploader::v1::AvailableInfoStorages value);

  private:
  ::uploader::v1::AvailableInfoStorages _internal_info_storage() const;
  void _internal_set_info_storage(::uploader::v1::AvailableInfoStorages value);

  public:
  // optional uint32 redis_info_expiration = 4 [json_name = "redisInfoExpiration"];
  bool has_redis_info_expiration() const;
  void clear_redis_info_expiration() ;
  ::uint32_t redis_info_expiration() const;
  void set_redis_info_expiration(::uint32_t value);

  private:
  ::uint32_t _internal_redis_info_expiration() const;
  void _internal_set_redis_info_expiration(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.InfoStoreOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4,
                                   0, 56,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const InfoStoreOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr info_dir_;
    ::google::protobuf::internal::ArenaStringPtr info_db_dsn_;
    int info_storage_;
    ::uint32_t redis_info_expiration_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull InfoStoreOptions_class_data_;
// -------------------------------------------------------------------

class ExtraKafkaOptions_OptsEntry_DoNotUse final
    : public ::google::protobuf::internal::MapEntry<std::string, std::string,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                             ::google::protobuf::internal::WireFormatLite::TYPE_STRING> {
 public:
  using SuperType =
      ::google::protobuf::internal::MapEntry<std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>;
  ExtraKafkaOptions_OptsEntry_DoNotUse();
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtraKafkaOptions_OptsEntry_DoNotUse(::google::protobuf::internal::ConstantInitialized);
  explicit ExtraKafkaOptions_OptsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr const void* PROTOBUF_NONNULL internal_default_instance() {
    return &_ExtraKafkaOptions_OptsEntry_DoNotUse_default_instance_;
  }


  static constexpr auto InternalGenerateClassData_();

 private:
  friend class ::google::protobuf::MessageLite;
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2,
                                   0, 56,
                                   2>
      _table_;

  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();
};
extern const ::google::protobuf::internal::ClassDataFull ExtraKafkaOptions_OptsEntry_DoNotUse_class_data_;
// -------------------------------------------------------------------

class DataStorageOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.DataStorageOptions) */ {
 public:
  inline DataStorageOptions() : DataStorageOptions(nullptr) {}
  ~DataStorageOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DataStorageOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DataStorageOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DataStorageOptions(::google::protobuf::internal::ConstantInitialized);

  inline DataStorageOptions(const DataStorageOptions& from) : DataStorageOptions(nullptr, from) {}
  inline DataStorageOptions(DataStorageOptions&& from) noexcept
      : DataStorageOptions(nullptr, ::std::move(from)) {}
  inline DataStorageOptions& operator=(const DataStorageOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataStorageOptions& operator=(DataStorageOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataStorageOptions& default_instance() {
    return *reinterpret_cast<const DataStorageOptions*>(
        &_DataStorageOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(DataStorageOptions& a, DataStorageOptions& b) { a.Swap(&b); }
  inline void Swap(DataStorageOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataStorageOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataStorageOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DataStorageOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DataStorageOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DataStorageOptions& from) { DataStorageOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DataStorageOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.DataStorageOptions"; }

 protected:
  explicit DataStorageOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  DataStorageOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const DataStorageOptions& from);
  DataStorageOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, DataStorageOptions&& from) noexcept
      : DataStorageOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataDirFieldNumber = 2,
    kDirStructureFieldNumber = 3,
    kS3BucketFieldNumber = 5,
    kS3RegionFieldNumber = 6,
    kS3AccessKeyFieldNumber = 7,
    kS3AccessKeyPathFieldNumber = 8,
    kS3SecretKeyFieldNumber = 9,
    kS3SecretKeyPathFieldNumber = 10,
    kS3UrlFieldNumber = 11,
    kS3SecurityTokenFieldNumber = 13,
    kS3SessionTokenFieldNumber = 14,
    kS3ProfileFieldNumber = 15,
    kS3HeadersFieldNumber = 16,
    kStorageFieldNumber = 1,
    kForceFsyncFieldNumber = 4,
    kS3ForcePathStyleFieldNumber = 12,
    kS3ConcatConcurrentDownloadsFieldNumber = 17,
  };
  // string data_dir = 2 [json_name = "dataDir"];
  void clear_data_dir() ;
  const ::std::string& data_dir() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_data_dir(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_data_dir();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_data_dir();
  void set_allocated_data_dir(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_data_dir() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_data_dir(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_data_dir();

  public:
  // string dir_structure = 3 [json_name = "dirStructure"];
  void clear_dir_structure() ;
  const ::std::string& dir_structure() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_dir_structure(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_dir_structure();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_dir_structure();
  void set_allocated_dir_structure(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_dir_structure() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_dir_structure(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_dir_structure();

  public:
  // optional string s3_bucket = 5 [json_name = "s3Bucket"];
  bool has_s3_bucket() const;
  void clear_s3_bucket() ;
  const ::std::string& s3_bucket() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_bucket(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_bucket();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_bucket();
  void set_allocated_s3_bucket(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_bucket() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_bucket(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_bucket();

  public:
  // optional string s3_region = 6 [json_name = "s3Region"];
  bool has_s3_region() const;
  void clear_s3_region() ;
  const ::std::string& s3_region() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_region(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_region();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_region();
  void set_allocated_s3_region(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_region() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_region(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_region();

  public:
  // optional string s3_access_key = 7 [json_name = "s3AccessKey"];
  bool has_s3_access_key() const;
  void clear_s3_access_key() ;
  const ::std::string& s3_access_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_access_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_access_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_access_key();
  void set_allocated_s3_access_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_access_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_access_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_access_key();

  public:
  // optional string s3_access_key_path = 8 [json_name = "s3AccessKeyPath"];
  bool has_s3_access_key_path() const;
  void clear_s3_access_key_path() ;
  const ::std::string& s3_access_key_path() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_access_key_path(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_access_key_path();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_access_key_path();
  void set_allocated_s3_access_key_path(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_access_key_path() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_access_key_path(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_access_key_path();

  public:
  // optional string s3_secret_key = 9 [json_name = "s3SecretKey"];
  bool has_s3_secret_key() const;
  void clear_s3_secret_key() ;
  const ::std::string& s3_secret_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_secret_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_secret_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_secret_key();
  void set_allocated_s3_secret_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_secret_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_secret_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_secret_key();

  public:
  // optional string s3_secret_key_path = 10 [json_name = "s3SecretKeyPath"];
  bool has_s3_secret_key_path() const;
  void clear_s3_secret_key_path() ;
  const ::std::string& s3_secret_key_path() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_secret_key_path(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_secret_key_path();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_secret_key_path();
  void set_allocated_s3_secret_key_path(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_secret_key_path() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_secret_key_path(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_secret_key_path();

  public:
  // optional string s3_url = 11 [json_name = "s3Url"];
  bool has_s3_url() const;
  void clear_s3_url() ;
  const ::std::string& s3_url() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_url(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_url();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_url();
  void set_allocated_s3_url(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_url(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_url();

  public:
  // optional string s3_security_token = 13 [json_name = "s3SecurityToken"];
  bool has_s3_security_token() const;
  void clear_s3_security_token() ;
  const ::std::string& s3_security_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_security_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_security_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_security_token();
  void set_allocated_s3_security_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_security_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_security_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_security_token();

  public:
  // optional string s3_session_token = 14 [json_name = "s3SessionToken"];
  bool has_s3_session_token() const;
  void clear_s3_session_token() ;
  const ::std::string& s3_session_token() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_session_token(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_session_token();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_session_token();
  void set_allocated_s3_session_token(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_session_token() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_session_token(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_session_token();

  public:
  // optional string s3_profile = 15 [json_name = "s3Profile"];
  bool has_s3_profile() const;
  void clear_s3_profile() ;
  const ::std::string& s3_profile() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_profile(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_profile();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_profile();
  void set_allocated_s3_profile(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_profile() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_profile(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_profile();

  public:
  // optional string s3_headers = 16 [json_name = "s3Headers"];
  bool has_s3_headers() const;
  void clear_s3_headers() ;
  const ::std::string& s3_headers() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_s3_headers(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_s3_headers();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_s3_headers();
  void set_allocated_s3_headers(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_s3_headers() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_s3_headers(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_s3_headers();

  public:
  // .uploader.v1.AvailableDataStorages storage = 1 [json_name = "storage"];
  void clear_storage() ;
  ::uploader::v1::AvailableDataStorages storage() const;
  void set_storage(::uploader::v1::AvailableDataStorages value);

  private:
  ::uploader::v1::AvailableDataStorages _internal_storage() const;
  void _internal_set_storage(::uploader::v1::AvailableDataStorages value);

  public:
  // bool force_fsync = 4 [json_name = "forceFsync"];
  void clear_force_fsync() ;
  bool force_fsync() const;
  void set_force_fsync(bool value);

  private:
  bool _internal_force_fsync() const;
  void _internal_set_force_fsync(bool value);

  public:
  // bool s3_force_path_style = 12 [json_name = "s3ForcePathStyle"];
  void clear_s3_force_path_style() ;
  bool s3_force_path_style() const;
  void set_s3_force_path_style(bool value);

  private:
  bool _internal_s3_force_path_style() const;
  void _internal_set_s3_force_path_style(bool value);

  public:
  // uint32 s3_concat_concurrent_downloads = 17 [json_name = "s3ConcatConcurrentDownloads"];
  void clear_s3_concat_concurrent_downloads() ;
  ::uint32_t s3_concat_concurrent_downloads() const;
  void set_s3_concat_concurrent_downloads(::uint32_t value);

  private:
  ::uint32_t _internal_s3_concat_concurrent_downloads() const;
  void _internal_set_s3_concat_concurrent_downloads(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.DataStorageOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<5, 17,
                                   0, 215,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const DataStorageOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr data_dir_;
    ::google::protobuf::internal::ArenaStringPtr dir_structure_;
    ::google::protobuf::internal::ArenaStringPtr s3_bucket_;
    ::google::protobuf::internal::ArenaStringPtr s3_region_;
    ::google::protobuf::internal::ArenaStringPtr s3_access_key_;
    ::google::protobuf::internal::ArenaStringPtr s3_access_key_path_;
    ::google::protobuf::internal::ArenaStringPtr s3_secret_key_;
    ::google::protobuf::internal::ArenaStringPtr s3_secret_key_path_;
    ::google::protobuf::internal::ArenaStringPtr s3_url_;
    ::google::protobuf::internal::ArenaStringPtr s3_security_token_;
    ::google::protobuf::internal::ArenaStringPtr s3_session_token_;
    ::google::protobuf::internal::ArenaStringPtr s3_profile_;
    ::google::protobuf::internal::ArenaStringPtr s3_headers_;
    int storage_;
    bool force_fsync_;
    bool s3_force_path_style_;
    ::uint32_t s3_concat_concurrent_downloads_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull DataStorageOptions_class_data_;
// -------------------------------------------------------------------

class AMQPHooksOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.AMQPHooksOptions) */ {
 public:
  inline AMQPHooksOptions() : AMQPHooksOptions(nullptr) {}
  ~AMQPHooksOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AMQPHooksOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AMQPHooksOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AMQPHooksOptions(::google::protobuf::internal::ConstantInitialized);

  inline AMQPHooksOptions(const AMQPHooksOptions& from) : AMQPHooksOptions(nullptr, from) {}
  inline AMQPHooksOptions(AMQPHooksOptions&& from) noexcept
      : AMQPHooksOptions(nullptr, ::std::move(from)) {}
  inline AMQPHooksOptions& operator=(const AMQPHooksOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline AMQPHooksOptions& operator=(AMQPHooksOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AMQPHooksOptions& default_instance() {
    return *reinterpret_cast<const AMQPHooksOptions*>(
        &_AMQPHooksOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(AMQPHooksOptions& a, AMQPHooksOptions& b) { a.Swap(&b); }
  inline void Swap(AMQPHooksOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AMQPHooksOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AMQPHooksOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<AMQPHooksOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AMQPHooksOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AMQPHooksOptions& from) { AMQPHooksOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(AMQPHooksOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.AMQPHooksOptions"; }

 protected:
  explicit AMQPHooksOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  AMQPHooksOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const AMQPHooksOptions& from);
  AMQPHooksOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, AMQPHooksOptions&& from) noexcept
      : AMQPHooksOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlFieldNumber = 1,
    kExchangeFieldNumber = 7,
    kExchangeKindFieldNumber = 8,
    kRoutingKeyFieldNumber = 9,
    kQueuesPrefixFieldNumber = 10,
    kDeclareExchangeFieldNumber = 2,
    kDeclareQueuesFieldNumber = 3,
    kDurableExchangeFieldNumber = 4,
    kDurableQueuesFieldNumber = 5,
    kCeleryFieldNumber = 6,
    kAutoDeleteFieldNumber = 15,
    kConnectionPoolSizeFieldNumber = 11,
    kChannelPoolSizeFieldNumber = 12,
    kIdleConnectionTimeoutFieldNumber = 13,
    kIdleChannelsTimeoutFieldNumber = 14,
  };
  // optional string url = 1 [json_name = "url"];
  bool has_url() const;
  void clear_url() ;
  const ::std::string& url() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string exchange = 7 [json_name = "exchange"];
  void clear_exchange() ;
  const ::std::string& exchange() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_exchange(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_exchange();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_exchange();
  void set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_exchange() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_exchange(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_exchange();

  public:
  // string exchange_kind = 8 [json_name = "exchangeKind"];
  void clear_exchange_kind() ;
  const ::std::string& exchange_kind() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_exchange_kind(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_exchange_kind();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_exchange_kind();
  void set_allocated_exchange_kind(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_exchange_kind() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_exchange_kind(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_exchange_kind();

  public:
  // optional string routing_key = 9 [json_name = "routingKey"];
  bool has_routing_key() const;
  void clear_routing_key() ;
  const ::std::string& routing_key() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_routing_key(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_routing_key();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_routing_key();
  void set_allocated_routing_key(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_routing_key() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_routing_key(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_routing_key();

  public:
  // string queues_prefix = 10 [json_name = "queuesPrefix"];
  void clear_queues_prefix() ;
  const ::std::string& queues_prefix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_queues_prefix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_queues_prefix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_queues_prefix();
  void set_allocated_queues_prefix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_queues_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_queues_prefix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_queues_prefix();

  public:
  // bool declare_exchange = 2 [json_name = "declareExchange"];
  void clear_declare_exchange() ;
  bool declare_exchange() const;
  void set_declare_exchange(bool value);

  private:
  bool _internal_declare_exchange() const;
  void _internal_set_declare_exchange(bool value);

  public:
  // bool declare_queues = 3 [json_name = "declareQueues"];
  void clear_declare_queues() ;
  bool declare_queues() const;
  void set_declare_queues(bool value);

  private:
  bool _internal_declare_queues() const;
  void _internal_set_declare_queues(bool value);

  public:
  // bool durable_exchange = 4 [json_name = "durableExchange"];
  void clear_durable_exchange() ;
  bool durable_exchange() const;
  void set_durable_exchange(bool value);

  private:
  bool _internal_durable_exchange() const;
  void _internal_set_durable_exchange(bool value);

  public:
  // bool durable_queues = 5 [json_name = "durableQueues"];
  void clear_durable_queues() ;
  bool durable_queues() const;
  void set_durable_queues(bool value);

  private:
  bool _internal_durable_queues() const;
  void _internal_set_durable_queues(bool value);

  public:
  // bool celery = 6 [json_name = "celery"];
  void clear_celery() ;
  bool celery() const;
  void set_celery(bool value);

  private:
  bool _internal_celery() const;
  void _internal_set_celery(bool value);

  public:
  // bool auto_delete = 15 [json_name = "autoDelete"];
  void clear_auto_delete() ;
  bool auto_delete() const;
  void set_auto_delete(bool value);

  private:
  bool _internal_auto_delete() const;
  void _internal_set_auto_delete(bool value);

  public:
  // uint64 connection_pool_size = 11 [json_name = "connectionPoolSize"];
  void clear_connection_pool_size() ;
  ::uint64_t connection_pool_size() const;
  void set_connection_pool_size(::uint64_t value);

  private:
  ::uint64_t _internal_connection_pool_size() const;
  void _internal_set_connection_pool_size(::uint64_t value);

  public:
  // uint64 channel_pool_size = 12 [json_name = "channelPoolSize"];
  void clear_channel_pool_size() ;
  ::uint64_t channel_pool_size() const;
  void set_channel_pool_size(::uint64_t value);

  private:
  ::uint64_t _internal_channel_pool_size() const;
  void _internal_set_channel_pool_size(::uint64_t value);

  public:
  // optional uint64 idle_connection_timeout = 13 [json_name = "idleConnectionTimeout"];
  bool has_idle_connection_timeout() const;
  void clear_idle_connection_timeout() ;
  ::uint64_t idle_connection_timeout() const;
  void set_idle_connection_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_idle_connection_timeout() const;
  void _internal_set_idle_connection_timeout(::uint64_t value);

  public:
  // optional uint64 idle_channels_timeout = 14 [json_name = "idleChannelsTimeout"];
  bool has_idle_channels_timeout() const;
  void clear_idle_channels_timeout() ;
  ::uint64_t idle_channels_timeout() const;
  void set_idle_channels_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_idle_channels_timeout() const;
  void _internal_set_idle_channels_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.AMQPHooksOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 15,
                                   0, 93,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const AMQPHooksOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr exchange_;
    ::google::protobuf::internal::ArenaStringPtr exchange_kind_;
    ::google::protobuf::internal::ArenaStringPtr routing_key_;
    ::google::protobuf::internal::ArenaStringPtr queues_prefix_;
    bool declare_exchange_;
    bool declare_queues_;
    bool durable_exchange_;
    bool durable_queues_;
    bool celery_;
    bool auto_delete_;
    ::uint64_t connection_pool_size_;
    ::uint64_t channel_pool_size_;
    ::uint64_t idle_connection_timeout_;
    ::uint64_t idle_channels_timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull AMQPHooksOptions_class_data_;
// -------------------------------------------------------------------

class ExtraKafkaOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.ExtraKafkaOptions) */ {
 public:
  inline ExtraKafkaOptions() : ExtraKafkaOptions(nullptr) {}
  ~ExtraKafkaOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ExtraKafkaOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ExtraKafkaOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ExtraKafkaOptions(::google::protobuf::internal::ConstantInitialized);

  inline ExtraKafkaOptions(const ExtraKafkaOptions& from) : ExtraKafkaOptions(nullptr, from) {}
  inline ExtraKafkaOptions(ExtraKafkaOptions&& from) noexcept
      : ExtraKafkaOptions(nullptr, ::std::move(from)) {}
  inline ExtraKafkaOptions& operator=(const ExtraKafkaOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtraKafkaOptions& operator=(ExtraKafkaOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExtraKafkaOptions& default_instance() {
    return *reinterpret_cast<const ExtraKafkaOptions*>(
        &_ExtraKafkaOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(ExtraKafkaOptions& a, ExtraKafkaOptions& b) { a.Swap(&b); }
  inline void Swap(ExtraKafkaOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtraKafkaOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExtraKafkaOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ExtraKafkaOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExtraKafkaOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ExtraKafkaOptions& from) { ExtraKafkaOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ExtraKafkaOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.ExtraKafkaOptions"; }

 protected:
  explicit ExtraKafkaOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  ExtraKafkaOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const ExtraKafkaOptions& from);
  ExtraKafkaOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, ExtraKafkaOptions&& from) noexcept
      : ExtraKafkaOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOptsFieldNumber = 1,
  };
  // map<string, string> opts = 1 [json_name = "opts"];
  int opts_size() const;
  private:
  int _internal_opts_size() const;

  public:
  void clear_opts() ;
  const ::google::protobuf::Map<std::string, std::string>& opts() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL mutable_opts();

  private:
  const ::google::protobuf::Map<std::string, std::string>& _internal_opts() const;
  ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL _internal_mutable_opts();

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.ExtraKafkaOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1,
                                   1, 42,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const ExtraKafkaOptions& from_msg);
    ::google::protobuf::internal::MapField<ExtraKafkaOptions_OptsEntry_DoNotUse, std::string, std::string,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
                      ::google::protobuf::internal::WireFormatLite::TYPE_STRING>
        opts_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull ExtraKafkaOptions_class_data_;
// -------------------------------------------------------------------

class KafkaHookOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.KafkaHookOptions) */ {
 public:
  inline KafkaHookOptions() : KafkaHookOptions(nullptr) {}
  ~KafkaHookOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(KafkaHookOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(KafkaHookOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KafkaHookOptions(::google::protobuf::internal::ConstantInitialized);

  inline KafkaHookOptions(const KafkaHookOptions& from) : KafkaHookOptions(nullptr, from) {}
  inline KafkaHookOptions(KafkaHookOptions&& from) noexcept
      : KafkaHookOptions(nullptr, ::std::move(from)) {}
  inline KafkaHookOptions& operator=(const KafkaHookOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline KafkaHookOptions& operator=(KafkaHookOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KafkaHookOptions& default_instance() {
    return *reinterpret_cast<const KafkaHookOptions*>(
        &_KafkaHookOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(KafkaHookOptions& a, KafkaHookOptions& b) { a.Swap(&b); }
  inline void Swap(KafkaHookOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KafkaHookOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KafkaHookOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<KafkaHookOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KafkaHookOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KafkaHookOptions& from) { KafkaHookOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(KafkaHookOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.KafkaHookOptions"; }

 protected:
  explicit KafkaHookOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  KafkaHookOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const KafkaHookOptions& from);
  KafkaHookOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, KafkaHookOptions&& from) noexcept
      : KafkaHookOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUrlsFieldNumber = 1,
    kClientIdFieldNumber = 2,
    kTopicFieldNumber = 3,
    kPrefixFieldNumber = 4,
    kRequiredAcksFieldNumber = 5,
    kCompressionFieldNumber = 6,
    kExtraKafkaOptsFieldNumber = 9,
    kIdleTimeoutFieldNumber = 7,
    kSendTimeoutFieldNumber = 8,
  };
  // optional string urls = 1 [json_name = "urls"];
  bool has_urls() const;
  void clear_urls() ;
  const ::std::string& urls() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_urls(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_urls();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_urls();
  void set_allocated_urls(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_urls() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_urls(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_urls();

  public:
  // optional string client_id = 2 [json_name = "clientId"];
  bool has_client_id() const;
  void clear_client_id() ;
  const ::std::string& client_id() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_client_id(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_client_id();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_client_id();
  void set_allocated_client_id(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_client_id() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_client_id();

  public:
  // optional string topic = 3 [json_name = "topic"];
  bool has_topic() const;
  void clear_topic() ;
  const ::std::string& topic() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_topic(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_topic();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_topic();
  void set_allocated_topic(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_topic() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_topic(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_topic();

  public:
  // optional string prefix = 4 [json_name = "prefix"];
  bool has_prefix() const;
  void clear_prefix() ;
  const ::std::string& prefix() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_prefix(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_prefix();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_prefix();
  void set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_prefix() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_prefix(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_prefix();

  public:
  // optional string required_acks = 5 [json_name = "requiredAcks"];
  bool has_required_acks() const;
  void clear_required_acks() ;
  const ::std::string& required_acks() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_required_acks(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_required_acks();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_required_acks();
  void set_allocated_required_acks(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_required_acks() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_required_acks(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_required_acks();

  public:
  // optional string compression = 6 [json_name = "compression"];
  bool has_compression() const;
  void clear_compression() ;
  const ::std::string& compression() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_compression(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_compression();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_compression();
  void set_allocated_compression(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_compression() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_compression(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_compression();

  public:
  // optional .uploader.v1.ExtraKafkaOptions extra_kafka_opts = 9 [json_name = "extraKafkaOpts"];
  bool has_extra_kafka_opts() const;
  void clear_extra_kafka_opts() ;
  const ::uploader::v1::ExtraKafkaOptions& extra_kafka_opts() const;
  [[nodiscard]] ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE release_extra_kafka_opts();
  ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NONNULL mutable_extra_kafka_opts();
  void set_allocated_extra_kafka_opts(::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_extra_kafka_opts(::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE unsafe_arena_release_extra_kafka_opts();

  private:
  const ::uploader::v1::ExtraKafkaOptions& _internal_extra_kafka_opts() const;
  ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NONNULL _internal_mutable_extra_kafka_opts();

  public:
  // optional uint64 idle_timeout = 7 [json_name = "idleTimeout"];
  bool has_idle_timeout() const;
  void clear_idle_timeout() ;
  ::uint64_t idle_timeout() const;
  void set_idle_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_idle_timeout() const;
  void _internal_set_idle_timeout(::uint64_t value);

  public:
  // optional uint64 send_timeout = 8 [json_name = "sendTimeout"];
  bool has_send_timeout() const;
  void clear_send_timeout() ;
  ::uint64_t send_timeout() const;
  void set_send_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_send_timeout() const;
  void _internal_set_send_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.KafkaHookOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 9,
                                   1, 93,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const KafkaHookOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr urls_;
    ::google::protobuf::internal::ArenaStringPtr client_id_;
    ::google::protobuf::internal::ArenaStringPtr topic_;
    ::google::protobuf::internal::ArenaStringPtr prefix_;
    ::google::protobuf::internal::ArenaStringPtr required_acks_;
    ::google::protobuf::internal::ArenaStringPtr compression_;
    ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE extra_kafka_opts_;
    ::uint64_t idle_timeout_;
    ::uint64_t send_timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull KafkaHookOptions_class_data_;
// -------------------------------------------------------------------

class NotificationsOptions final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.NotificationsOptions) */ {
 public:
  inline NotificationsOptions() : NotificationsOptions(nullptr) {}
  ~NotificationsOptions() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NotificationsOptions* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NotificationsOptions));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NotificationsOptions(::google::protobuf::internal::ConstantInitialized);

  inline NotificationsOptions(const NotificationsOptions& from) : NotificationsOptions(nullptr, from) {}
  inline NotificationsOptions(NotificationsOptions&& from) noexcept
      : NotificationsOptions(nullptr, ::std::move(from)) {}
  inline NotificationsOptions& operator=(const NotificationsOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotificationsOptions& operator=(NotificationsOptions&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotificationsOptions& default_instance() {
    return *reinterpret_cast<const NotificationsOptions*>(
        &_NotificationsOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(NotificationsOptions& a, NotificationsOptions& b) { a.Swap(&b); }
  inline void Swap(NotificationsOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotificationsOptions* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotificationsOptions* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NotificationsOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotificationsOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NotificationsOptions& from) { NotificationsOptions::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NotificationsOptions* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.NotificationsOptions"; }

 protected:
  explicit NotificationsOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  NotificationsOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const NotificationsOptions& from);
  NotificationsOptions(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, NotificationsOptions&& from) noexcept
      : NotificationsOptions(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHooksFieldNumber = 2,
    kHooksHttpUrlsFieldNumber = 4,
    kHooksHttpProxyHeadersFieldNumber = 6,
    kHooksDirFieldNumber = 7,
    kHooksFileFieldNumber = 8,
    kAmqpHookOptsFieldNumber = 9,
    kKafkaHookOptsFieldNumber = 10,
    kNatsHookOptsFieldNumber = 11,
    kHooksFormatFieldNumber = 1,
    kBehindProxyFieldNumber = 3,
    kHttpHookTimeoutFieldNumber = 5,
  };
  // repeated .uploader.v1.Hook hooks = 2 [json_name = "hooks"];
  int hooks_size() const;
  private:
  int _internal_hooks_size() const;

  public:
  void clear_hooks() ;
  public:
  ::uploader::v1::Hook hooks(int index) const;
  void set_hooks(int index, ::uploader::v1::Hook value);
  void add_hooks(::uploader::v1::Hook value);
  const ::google::protobuf::RepeatedField<int>& hooks() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_hooks();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_hooks() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_hooks();

  public:
  // repeated string hooks_http_urls = 4 [json_name = "hooksHttpUrls"];
  int hooks_http_urls_size() const;
  private:
  int _internal_hooks_http_urls_size() const;

  public:
  void clear_hooks_http_urls() ;
  const ::std::string& hooks_http_urls(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_hooks_http_urls(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hooks_http_urls(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_hooks_http_urls();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_hooks_http_urls(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& hooks_http_urls() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_hooks_http_urls();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_hooks_http_urls() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_hooks_http_urls();

  public:
  // repeated string hooks_http_proxy_headers = 6 [json_name = "hooksHttpProxyHeaders"];
  int hooks_http_proxy_headers_size() const;
  private:
  int _internal_hooks_http_proxy_headers_size() const;

  public:
  void clear_hooks_http_proxy_headers() ;
  const ::std::string& hooks_http_proxy_headers(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_hooks_http_proxy_headers(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hooks_http_proxy_headers(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_hooks_http_proxy_headers();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_hooks_http_proxy_headers(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& hooks_http_proxy_headers() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_hooks_http_proxy_headers();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_hooks_http_proxy_headers() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_hooks_http_proxy_headers();

  public:
  // optional string hooks_dir = 7 [json_name = "hooksDir"];
  bool has_hooks_dir() const;
  void clear_hooks_dir() ;
  const ::std::string& hooks_dir() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hooks_dir(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hooks_dir();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hooks_dir();
  void set_allocated_hooks_dir(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hooks_dir() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hooks_dir(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hooks_dir();

  public:
  // optional string hooks_file = 8 [json_name = "hooksFile"];
  bool has_hooks_file() const;
  void clear_hooks_file() ;
  const ::std::string& hooks_file() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_hooks_file(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_hooks_file();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_hooks_file();
  void set_allocated_hooks_file(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_hooks_file() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_hooks_file(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_hooks_file();

  public:
  // .uploader.v1.AMQPHooksOptions amqp_hook_opts = 9 [json_name = "amqpHookOpts"];
  bool has_amqp_hook_opts() const;
  void clear_amqp_hook_opts() ;
  const ::uploader::v1::AMQPHooksOptions& amqp_hook_opts() const;
  [[nodiscard]] ::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE release_amqp_hook_opts();
  ::uploader::v1::AMQPHooksOptions* PROTOBUF_NONNULL mutable_amqp_hook_opts();
  void set_allocated_amqp_hook_opts(::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_amqp_hook_opts(::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE unsafe_arena_release_amqp_hook_opts();

  private:
  const ::uploader::v1::AMQPHooksOptions& _internal_amqp_hook_opts() const;
  ::uploader::v1::AMQPHooksOptions* PROTOBUF_NONNULL _internal_mutable_amqp_hook_opts();

  public:
  // .uploader.v1.KafkaHookOptions kafka_hook_opts = 10 [json_name = "kafkaHookOpts"];
  bool has_kafka_hook_opts() const;
  void clear_kafka_hook_opts() ;
  const ::uploader::v1::KafkaHookOptions& kafka_hook_opts() const;
  [[nodiscard]] ::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE release_kafka_hook_opts();
  ::uploader::v1::KafkaHookOptions* PROTOBUF_NONNULL mutable_kafka_hook_opts();
  void set_allocated_kafka_hook_opts(::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_kafka_hook_opts(::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE unsafe_arena_release_kafka_hook_opts();

  private:
  const ::uploader::v1::KafkaHookOptions& _internal_kafka_hook_opts() const;
  ::uploader::v1::KafkaHookOptions* PROTOBUF_NONNULL _internal_mutable_kafka_hook_opts();

  public:
  // .uploader.v1.NatsHookOptions nats_hook_opts = 11 [json_name = "natsHookOpts"];
  bool has_nats_hook_opts() const;
  void clear_nats_hook_opts() ;
  const ::uploader::v1::NatsHookOptions& nats_hook_opts() const;
  [[nodiscard]] ::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE release_nats_hook_opts();
  ::uploader::v1::NatsHookOptions* PROTOBUF_NONNULL mutable_nats_hook_opts();
  void set_allocated_nats_hook_opts(::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_nats_hook_opts(::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE unsafe_arena_release_nats_hook_opts();

  private:
  const ::uploader::v1::NatsHookOptions& _internal_nats_hook_opts() const;
  ::uploader::v1::NatsHookOptions* PROTOBUF_NONNULL _internal_mutable_nats_hook_opts();

  public:
  // .uploader.v1.Format hooks_format = 1 [json_name = "hooksFormat"];
  void clear_hooks_format() ;
  ::uploader::v1::Format hooks_format() const;
  void set_hooks_format(::uploader::v1::Format value);

  private:
  ::uploader::v1::Format _internal_hooks_format() const;
  void _internal_set_hooks_format(::uploader::v1::Format value);

  public:
  // bool behind_proxy = 3 [json_name = "behindProxy"];
  void clear_behind_proxy() ;
  bool behind_proxy() const;
  void set_behind_proxy(bool value);

  private:
  bool _internal_behind_proxy() const;
  void _internal_set_behind_proxy(bool value);

  public:
  // optional uint64 http_hook_timeout = 5 [json_name = "httpHookTimeout"];
  bool has_http_hook_timeout() const;
  void clear_http_hook_timeout() ;
  ::uint64_t http_hook_timeout() const;
  void set_http_hook_timeout(::uint64_t value);

  private:
  ::uint64_t _internal_http_hook_timeout() const;
  void _internal_set_http_hook_timeout(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.NotificationsOptions)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11,
                                   3, 107,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const NotificationsOptions& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<int> hooks_;
    ::google::protobuf::internal::CachedSize _hooks_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> hooks_http_urls_;
    ::google::protobuf::RepeatedPtrField<::std::string> hooks_http_proxy_headers_;
    ::google::protobuf::internal::ArenaStringPtr hooks_dir_;
    ::google::protobuf::internal::ArenaStringPtr hooks_file_;
    ::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE amqp_hook_opts_;
    ::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE kafka_hook_opts_;
    ::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE nats_hook_opts_;
    int hooks_format_;
    bool behind_proxy_;
    ::uint64_t http_hook_timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull NotificationsOptions_class_data_;
// -------------------------------------------------------------------

class RustusConf final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:uploader.v1.RustusConf) */ {
 public:
  inline RustusConf() : RustusConf(nullptr) {}
  ~RustusConf() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RustusConf* PROTOBUF_NONNULL msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RustusConf));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RustusConf(::google::protobuf::internal::ConstantInitialized);

  inline RustusConf(const RustusConf& from) : RustusConf(nullptr, from) {}
  inline RustusConf(RustusConf&& from) noexcept
      : RustusConf(nullptr, ::std::move(from)) {}
  inline RustusConf& operator=(const RustusConf& from) {
    CopyFrom(from);
    return *this;
  }
  inline RustusConf& operator=(RustusConf&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* PROTOBUF_NONNULL mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* PROTOBUF_NONNULL GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* PROTOBUF_NONNULL GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RustusConf& default_instance() {
    return *reinterpret_cast<const RustusConf*>(
        &_RustusConf_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(RustusConf& a, RustusConf& b) { a.Swap(&b); }
  inline void Swap(RustusConf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RustusConf* PROTOBUF_NONNULL other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RustusConf* PROTOBUF_NONNULL New(::google::protobuf::Arena* PROTOBUF_NULLABLE arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RustusConf>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RustusConf& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RustusConf& from) { RustusConf::MergeImpl(*this, from); }

  private:
  static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                        const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      const ::google::protobuf::MessageLite& msg, ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* PROTOBUF_NONNULL _InternalSerialize(
      ::uint8_t* PROTOBUF_NONNULL target,
      ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RustusConf* PROTOBUF_NONNULL other);
 private:
  template <typename T>
  friend ::absl::string_view(::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "uploader.v1.RustusConf"; }

 protected:
  explicit RustusConf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  RustusConf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const RustusConf& from);
  RustusConf(
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, RustusConf&& from) noexcept
      : RustusConf(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL GetClassData() const PROTOBUF_FINAL;
  static void* PROTOBUF_NONNULL PlacementNew_(
      const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
      ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
  static constexpr auto InternalNewImpl_();

 public:
  static constexpr auto InternalGenerateClassData_();

  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCorsFieldNumber = 5,
    kTusExtensionsFieldNumber = 9,
    kHostFieldNumber = 1,
    kUrlFieldNumber = 4,
    kLogLevelFieldNumber = 7,
    kStorageOptsFieldNumber = 13,
    kInfoStorageOptsFieldNumber = 14,
    kNotificationOptsFieldNumber = 15,
    kSentryOptsFieldNumber = 16,
    kPortFieldNumber = 2,
    kMaxBodySizeFieldNumber = 6,
    kWorkersFieldNumber = 8,
    kDisableHealthAccessLogFieldNumber = 3,
    kAllowEmptyFieldNumber = 10,
    kRemovePartsFieldNumber = 11,
    kMaxFileSizeFieldNumber = 12,
  };
  // repeated string cors = 5 [json_name = "cors"];
  int cors_size() const;
  private:
  int _internal_cors_size() const;

  public:
  void clear_cors() ;
  const ::std::string& cors(int index) const;
  ::std::string* PROTOBUF_NONNULL mutable_cors(int index);
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_cors(int index, Arg_&& value, Args_... args);
  ::std::string* PROTOBUF_NONNULL add_cors();
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void add_cors(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<::std::string>& cors() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL mutable_cors();

  private:
  const ::google::protobuf::RepeatedPtrField<::std::string>& _internal_cors() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL _internal_mutable_cors();

  public:
  // repeated .uploader.v1.Extensions tus_extensions = 9 [json_name = "tusExtensions"];
  int tus_extensions_size() const;
  private:
  int _internal_tus_extensions_size() const;

  public:
  void clear_tus_extensions() ;
  public:
  ::uploader::v1::Extensions tus_extensions(int index) const;
  void set_tus_extensions(int index, ::uploader::v1::Extensions value);
  void add_tus_extensions(::uploader::v1::Extensions value);
  const ::google::protobuf::RepeatedField<int>& tus_extensions() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL mutable_tus_extensions();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_tus_extensions() const;
  ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL _internal_mutable_tus_extensions();

  public:
  // string host = 1 [json_name = "host"];
  void clear_host() ;
  const ::std::string& host() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_host(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_host();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_host();
  void set_allocated_host(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_host() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_host(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_host();

  public:
  // string url = 4 [json_name = "url"];
  void clear_url() ;
  const ::std::string& url() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_url(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_url();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_url();
  void set_allocated_url(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_url() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_url(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_url();

  public:
  // string log_level = 7 [json_name = "logLevel"];
  void clear_log_level() ;
  const ::std::string& log_level() const;
  template <typename Arg_ = const ::std::string&, typename... Args_>
  void set_log_level(Arg_&& arg, Args_... args);
  ::std::string* PROTOBUF_NONNULL mutable_log_level();
  [[nodiscard]] ::std::string* PROTOBUF_NULLABLE release_log_level();
  void set_allocated_log_level(::std::string* PROTOBUF_NULLABLE value);

  private:
  const ::std::string& _internal_log_level() const;
  PROTOBUF_ALWAYS_INLINE void _internal_set_log_level(const ::std::string& value);
  ::std::string* PROTOBUF_NONNULL _internal_mutable_log_level();

  public:
  // .uploader.v1.DataStorageOptions storage_opts = 13 [json_name = "storageOpts"];
  bool has_storage_opts() const;
  void clear_storage_opts() ;
  const ::uploader::v1::DataStorageOptions& storage_opts() const;
  [[nodiscard]] ::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE release_storage_opts();
  ::uploader::v1::DataStorageOptions* PROTOBUF_NONNULL mutable_storage_opts();
  void set_allocated_storage_opts(::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_storage_opts(::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE unsafe_arena_release_storage_opts();

  private:
  const ::uploader::v1::DataStorageOptions& _internal_storage_opts() const;
  ::uploader::v1::DataStorageOptions* PROTOBUF_NONNULL _internal_mutable_storage_opts();

  public:
  // .uploader.v1.InfoStoreOptions info_storage_opts = 14 [json_name = "infoStorageOpts"];
  bool has_info_storage_opts() const;
  void clear_info_storage_opts() ;
  const ::uploader::v1::InfoStoreOptions& info_storage_opts() const;
  [[nodiscard]] ::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE release_info_storage_opts();
  ::uploader::v1::InfoStoreOptions* PROTOBUF_NONNULL mutable_info_storage_opts();
  void set_allocated_info_storage_opts(::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_info_storage_opts(::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE unsafe_arena_release_info_storage_opts();

  private:
  const ::uploader::v1::InfoStoreOptions& _internal_info_storage_opts() const;
  ::uploader::v1::InfoStoreOptions* PROTOBUF_NONNULL _internal_mutable_info_storage_opts();

  public:
  // .uploader.v1.NotificationsOptions notification_opts = 15 [json_name = "notificationOpts"];
  bool has_notification_opts() const;
  void clear_notification_opts() ;
  const ::uploader::v1::NotificationsOptions& notification_opts() const;
  [[nodiscard]] ::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE release_notification_opts();
  ::uploader::v1::NotificationsOptions* PROTOBUF_NONNULL mutable_notification_opts();
  void set_allocated_notification_opts(::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_notification_opts(::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE unsafe_arena_release_notification_opts();

  private:
  const ::uploader::v1::NotificationsOptions& _internal_notification_opts() const;
  ::uploader::v1::NotificationsOptions* PROTOBUF_NONNULL _internal_mutable_notification_opts();

  public:
  // .uploader.v1.SentryOptions sentry_opts = 16 [json_name = "sentryOpts"];
  bool has_sentry_opts() const;
  void clear_sentry_opts() ;
  const ::uploader::v1::SentryOptions& sentry_opts() const;
  [[nodiscard]] ::uploader::v1::SentryOptions* PROTOBUF_NULLABLE release_sentry_opts();
  ::uploader::v1::SentryOptions* PROTOBUF_NONNULL mutable_sentry_opts();
  void set_allocated_sentry_opts(::uploader::v1::SentryOptions* PROTOBUF_NULLABLE value);
  void unsafe_arena_set_allocated_sentry_opts(::uploader::v1::SentryOptions* PROTOBUF_NULLABLE value);
  ::uploader::v1::SentryOptions* PROTOBUF_NULLABLE unsafe_arena_release_sentry_opts();

  private:
  const ::uploader::v1::SentryOptions& _internal_sentry_opts() const;
  ::uploader::v1::SentryOptions* PROTOBUF_NONNULL _internal_mutable_sentry_opts();

  public:
  // uint32 port = 2 [json_name = "port"];
  void clear_port() ;
  ::uint32_t port() const;
  void set_port(::uint32_t value);

  private:
  ::uint32_t _internal_port() const;
  void _internal_set_port(::uint32_t value);

  public:
  // uint32 max_body_size = 6 [json_name = "maxBodySize"];
  void clear_max_body_size() ;
  ::uint32_t max_body_size() const;
  void set_max_body_size(::uint32_t value);

  private:
  ::uint32_t _internal_max_body_size() const;
  void _internal_set_max_body_size(::uint32_t value);

  public:
  // optional uint32 workers = 8 [json_name = "workers"];
  bool has_workers() const;
  void clear_workers() ;
  ::uint32_t workers() const;
  void set_workers(::uint32_t value);

  private:
  ::uint32_t _internal_workers() const;
  void _internal_set_workers(::uint32_t value);

  public:
  // bool disable_health_access_log = 3 [json_name = "disableHealthAccessLog"];
  void clear_disable_health_access_log() ;
  bool disable_health_access_log() const;
  void set_disable_health_access_log(bool value);

  private:
  bool _internal_disable_health_access_log() const;
  void _internal_set_disable_health_access_log(bool value);

  public:
  // bool allow_empty = 10 [json_name = "allowEmpty"];
  void clear_allow_empty() ;
  bool allow_empty() const;
  void set_allow_empty(bool value);

  private:
  bool _internal_allow_empty() const;
  void _internal_set_allow_empty(bool value);

  public:
  // bool remove_parts = 11 [json_name = "removeParts"];
  void clear_remove_parts() ;
  bool remove_parts() const;
  void set_remove_parts(bool value);

  private:
  bool _internal_remove_parts() const;
  void _internal_set_remove_parts(bool value);

  public:
  // optional uint32 max_file_size = 12 [json_name = "maxFileSize"];
  bool has_max_file_size() const;
  void clear_max_file_size() ;
  ::uint32_t max_file_size() const;
  void set_max_file_size(::uint32_t value);

  private:
  ::uint32_t _internal_max_file_size() const;
  void _internal_set_max_file_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:uploader.v1.RustusConf)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 16,
                                   4, 67,
                                   2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena);
    inline explicit Impl_(
        ::google::protobuf::internal::InternalVisibility visibility,
        ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
        const RustusConf& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<::std::string> cors_;
    ::google::protobuf::RepeatedField<int> tus_extensions_;
    ::google::protobuf::internal::CachedSize _tus_extensions_cached_byte_size_;
    ::google::protobuf::internal::ArenaStringPtr host_;
    ::google::protobuf::internal::ArenaStringPtr url_;
    ::google::protobuf::internal::ArenaStringPtr log_level_;
    ::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE storage_opts_;
    ::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE info_storage_opts_;
    ::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE notification_opts_;
    ::uploader::v1::SentryOptions* PROTOBUF_NULLABLE sentry_opts_;
    ::uint32_t port_;
    ::uint32_t max_body_size_;
    ::uint32_t workers_;
    bool disable_health_access_log_;
    bool allow_empty_;
    bool remove_parts_;
    ::uint32_t max_file_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_uploader_2fv1_2fconfig_2eproto;
};

extern const ::google::protobuf::internal::ClassDataFull RustusConf_class_data_;

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ExtraKafkaOptions

// map<string, string> opts = 1 [json_name = "opts"];
inline int ExtraKafkaOptions::_internal_opts_size() const {
  return _internal_opts().size();
}
inline int ExtraKafkaOptions::opts_size() const {
  return _internal_opts_size();
}
inline void ExtraKafkaOptions::clear_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.opts_.Clear();
}
inline const ::google::protobuf::Map<std::string, std::string>& ExtraKafkaOptions::_internal_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.opts_.GetMap();
}
inline const ::google::protobuf::Map<std::string, std::string>& ExtraKafkaOptions::opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_map:uploader.v1.ExtraKafkaOptions.opts)
  return _internal_opts();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL ExtraKafkaOptions::_internal_mutable_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.opts_.MutableMap();
}
inline ::google::protobuf::Map<std::string, std::string>* PROTOBUF_NONNULL ExtraKafkaOptions::mutable_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_map:uploader.v1.ExtraKafkaOptions.opts)
  return _internal_mutable_opts();
}

// -------------------------------------------------------------------

// DataStorageOptions

// .uploader.v1.AvailableDataStorages storage = 1 [json_name = "storage"];
inline void DataStorageOptions::clear_storage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.storage_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uploader::v1::AvailableDataStorages DataStorageOptions::storage() const {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.storage)
  return _internal_storage();
}
inline void DataStorageOptions::set_storage(::uploader::v1::AvailableDataStorages value) {
  _internal_set_storage(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.storage)
}
inline ::uploader::v1::AvailableDataStorages DataStorageOptions::_internal_storage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::uploader::v1::AvailableDataStorages>(_impl_.storage_);
}
inline void DataStorageOptions::_internal_set_storage(::uploader::v1::AvailableDataStorages value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.storage_ = value;
}

// string data_dir = 2 [json_name = "dataDir"];
inline void DataStorageOptions::clear_data_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_dir_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DataStorageOptions::data_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.data_dir)
  return _internal_data_dir();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_data_dir(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.data_dir)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_data_dir()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_data_dir();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.data_dir)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_data_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_dir_.Get();
}
inline void DataStorageOptions::_internal_set_data_dir(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.data_dir_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_data_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.data_dir_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_data_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.data_dir)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.data_dir_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.data_dir_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_data_dir(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.data_dir_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_dir_.IsDefault()) {
    _impl_.data_dir_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.data_dir)
}

// string dir_structure = 3 [json_name = "dirStructure"];
inline void DataStorageOptions::clear_dir_structure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dir_structure_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& DataStorageOptions::dir_structure() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.dir_structure)
  return _internal_dir_structure();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_dir_structure(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dir_structure_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.dir_structure)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_dir_structure()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_dir_structure();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.dir_structure)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_dir_structure() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dir_structure_.Get();
}
inline void DataStorageOptions::_internal_set_dir_structure(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.dir_structure_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_dir_structure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.dir_structure_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_dir_structure() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.dir_structure)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.dir_structure_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dir_structure_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_dir_structure(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.dir_structure_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dir_structure_.IsDefault()) {
    _impl_.dir_structure_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.dir_structure)
}

// bool force_fsync = 4 [json_name = "forceFsync"];
inline void DataStorageOptions::clear_force_fsync() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.force_fsync_ = false;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline bool DataStorageOptions::force_fsync() const {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.force_fsync)
  return _internal_force_fsync();
}
inline void DataStorageOptions::set_force_fsync(bool value) {
  _internal_set_force_fsync(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.force_fsync)
}
inline bool DataStorageOptions::_internal_force_fsync() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.force_fsync_;
}
inline void DataStorageOptions::_internal_set_force_fsync(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.force_fsync_ = value;
}

// optional string s3_bucket = 5 [json_name = "s3Bucket"];
inline bool DataStorageOptions::has_s3_bucket() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_bucket_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& DataStorageOptions::s3_bucket() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_bucket)
  return _internal_s3_bucket();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_bucket(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.s3_bucket_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_bucket)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_bucket()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_bucket();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_bucket)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_bucket() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_bucket_.Get();
}
inline void DataStorageOptions::_internal_set_s3_bucket(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.s3_bucket_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.s3_bucket_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_bucket() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_bucket)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.s3_bucket_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_bucket_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_bucket(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.s3_bucket_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_bucket_.IsDefault()) {
    _impl_.s3_bucket_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_bucket)
}

// optional string s3_region = 6 [json_name = "s3Region"];
inline bool DataStorageOptions::has_s3_region() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_region_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& DataStorageOptions::s3_region() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_region)
  return _internal_s3_region();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_region(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.s3_region_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_region)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_region()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_region();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_region)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_region() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_region_.Get();
}
inline void DataStorageOptions::_internal_set_s3_region(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.s3_region_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.s3_region_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_region() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_region)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.s3_region_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_region_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_region(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.s3_region_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_region_.IsDefault()) {
    _impl_.s3_region_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_region)
}

// optional string s3_access_key = 7 [json_name = "s3AccessKey"];
inline bool DataStorageOptions::has_s3_access_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_access_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& DataStorageOptions::s3_access_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_access_key)
  return _internal_s3_access_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_access_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.s3_access_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_access_key)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_access_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_access_key();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_access_key)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_access_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_access_key_.Get();
}
inline void DataStorageOptions::_internal_set_s3_access_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.s3_access_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.s3_access_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_access_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_access_key)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.s3_access_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_access_key_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_access_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.s3_access_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_access_key_.IsDefault()) {
    _impl_.s3_access_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_access_key)
}

// optional string s3_access_key_path = 8 [json_name = "s3AccessKeyPath"];
inline bool DataStorageOptions::has_s3_access_key_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_access_key_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_access_key_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& DataStorageOptions::s3_access_key_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_access_key_path)
  return _internal_s3_access_key_path();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_access_key_path(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.s3_access_key_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_access_key_path)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_access_key_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_access_key_path();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_access_key_path)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_access_key_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_access_key_path_.Get();
}
inline void DataStorageOptions::_internal_set_s3_access_key_path(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.s3_access_key_path_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_access_key_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.s3_access_key_path_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_access_key_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_access_key_path)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.s3_access_key_path_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_access_key_path_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_access_key_path(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.s3_access_key_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_access_key_path_.IsDefault()) {
    _impl_.s3_access_key_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_access_key_path)
}

// optional string s3_secret_key = 9 [json_name = "s3SecretKey"];
inline bool DataStorageOptions::has_s3_secret_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_secret_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_secret_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& DataStorageOptions::s3_secret_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_secret_key)
  return _internal_s3_secret_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_secret_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.s3_secret_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_secret_key)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_secret_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_secret_key();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_secret_key)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_secret_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_secret_key_.Get();
}
inline void DataStorageOptions::_internal_set_s3_secret_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.s3_secret_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_secret_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000040u;
  return _impl_.s3_secret_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_secret_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_secret_key)
  if ((_impl_._has_bits_[0] & 0x00000040u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000040u;
  auto* released = _impl_.s3_secret_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_secret_key_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_secret_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.s3_secret_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_secret_key_.IsDefault()) {
    _impl_.s3_secret_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_secret_key)
}

// optional string s3_secret_key_path = 10 [json_name = "s3SecretKeyPath"];
inline bool DataStorageOptions::has_s3_secret_key_path() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_secret_key_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_secret_key_path_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::std::string& DataStorageOptions::s3_secret_key_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_secret_key_path)
  return _internal_s3_secret_key_path();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_secret_key_path(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.s3_secret_key_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_secret_key_path)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_secret_key_path()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_secret_key_path();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_secret_key_path)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_secret_key_path() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_secret_key_path_.Get();
}
inline void DataStorageOptions::_internal_set_s3_secret_key_path(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.s3_secret_key_path_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_secret_key_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000080u;
  return _impl_.s3_secret_key_path_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_secret_key_path() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_secret_key_path)
  if ((_impl_._has_bits_[0] & 0x00000080u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000080u;
  auto* released = _impl_.s3_secret_key_path_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_secret_key_path_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_secret_key_path(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.s3_secret_key_path_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_secret_key_path_.IsDefault()) {
    _impl_.s3_secret_key_path_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_secret_key_path)
}

// optional string s3_url = 11 [json_name = "s3Url"];
inline bool DataStorageOptions::has_s3_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::std::string& DataStorageOptions::s3_url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_url)
  return _internal_s3_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.s3_url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_url)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_url();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_url)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_url_.Get();
}
inline void DataStorageOptions::_internal_set_s3_url(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.s3_url_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000100u;
  return _impl_.s3_url_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_url)
  if ((_impl_._has_bits_[0] & 0x00000100u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000100u;
  auto* released = _impl_.s3_url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_url_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_url(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.s3_url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_url_.IsDefault()) {
    _impl_.s3_url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_url)
}

// bool s3_force_path_style = 12 [json_name = "s3ForcePathStyle"];
inline void DataStorageOptions::clear_s3_force_path_style() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_force_path_style_ = false;
  _impl_._has_bits_[0] &= ~0x00008000u;
}
inline bool DataStorageOptions::s3_force_path_style() const {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_force_path_style)
  return _internal_s3_force_path_style();
}
inline void DataStorageOptions::set_s3_force_path_style(bool value) {
  _internal_set_s3_force_path_style(value);
  _impl_._has_bits_[0] |= 0x00008000u;
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_force_path_style)
}
inline bool DataStorageOptions::_internal_s3_force_path_style() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_force_path_style_;
}
inline void DataStorageOptions::_internal_set_s3_force_path_style(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_force_path_style_ = value;
}

// optional string s3_security_token = 13 [json_name = "s3SecurityToken"];
inline bool DataStorageOptions::has_s3_security_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_security_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_security_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::std::string& DataStorageOptions::s3_security_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_security_token)
  return _internal_s3_security_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_security_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.s3_security_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_security_token)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_security_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_security_token();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_security_token)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_security_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_security_token_.Get();
}
inline void DataStorageOptions::_internal_set_s3_security_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.s3_security_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_security_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000200u;
  return _impl_.s3_security_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_security_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_security_token)
  if ((_impl_._has_bits_[0] & 0x00000200u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000200u;
  auto* released = _impl_.s3_security_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_security_token_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_security_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.s3_security_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_security_token_.IsDefault()) {
    _impl_.s3_security_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_security_token)
}

// optional string s3_session_token = 14 [json_name = "s3SessionToken"];
inline bool DataStorageOptions::has_s3_session_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_session_token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::std::string& DataStorageOptions::s3_session_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_session_token)
  return _internal_s3_session_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_session_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.s3_session_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_session_token)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_session_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_session_token();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_session_token)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_session_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_session_token_.Get();
}
inline void DataStorageOptions::_internal_set_s3_session_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.s3_session_token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000400u;
  return _impl_.s3_session_token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_session_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_session_token)
  if ((_impl_._has_bits_[0] & 0x00000400u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000400u;
  auto* released = _impl_.s3_session_token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_session_token_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_session_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.s3_session_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_session_token_.IsDefault()) {
    _impl_.s3_session_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_session_token)
}

// optional string s3_profile = 15 [json_name = "s3Profile"];
inline bool DataStorageOptions::has_s3_profile() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_profile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_profile_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline const ::std::string& DataStorageOptions::s3_profile() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_profile)
  return _internal_s3_profile();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_profile(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.s3_profile_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_profile)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_profile()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_profile();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_profile)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_profile() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_profile_.Get();
}
inline void DataStorageOptions::_internal_set_s3_profile(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.s3_profile_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_profile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000800u;
  return _impl_.s3_profile_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_profile() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_profile)
  if ((_impl_._has_bits_[0] & 0x00000800u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000800u;
  auto* released = _impl_.s3_profile_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_profile_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_profile(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000800u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000800u;
  }
  _impl_.s3_profile_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_profile_.IsDefault()) {
    _impl_.s3_profile_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_profile)
}

// optional string s3_headers = 16 [json_name = "s3Headers"];
inline bool DataStorageOptions::has_s3_headers() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline void DataStorageOptions::clear_s3_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_headers_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline const ::std::string& DataStorageOptions::s3_headers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_headers)
  return _internal_s3_headers();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void DataStorageOptions::set_s3_headers(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.s3_headers_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_headers)
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::mutable_s3_headers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_s3_headers();
  // @@protoc_insertion_point(field_mutable:uploader.v1.DataStorageOptions.s3_headers)
  return _s;
}
inline const ::std::string& DataStorageOptions::_internal_s3_headers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_headers_.Get();
}
inline void DataStorageOptions::_internal_set_s3_headers(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.s3_headers_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL DataStorageOptions::_internal_mutable_s3_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00001000u;
  return _impl_.s3_headers_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE DataStorageOptions::release_s3_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.DataStorageOptions.s3_headers)
  if ((_impl_._has_bits_[0] & 0x00001000u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00001000u;
  auto* released = _impl_.s3_headers_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.s3_headers_.Set("", GetArena());
  }
  return released;
}
inline void DataStorageOptions::set_allocated_s3_headers(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00001000u;
  } else {
    _impl_._has_bits_[0] &= ~0x00001000u;
  }
  _impl_.s3_headers_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.s3_headers_.IsDefault()) {
    _impl_.s3_headers_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.DataStorageOptions.s3_headers)
}

// uint32 s3_concat_concurrent_downloads = 17 [json_name = "s3ConcatConcurrentDownloads"];
inline void DataStorageOptions::clear_s3_concat_concurrent_downloads() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_concat_concurrent_downloads_ = 0u;
  _impl_._has_bits_[0] &= ~0x00010000u;
}
inline ::uint32_t DataStorageOptions::s3_concat_concurrent_downloads() const {
  // @@protoc_insertion_point(field_get:uploader.v1.DataStorageOptions.s3_concat_concurrent_downloads)
  return _internal_s3_concat_concurrent_downloads();
}
inline void DataStorageOptions::set_s3_concat_concurrent_downloads(::uint32_t value) {
  _internal_set_s3_concat_concurrent_downloads(value);
  _impl_._has_bits_[0] |= 0x00010000u;
  // @@protoc_insertion_point(field_set:uploader.v1.DataStorageOptions.s3_concat_concurrent_downloads)
}
inline ::uint32_t DataStorageOptions::_internal_s3_concat_concurrent_downloads() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.s3_concat_concurrent_downloads_;
}
inline void DataStorageOptions::_internal_set_s3_concat_concurrent_downloads(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.s3_concat_concurrent_downloads_ = value;
}

// -------------------------------------------------------------------

// InfoStoreOptions

// .uploader.v1.AvailableInfoStorages info_storage = 1 [json_name = "infoStorage"];
inline void InfoStoreOptions::clear_info_storage() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_storage_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::uploader::v1::AvailableInfoStorages InfoStoreOptions::info_storage() const {
  // @@protoc_insertion_point(field_get:uploader.v1.InfoStoreOptions.info_storage)
  return _internal_info_storage();
}
inline void InfoStoreOptions::set_info_storage(::uploader::v1::AvailableInfoStorages value) {
  _internal_set_info_storage(value);
  _impl_._has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_set:uploader.v1.InfoStoreOptions.info_storage)
}
inline ::uploader::v1::AvailableInfoStorages InfoStoreOptions::_internal_info_storage() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::uploader::v1::AvailableInfoStorages>(_impl_.info_storage_);
}
inline void InfoStoreOptions::_internal_set_info_storage(::uploader::v1::AvailableInfoStorages value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_storage_ = value;
}

// string info_dir = 2 [json_name = "infoDir"];
inline void InfoStoreOptions::clear_info_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_dir_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& InfoStoreOptions::info_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.InfoStoreOptions.info_dir)
  return _internal_info_dir();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InfoStoreOptions::set_info_dir(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.info_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.InfoStoreOptions.info_dir)
}
inline ::std::string* PROTOBUF_NONNULL InfoStoreOptions::mutable_info_dir()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_info_dir();
  // @@protoc_insertion_point(field_mutable:uploader.v1.InfoStoreOptions.info_dir)
  return _s;
}
inline const ::std::string& InfoStoreOptions::_internal_info_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.info_dir_.Get();
}
inline void InfoStoreOptions::_internal_set_info_dir(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.info_dir_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InfoStoreOptions::_internal_mutable_info_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.info_dir_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InfoStoreOptions::release_info_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.InfoStoreOptions.info_dir)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.info_dir_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.info_dir_.Set("", GetArena());
  }
  return released;
}
inline void InfoStoreOptions::set_allocated_info_dir(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.info_dir_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.info_dir_.IsDefault()) {
    _impl_.info_dir_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.InfoStoreOptions.info_dir)
}

// optional string info_db_dsn = 3 [json_name = "infoDbDsn"];
inline bool InfoStoreOptions::has_info_db_dsn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void InfoStoreOptions::clear_info_db_dsn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.info_db_dsn_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& InfoStoreOptions::info_db_dsn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.InfoStoreOptions.info_db_dsn)
  return _internal_info_db_dsn();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void InfoStoreOptions::set_info_db_dsn(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.info_db_dsn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.InfoStoreOptions.info_db_dsn)
}
inline ::std::string* PROTOBUF_NONNULL InfoStoreOptions::mutable_info_db_dsn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_info_db_dsn();
  // @@protoc_insertion_point(field_mutable:uploader.v1.InfoStoreOptions.info_db_dsn)
  return _s;
}
inline const ::std::string& InfoStoreOptions::_internal_info_db_dsn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.info_db_dsn_.Get();
}
inline void InfoStoreOptions::_internal_set_info_db_dsn(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.info_db_dsn_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL InfoStoreOptions::_internal_mutable_info_db_dsn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.info_db_dsn_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE InfoStoreOptions::release_info_db_dsn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.InfoStoreOptions.info_db_dsn)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.info_db_dsn_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.info_db_dsn_.Set("", GetArena());
  }
  return released;
}
inline void InfoStoreOptions::set_allocated_info_db_dsn(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.info_db_dsn_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.info_db_dsn_.IsDefault()) {
    _impl_.info_db_dsn_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.InfoStoreOptions.info_db_dsn)
}

// optional uint32 redis_info_expiration = 4 [json_name = "redisInfoExpiration"];
inline bool InfoStoreOptions::has_redis_info_expiration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void InfoStoreOptions::clear_redis_info_expiration() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redis_info_expiration_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::uint32_t InfoStoreOptions::redis_info_expiration() const {
  // @@protoc_insertion_point(field_get:uploader.v1.InfoStoreOptions.redis_info_expiration)
  return _internal_redis_info_expiration();
}
inline void InfoStoreOptions::set_redis_info_expiration(::uint32_t value) {
  _internal_set_redis_info_expiration(value);
  _impl_._has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_set:uploader.v1.InfoStoreOptions.redis_info_expiration)
}
inline ::uint32_t InfoStoreOptions::_internal_redis_info_expiration() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.redis_info_expiration_;
}
inline void InfoStoreOptions::_internal_set_redis_info_expiration(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.redis_info_expiration_ = value;
}

// -------------------------------------------------------------------

// AMQPHooksOptions

// optional string url = 1 [json_name = "url"];
inline bool AMQPHooksOptions::has_url() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AMQPHooksOptions::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& AMQPHooksOptions::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AMQPHooksOptions::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.url)
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:uploader.v1.AMQPHooksOptions.url)
  return _s;
}
inline const ::std::string& AMQPHooksOptions::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void AMQPHooksOptions::_internal_set_url(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.url_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.url_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AMQPHooksOptions::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.AMQPHooksOptions.url)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void AMQPHooksOptions::set_allocated_url(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.AMQPHooksOptions.url)
}

// bool declare_exchange = 2 [json_name = "declareExchange"];
inline void AMQPHooksOptions::clear_declare_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.declare_exchange_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool AMQPHooksOptions::declare_exchange() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.declare_exchange)
  return _internal_declare_exchange();
}
inline void AMQPHooksOptions::set_declare_exchange(bool value) {
  _internal_set_declare_exchange(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.declare_exchange)
}
inline bool AMQPHooksOptions::_internal_declare_exchange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.declare_exchange_;
}
inline void AMQPHooksOptions::_internal_set_declare_exchange(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.declare_exchange_ = value;
}

// bool declare_queues = 3 [json_name = "declareQueues"];
inline void AMQPHooksOptions::clear_declare_queues() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.declare_queues_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool AMQPHooksOptions::declare_queues() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.declare_queues)
  return _internal_declare_queues();
}
inline void AMQPHooksOptions::set_declare_queues(bool value) {
  _internal_set_declare_queues(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.declare_queues)
}
inline bool AMQPHooksOptions::_internal_declare_queues() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.declare_queues_;
}
inline void AMQPHooksOptions::_internal_set_declare_queues(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.declare_queues_ = value;
}

// bool durable_exchange = 4 [json_name = "durableExchange"];
inline void AMQPHooksOptions::clear_durable_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.durable_exchange_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool AMQPHooksOptions::durable_exchange() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.durable_exchange)
  return _internal_durable_exchange();
}
inline void AMQPHooksOptions::set_durable_exchange(bool value) {
  _internal_set_durable_exchange(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.durable_exchange)
}
inline bool AMQPHooksOptions::_internal_durable_exchange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.durable_exchange_;
}
inline void AMQPHooksOptions::_internal_set_durable_exchange(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.durable_exchange_ = value;
}

// bool durable_queues = 5 [json_name = "durableQueues"];
inline void AMQPHooksOptions::clear_durable_queues() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.durable_queues_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool AMQPHooksOptions::durable_queues() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.durable_queues)
  return _internal_durable_queues();
}
inline void AMQPHooksOptions::set_durable_queues(bool value) {
  _internal_set_durable_queues(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.durable_queues)
}
inline bool AMQPHooksOptions::_internal_durable_queues() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.durable_queues_;
}
inline void AMQPHooksOptions::_internal_set_durable_queues(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.durable_queues_ = value;
}

// bool celery = 6 [json_name = "celery"];
inline void AMQPHooksOptions::clear_celery() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.celery_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool AMQPHooksOptions::celery() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.celery)
  return _internal_celery();
}
inline void AMQPHooksOptions::set_celery(bool value) {
  _internal_set_celery(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.celery)
}
inline bool AMQPHooksOptions::_internal_celery() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.celery_;
}
inline void AMQPHooksOptions::_internal_set_celery(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.celery_ = value;
}

// string exchange = 7 [json_name = "exchange"];
inline void AMQPHooksOptions::clear_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exchange_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& AMQPHooksOptions::exchange() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.exchange)
  return _internal_exchange();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AMQPHooksOptions::set_exchange(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.exchange_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.exchange)
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::mutable_exchange()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_exchange();
  // @@protoc_insertion_point(field_mutable:uploader.v1.AMQPHooksOptions.exchange)
  return _s;
}
inline const ::std::string& AMQPHooksOptions::_internal_exchange() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exchange_.Get();
}
inline void AMQPHooksOptions::_internal_set_exchange(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.exchange_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::_internal_mutable_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.exchange_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AMQPHooksOptions::release_exchange() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.AMQPHooksOptions.exchange)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.exchange_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.exchange_.Set("", GetArena());
  }
  return released;
}
inline void AMQPHooksOptions::set_allocated_exchange(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.exchange_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.exchange_.IsDefault()) {
    _impl_.exchange_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.AMQPHooksOptions.exchange)
}

// string exchange_kind = 8 [json_name = "exchangeKind"];
inline void AMQPHooksOptions::clear_exchange_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.exchange_kind_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& AMQPHooksOptions::exchange_kind() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.exchange_kind)
  return _internal_exchange_kind();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AMQPHooksOptions::set_exchange_kind(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.exchange_kind_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.exchange_kind)
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::mutable_exchange_kind()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_exchange_kind();
  // @@protoc_insertion_point(field_mutable:uploader.v1.AMQPHooksOptions.exchange_kind)
  return _s;
}
inline const ::std::string& AMQPHooksOptions::_internal_exchange_kind() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.exchange_kind_.Get();
}
inline void AMQPHooksOptions::_internal_set_exchange_kind(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.exchange_kind_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::_internal_mutable_exchange_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.exchange_kind_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AMQPHooksOptions::release_exchange_kind() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.AMQPHooksOptions.exchange_kind)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.exchange_kind_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.exchange_kind_.Set("", GetArena());
  }
  return released;
}
inline void AMQPHooksOptions::set_allocated_exchange_kind(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.exchange_kind_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.exchange_kind_.IsDefault()) {
    _impl_.exchange_kind_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.AMQPHooksOptions.exchange_kind)
}

// optional string routing_key = 9 [json_name = "routingKey"];
inline bool AMQPHooksOptions::has_routing_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void AMQPHooksOptions::clear_routing_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.routing_key_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& AMQPHooksOptions::routing_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.routing_key)
  return _internal_routing_key();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AMQPHooksOptions::set_routing_key(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.routing_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.routing_key)
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::mutable_routing_key()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_routing_key();
  // @@protoc_insertion_point(field_mutable:uploader.v1.AMQPHooksOptions.routing_key)
  return _s;
}
inline const ::std::string& AMQPHooksOptions::_internal_routing_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.routing_key_.Get();
}
inline void AMQPHooksOptions::_internal_set_routing_key(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.routing_key_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::_internal_mutable_routing_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.routing_key_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AMQPHooksOptions::release_routing_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.AMQPHooksOptions.routing_key)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.routing_key_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.routing_key_.Set("", GetArena());
  }
  return released;
}
inline void AMQPHooksOptions::set_allocated_routing_key(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.routing_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.routing_key_.IsDefault()) {
    _impl_.routing_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.AMQPHooksOptions.routing_key)
}

// string queues_prefix = 10 [json_name = "queuesPrefix"];
inline void AMQPHooksOptions::clear_queues_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.queues_prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& AMQPHooksOptions::queues_prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.queues_prefix)
  return _internal_queues_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void AMQPHooksOptions::set_queues_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.queues_prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.queues_prefix)
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::mutable_queues_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_queues_prefix();
  // @@protoc_insertion_point(field_mutable:uploader.v1.AMQPHooksOptions.queues_prefix)
  return _s;
}
inline const ::std::string& AMQPHooksOptions::_internal_queues_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.queues_prefix_.Get();
}
inline void AMQPHooksOptions::_internal_set_queues_prefix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.queues_prefix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL AMQPHooksOptions::_internal_mutable_queues_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.queues_prefix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE AMQPHooksOptions::release_queues_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.AMQPHooksOptions.queues_prefix)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.queues_prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.queues_prefix_.Set("", GetArena());
  }
  return released;
}
inline void AMQPHooksOptions::set_allocated_queues_prefix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.queues_prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.queues_prefix_.IsDefault()) {
    _impl_.queues_prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.AMQPHooksOptions.queues_prefix)
}

// uint64 connection_pool_size = 11 [json_name = "connectionPoolSize"];
inline void AMQPHooksOptions::clear_connection_pool_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_pool_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline ::uint64_t AMQPHooksOptions::connection_pool_size() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.connection_pool_size)
  return _internal_connection_pool_size();
}
inline void AMQPHooksOptions::set_connection_pool_size(::uint64_t value) {
  _internal_set_connection_pool_size(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.connection_pool_size)
}
inline ::uint64_t AMQPHooksOptions::_internal_connection_pool_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.connection_pool_size_;
}
inline void AMQPHooksOptions::_internal_set_connection_pool_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.connection_pool_size_ = value;
}

// uint64 channel_pool_size = 12 [json_name = "channelPoolSize"];
inline void AMQPHooksOptions::clear_channel_pool_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_pool_size_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::uint64_t AMQPHooksOptions::channel_pool_size() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.channel_pool_size)
  return _internal_channel_pool_size();
}
inline void AMQPHooksOptions::set_channel_pool_size(::uint64_t value) {
  _internal_set_channel_pool_size(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.channel_pool_size)
}
inline ::uint64_t AMQPHooksOptions::_internal_channel_pool_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_pool_size_;
}
inline void AMQPHooksOptions::_internal_set_channel_pool_size(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_pool_size_ = value;
}

// optional uint64 idle_connection_timeout = 13 [json_name = "idleConnectionTimeout"];
inline bool AMQPHooksOptions::has_idle_connection_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void AMQPHooksOptions::clear_idle_connection_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idle_connection_timeout_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint64_t AMQPHooksOptions::idle_connection_timeout() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.idle_connection_timeout)
  return _internal_idle_connection_timeout();
}
inline void AMQPHooksOptions::set_idle_connection_timeout(::uint64_t value) {
  _internal_set_idle_connection_timeout(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.idle_connection_timeout)
}
inline ::uint64_t AMQPHooksOptions::_internal_idle_connection_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.idle_connection_timeout_;
}
inline void AMQPHooksOptions::_internal_set_idle_connection_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idle_connection_timeout_ = value;
}

// optional uint64 idle_channels_timeout = 14 [json_name = "idleChannelsTimeout"];
inline bool AMQPHooksOptions::has_idle_channels_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline void AMQPHooksOptions::clear_idle_channels_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idle_channels_timeout_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::uint64_t AMQPHooksOptions::idle_channels_timeout() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.idle_channels_timeout)
  return _internal_idle_channels_timeout();
}
inline void AMQPHooksOptions::set_idle_channels_timeout(::uint64_t value) {
  _internal_set_idle_channels_timeout(value);
  _impl_._has_bits_[0] |= 0x00004000u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.idle_channels_timeout)
}
inline ::uint64_t AMQPHooksOptions::_internal_idle_channels_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.idle_channels_timeout_;
}
inline void AMQPHooksOptions::_internal_set_idle_channels_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idle_channels_timeout_ = value;
}

// bool auto_delete = 15 [json_name = "autoDelete"];
inline void AMQPHooksOptions::clear_auto_delete() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_delete_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool AMQPHooksOptions::auto_delete() const {
  // @@protoc_insertion_point(field_get:uploader.v1.AMQPHooksOptions.auto_delete)
  return _internal_auto_delete();
}
inline void AMQPHooksOptions::set_auto_delete(bool value) {
  _internal_set_auto_delete(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:uploader.v1.AMQPHooksOptions.auto_delete)
}
inline bool AMQPHooksOptions::_internal_auto_delete() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.auto_delete_;
}
inline void AMQPHooksOptions::_internal_set_auto_delete(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.auto_delete_ = value;
}

// -------------------------------------------------------------------

// KafkaHookOptions

// optional string urls = 1 [json_name = "urls"];
inline bool KafkaHookOptions::has_urls() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urls_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& KafkaHookOptions::urls() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.urls)
  return _internal_urls();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KafkaHookOptions::set_urls(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.urls_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.urls)
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::mutable_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_urls();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.urls)
  return _s;
}
inline const ::std::string& KafkaHookOptions::_internal_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urls_.Get();
}
inline void KafkaHookOptions::_internal_set_urls(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.urls_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.urls_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KafkaHookOptions::release_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.urls)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.urls_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.urls_.Set("", GetArena());
  }
  return released;
}
inline void KafkaHookOptions::set_allocated_urls(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.urls_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.urls_.IsDefault()) {
    _impl_.urls_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.urls)
}

// optional string client_id = 2 [json_name = "clientId"];
inline bool KafkaHookOptions::has_client_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_client_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.client_id_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& KafkaHookOptions::client_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.client_id)
  return _internal_client_id();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KafkaHookOptions::set_client_id(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.client_id)
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::mutable_client_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.client_id)
  return _s;
}
inline const ::std::string& KafkaHookOptions::_internal_client_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.client_id_.Get();
}
inline void KafkaHookOptions::_internal_set_client_id(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.client_id_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_client_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.client_id_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KafkaHookOptions::release_client_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.client_id)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.client_id_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.client_id_.Set("", GetArena());
  }
  return released;
}
inline void KafkaHookOptions::set_allocated_client_id(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.client_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.client_id_.IsDefault()) {
    _impl_.client_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.client_id)
}

// optional string topic = 3 [json_name = "topic"];
inline bool KafkaHookOptions::has_topic() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.topic_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& KafkaHookOptions::topic() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.topic)
  return _internal_topic();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KafkaHookOptions::set_topic(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topic_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.topic)
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::mutable_topic()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_topic();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.topic)
  return _s;
}
inline const ::std::string& KafkaHookOptions::_internal_topic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.topic_.Get();
}
inline void KafkaHookOptions::_internal_set_topic(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.topic_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.topic_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KafkaHookOptions::release_topic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.topic)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.topic_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.topic_.Set("", GetArena());
  }
  return released;
}
inline void KafkaHookOptions::set_allocated_topic(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.topic_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.topic_.IsDefault()) {
    _impl_.topic_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.topic)
}

// optional string prefix = 4 [json_name = "prefix"];
inline bool KafkaHookOptions::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& KafkaHookOptions::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KafkaHookOptions::set_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.prefix)
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::mutable_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.prefix)
  return _s;
}
inline const ::std::string& KafkaHookOptions::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void KafkaHookOptions::_internal_set_prefix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.prefix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.prefix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KafkaHookOptions::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.prefix)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prefix_.Set("", GetArena());
  }
  return released;
}
inline void KafkaHookOptions::set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.prefix)
}

// optional string required_acks = 5 [json_name = "requiredAcks"];
inline bool KafkaHookOptions::has_required_acks() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_required_acks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.required_acks_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& KafkaHookOptions::required_acks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.required_acks)
  return _internal_required_acks();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KafkaHookOptions::set_required_acks(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.required_acks_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.required_acks)
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::mutable_required_acks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_required_acks();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.required_acks)
  return _s;
}
inline const ::std::string& KafkaHookOptions::_internal_required_acks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.required_acks_.Get();
}
inline void KafkaHookOptions::_internal_set_required_acks(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.required_acks_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_required_acks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.required_acks_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KafkaHookOptions::release_required_acks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.required_acks)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.required_acks_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.required_acks_.Set("", GetArena());
  }
  return released;
}
inline void KafkaHookOptions::set_allocated_required_acks(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.required_acks_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.required_acks_.IsDefault()) {
    _impl_.required_acks_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.required_acks)
}

// optional string compression = 6 [json_name = "compression"];
inline bool KafkaHookOptions::has_compression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_compression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compression_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& KafkaHookOptions::compression() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.compression)
  return _internal_compression();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void KafkaHookOptions::set_compression(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.compression_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.compression)
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::mutable_compression()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_compression();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.compression)
  return _s;
}
inline const ::std::string& KafkaHookOptions::_internal_compression() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compression_.Get();
}
inline void KafkaHookOptions::_internal_set_compression(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.compression_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_compression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000020u;
  return _impl_.compression_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE KafkaHookOptions::release_compression() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.compression)
  if ((_impl_._has_bits_[0] & 0x00000020u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000020u;
  auto* released = _impl_.compression_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.compression_.Set("", GetArena());
  }
  return released;
}
inline void KafkaHookOptions::set_allocated_compression(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.compression_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.compression_.IsDefault()) {
    _impl_.compression_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.compression)
}

// optional uint64 idle_timeout = 7 [json_name = "idleTimeout"];
inline bool KafkaHookOptions::has_idle_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_idle_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idle_timeout_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t KafkaHookOptions::idle_timeout() const {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.idle_timeout)
  return _internal_idle_timeout();
}
inline void KafkaHookOptions::set_idle_timeout(::uint64_t value) {
  _internal_set_idle_timeout(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.idle_timeout)
}
inline ::uint64_t KafkaHookOptions::_internal_idle_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.idle_timeout_;
}
inline void KafkaHookOptions::_internal_set_idle_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.idle_timeout_ = value;
}

// optional uint64 send_timeout = 8 [json_name = "sendTimeout"];
inline bool KafkaHookOptions::has_send_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline void KafkaHookOptions::clear_send_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.send_timeout_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint64_t KafkaHookOptions::send_timeout() const {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.send_timeout)
  return _internal_send_timeout();
}
inline void KafkaHookOptions::set_send_timeout(::uint64_t value) {
  _internal_set_send_timeout(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:uploader.v1.KafkaHookOptions.send_timeout)
}
inline ::uint64_t KafkaHookOptions::_internal_send_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.send_timeout_;
}
inline void KafkaHookOptions::_internal_set_send_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.send_timeout_ = value;
}

// optional .uploader.v1.ExtraKafkaOptions extra_kafka_opts = 9 [json_name = "extraKafkaOpts"];
inline bool KafkaHookOptions::has_extra_kafka_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.extra_kafka_opts_ != nullptr);
  return value;
}
inline void KafkaHookOptions::clear_extra_kafka_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.extra_kafka_opts_ != nullptr) _impl_.extra_kafka_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::uploader::v1::ExtraKafkaOptions& KafkaHookOptions::_internal_extra_kafka_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::ExtraKafkaOptions* p = _impl_.extra_kafka_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::ExtraKafkaOptions&>(::uploader::v1::_ExtraKafkaOptions_default_instance_);
}
inline const ::uploader::v1::ExtraKafkaOptions& KafkaHookOptions::extra_kafka_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.KafkaHookOptions.extra_kafka_opts)
  return _internal_extra_kafka_opts();
}
inline void KafkaHookOptions::unsafe_arena_set_allocated_extra_kafka_opts(
    ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_kafka_opts_);
  }
  _impl_.extra_kafka_opts_ = reinterpret_cast<::uploader::v1::ExtraKafkaOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.KafkaHookOptions.extra_kafka_opts)
}
inline ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE KafkaHookOptions::release_extra_kafka_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::uploader::v1::ExtraKafkaOptions* released = _impl_.extra_kafka_opts_;
  _impl_.extra_kafka_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE KafkaHookOptions::unsafe_arena_release_extra_kafka_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.KafkaHookOptions.extra_kafka_opts)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::uploader::v1::ExtraKafkaOptions* temp = _impl_.extra_kafka_opts_;
  _impl_.extra_kafka_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NONNULL KafkaHookOptions::_internal_mutable_extra_kafka_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.extra_kafka_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::ExtraKafkaOptions>(GetArena());
    _impl_.extra_kafka_opts_ = reinterpret_cast<::uploader::v1::ExtraKafkaOptions*>(p);
  }
  return _impl_.extra_kafka_opts_;
}
inline ::uploader::v1::ExtraKafkaOptions* PROTOBUF_NONNULL KafkaHookOptions::mutable_extra_kafka_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::uploader::v1::ExtraKafkaOptions* _msg = _internal_mutable_extra_kafka_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.KafkaHookOptions.extra_kafka_opts)
  return _msg;
}
inline void KafkaHookOptions::set_allocated_extra_kafka_opts(::uploader::v1::ExtraKafkaOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.extra_kafka_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.extra_kafka_opts_ = reinterpret_cast<::uploader::v1::ExtraKafkaOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.KafkaHookOptions.extra_kafka_opts)
}

// -------------------------------------------------------------------

// NatsHookOptions

// repeated string urls = 1 [json_name = "urls"];
inline int NatsHookOptions::_internal_urls_size() const {
  return _internal_urls().size();
}
inline int NatsHookOptions::urls_size() const {
  return _internal_urls_size();
}
inline void NatsHookOptions::clear_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.urls_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::add_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:uploader.v1.NatsHookOptions.urls)
  return _s;
}
inline const ::std::string& NatsHookOptions::urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.urls)
  return _internal_urls().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::mutable_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:uploader.v1.NatsHookOptions.urls)
  return _internal_mutable_urls()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void NatsHookOptions::set_urls(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_urls()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.urls)
}
template <typename Arg_, typename... Args_>
inline void NatsHookOptions::add_urls(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_urls(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:uploader.v1.NatsHookOptions.urls)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& NatsHookOptions::urls()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:uploader.v1.NatsHookOptions.urls)
  return _internal_urls();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
NatsHookOptions::mutable_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:uploader.v1.NatsHookOptions.urls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_urls();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
NatsHookOptions::_internal_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.urls_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
NatsHookOptions::_internal_mutable_urls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.urls_;
}

// optional string subject = 2 [json_name = "subject"];
inline bool NatsHookOptions::has_subject() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NatsHookOptions::clear_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subject_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& NatsHookOptions::subject() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.subject)
  return _internal_subject();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NatsHookOptions::set_subject(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.subject)
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::mutable_subject()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_subject();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NatsHookOptions.subject)
  return _s;
}
inline const ::std::string& NatsHookOptions::_internal_subject() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subject_.Get();
}
inline void NatsHookOptions::_internal_set_subject(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.subject_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::_internal_mutable_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.subject_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NatsHookOptions::release_subject() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NatsHookOptions.subject)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.subject_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.subject_.Set("", GetArena());
  }
  return released;
}
inline void NatsHookOptions::set_allocated_subject(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.subject_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.subject_.IsDefault()) {
    _impl_.subject_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NatsHookOptions.subject)
}

// optional string prefix = 3 [json_name = "prefix"];
inline bool NatsHookOptions::has_prefix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NatsHookOptions::clear_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prefix_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& NatsHookOptions::prefix() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.prefix)
  return _internal_prefix();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NatsHookOptions::set_prefix(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.prefix_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.prefix)
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::mutable_prefix()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_prefix();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NatsHookOptions.prefix)
  return _s;
}
inline const ::std::string& NatsHookOptions::_internal_prefix() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prefix_.Get();
}
inline void NatsHookOptions::_internal_set_prefix(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.prefix_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::_internal_mutable_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.prefix_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NatsHookOptions::release_prefix() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NatsHookOptions.prefix)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.prefix_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.prefix_.Set("", GetArena());
  }
  return released;
}
inline void NatsHookOptions::set_allocated_prefix(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.prefix_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.prefix_.IsDefault()) {
    _impl_.prefix_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NatsHookOptions.prefix)
}

// bool wait_for_replies = 4 [json_name = "waitForReplies"];
inline void NatsHookOptions::clear_wait_for_replies() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_for_replies_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool NatsHookOptions::wait_for_replies() const {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.wait_for_replies)
  return _internal_wait_for_replies();
}
inline void NatsHookOptions::set_wait_for_replies(bool value) {
  _internal_set_wait_for_replies(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.wait_for_replies)
}
inline bool NatsHookOptions::_internal_wait_for_replies() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wait_for_replies_;
}
inline void NatsHookOptions::_internal_set_wait_for_replies(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wait_for_replies_ = value;
}

// optional string username = 5 [json_name = "username"];
inline bool NatsHookOptions::has_username() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void NatsHookOptions::clear_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.username_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& NatsHookOptions::username() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.username)
  return _internal_username();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NatsHookOptions::set_username(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.username_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.username)
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::mutable_username()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NatsHookOptions.username)
  return _s;
}
inline const ::std::string& NatsHookOptions::_internal_username() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.username_.Get();
}
inline void NatsHookOptions::_internal_set_username(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.username_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::_internal_mutable_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.username_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NatsHookOptions::release_username() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NatsHookOptions.username)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.username_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.username_.Set("", GetArena());
  }
  return released;
}
inline void NatsHookOptions::set_allocated_username(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.username_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NatsHookOptions.username)
}

// optional string password = 6 [json_name = "password"];
inline bool NatsHookOptions::has_password() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void NatsHookOptions::clear_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.password_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& NatsHookOptions::password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.password)
  return _internal_password();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NatsHookOptions::set_password(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.password_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.password)
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::mutable_password()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NatsHookOptions.password)
  return _s;
}
inline const ::std::string& NatsHookOptions::_internal_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.password_.Get();
}
inline void NatsHookOptions::_internal_set_password(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.password_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::_internal_mutable_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000008u;
  return _impl_.password_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NatsHookOptions::release_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NatsHookOptions.password)
  if ((_impl_._has_bits_[0] & 0x00000008u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000008u;
  auto* released = _impl_.password_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.password_.Set("", GetArena());
  }
  return released;
}
inline void NatsHookOptions::set_allocated_password(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.password_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.password_.IsDefault()) {
    _impl_.password_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NatsHookOptions.password)
}

// optional string token = 7 [json_name = "token"];
inline bool NatsHookOptions::has_token() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void NatsHookOptions::clear_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.token_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& NatsHookOptions::token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NatsHookOptions.token)
  return _internal_token();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NatsHookOptions::set_token(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NatsHookOptions.token)
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::mutable_token()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NatsHookOptions.token)
  return _s;
}
inline const ::std::string& NatsHookOptions::_internal_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.token_.Get();
}
inline void NatsHookOptions::_internal_set_token(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.token_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NatsHookOptions::_internal_mutable_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000010u;
  return _impl_.token_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NatsHookOptions::release_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NatsHookOptions.token)
  if ((_impl_._has_bits_[0] & 0x00000010u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000010u;
  auto* released = _impl_.token_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.token_.Set("", GetArena());
  }
  return released;
}
inline void NatsHookOptions::set_allocated_token(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.token_.IsDefault()) {
    _impl_.token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NatsHookOptions.token)
}

// -------------------------------------------------------------------

// NotificationsOptions

// .uploader.v1.Format hooks_format = 1 [json_name = "hooksFormat"];
inline void NotificationsOptions::clear_hooks_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::uploader::v1::Format NotificationsOptions::hooks_format() const {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.hooks_format)
  return _internal_hooks_format();
}
inline void NotificationsOptions::set_hooks_format(::uploader::v1::Format value) {
  _internal_set_hooks_format(value);
  _impl_._has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.hooks_format)
}
inline ::uploader::v1::Format NotificationsOptions::_internal_hooks_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::uploader::v1::Format>(_impl_.hooks_format_);
}
inline void NotificationsOptions::_internal_set_hooks_format(::uploader::v1::Format value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_format_ = value;
}

// repeated .uploader.v1.Hook hooks = 2 [json_name = "hooks"];
inline int NotificationsOptions::_internal_hooks_size() const {
  return _internal_hooks().size();
}
inline int NotificationsOptions::hooks_size() const {
  return _internal_hooks_size();
}
inline void NotificationsOptions::clear_hooks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_.Clear();
}
inline ::uploader::v1::Hook NotificationsOptions::hooks(int index) const {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.hooks)
  return static_cast<::uploader::v1::Hook>(_internal_hooks().Get(index));
}
inline void NotificationsOptions::set_hooks(int index, ::uploader::v1::Hook value) {
  _internal_mutable_hooks()->Set(index, value);
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.hooks)
}
inline void NotificationsOptions::add_hooks(::uploader::v1::Hook value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_hooks()->Add(value);
  // @@protoc_insertion_point(field_add:uploader.v1.NotificationsOptions.hooks)
}
inline const ::google::protobuf::RepeatedField<int>& NotificationsOptions::hooks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:uploader.v1.NotificationsOptions.hooks)
  return _internal_hooks();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL NotificationsOptions::mutable_hooks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:uploader.v1.NotificationsOptions.hooks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hooks();
}
inline const ::google::protobuf::RepeatedField<int>& NotificationsOptions::_internal_hooks()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hooks_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
NotificationsOptions::_internal_mutable_hooks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hooks_;
}

// bool behind_proxy = 3 [json_name = "behindProxy"];
inline void NotificationsOptions::clear_behind_proxy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.behind_proxy_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool NotificationsOptions::behind_proxy() const {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.behind_proxy)
  return _internal_behind_proxy();
}
inline void NotificationsOptions::set_behind_proxy(bool value) {
  _internal_set_behind_proxy(value);
  _impl_._has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.behind_proxy)
}
inline bool NotificationsOptions::_internal_behind_proxy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.behind_proxy_;
}
inline void NotificationsOptions::_internal_set_behind_proxy(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.behind_proxy_ = value;
}

// repeated string hooks_http_urls = 4 [json_name = "hooksHttpUrls"];
inline int NotificationsOptions::_internal_hooks_http_urls_size() const {
  return _internal_hooks_http_urls().size();
}
inline int NotificationsOptions::hooks_http_urls_size() const {
  return _internal_hooks_http_urls_size();
}
inline void NotificationsOptions::clear_hooks_http_urls() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_http_urls_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::add_hooks_http_urls()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_hooks_http_urls()->Add();
  // @@protoc_insertion_point(field_add_mutable:uploader.v1.NotificationsOptions.hooks_http_urls)
  return _s;
}
inline const ::std::string& NotificationsOptions::hooks_http_urls(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.hooks_http_urls)
  return _internal_hooks_http_urls().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::mutable_hooks_http_urls(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.hooks_http_urls)
  return _internal_mutable_hooks_http_urls()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void NotificationsOptions::set_hooks_http_urls(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_hooks_http_urls()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.hooks_http_urls)
}
template <typename Arg_, typename... Args_>
inline void NotificationsOptions::add_hooks_http_urls(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_hooks_http_urls(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:uploader.v1.NotificationsOptions.hooks_http_urls)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& NotificationsOptions::hooks_http_urls()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:uploader.v1.NotificationsOptions.hooks_http_urls)
  return _internal_hooks_http_urls();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
NotificationsOptions::mutable_hooks_http_urls() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:uploader.v1.NotificationsOptions.hooks_http_urls)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hooks_http_urls();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
NotificationsOptions::_internal_hooks_http_urls() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hooks_http_urls_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
NotificationsOptions::_internal_mutable_hooks_http_urls() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hooks_http_urls_;
}

// optional uint64 http_hook_timeout = 5 [json_name = "httpHookTimeout"];
inline bool NotificationsOptions::has_http_hook_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline void NotificationsOptions::clear_http_hook_timeout() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_hook_timeout_ = ::uint64_t{0u};
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint64_t NotificationsOptions::http_hook_timeout() const {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.http_hook_timeout)
  return _internal_http_hook_timeout();
}
inline void NotificationsOptions::set_http_hook_timeout(::uint64_t value) {
  _internal_set_http_hook_timeout(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.http_hook_timeout)
}
inline ::uint64_t NotificationsOptions::_internal_http_hook_timeout() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.http_hook_timeout_;
}
inline void NotificationsOptions::_internal_set_http_hook_timeout(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.http_hook_timeout_ = value;
}

// repeated string hooks_http_proxy_headers = 6 [json_name = "hooksHttpProxyHeaders"];
inline int NotificationsOptions::_internal_hooks_http_proxy_headers_size() const {
  return _internal_hooks_http_proxy_headers().size();
}
inline int NotificationsOptions::hooks_http_proxy_headers_size() const {
  return _internal_hooks_http_proxy_headers_size();
}
inline void NotificationsOptions::clear_hooks_http_proxy_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_http_proxy_headers_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::add_hooks_http_proxy_headers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_hooks_http_proxy_headers()->Add();
  // @@protoc_insertion_point(field_add_mutable:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
  return _s;
}
inline const ::std::string& NotificationsOptions::hooks_http_proxy_headers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
  return _internal_hooks_http_proxy_headers().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::mutable_hooks_http_proxy_headers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
  return _internal_mutable_hooks_http_proxy_headers()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void NotificationsOptions::set_hooks_http_proxy_headers(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_hooks_http_proxy_headers()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
}
template <typename Arg_, typename... Args_>
inline void NotificationsOptions::add_hooks_http_proxy_headers(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_hooks_http_proxy_headers(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& NotificationsOptions::hooks_http_proxy_headers()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
  return _internal_hooks_http_proxy_headers();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
NotificationsOptions::mutable_hooks_http_proxy_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:uploader.v1.NotificationsOptions.hooks_http_proxy_headers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hooks_http_proxy_headers();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
NotificationsOptions::_internal_hooks_http_proxy_headers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hooks_http_proxy_headers_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
NotificationsOptions::_internal_mutable_hooks_http_proxy_headers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hooks_http_proxy_headers_;
}

// optional string hooks_dir = 7 [json_name = "hooksDir"];
inline bool NotificationsOptions::has_hooks_dir() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void NotificationsOptions::clear_hooks_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_dir_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& NotificationsOptions::hooks_dir() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.hooks_dir)
  return _internal_hooks_dir();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NotificationsOptions::set_hooks_dir(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hooks_dir_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.hooks_dir)
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::mutable_hooks_dir()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hooks_dir();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.hooks_dir)
  return _s;
}
inline const ::std::string& NotificationsOptions::_internal_hooks_dir() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hooks_dir_.Get();
}
inline void NotificationsOptions::_internal_set_hooks_dir(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.hooks_dir_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::_internal_mutable_hooks_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.hooks_dir_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NotificationsOptions::release_hooks_dir() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NotificationsOptions.hooks_dir)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.hooks_dir_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hooks_dir_.Set("", GetArena());
  }
  return released;
}
inline void NotificationsOptions::set_allocated_hooks_dir(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.hooks_dir_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hooks_dir_.IsDefault()) {
    _impl_.hooks_dir_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NotificationsOptions.hooks_dir)
}

// optional string hooks_file = 8 [json_name = "hooksFile"];
inline bool NotificationsOptions::has_hooks_file() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void NotificationsOptions::clear_hooks_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hooks_file_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& NotificationsOptions::hooks_file() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.hooks_file)
  return _internal_hooks_file();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void NotificationsOptions::set_hooks_file(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hooks_file_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.NotificationsOptions.hooks_file)
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::mutable_hooks_file()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_hooks_file();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.hooks_file)
  return _s;
}
inline const ::std::string& NotificationsOptions::_internal_hooks_file() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hooks_file_.Get();
}
inline void NotificationsOptions::_internal_set_hooks_file(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.hooks_file_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL NotificationsOptions::_internal_mutable_hooks_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.hooks_file_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE NotificationsOptions::release_hooks_file() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NotificationsOptions.hooks_file)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.hooks_file_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.hooks_file_.Set("", GetArena());
  }
  return released;
}
inline void NotificationsOptions::set_allocated_hooks_file(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.hooks_file_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hooks_file_.IsDefault()) {
    _impl_.hooks_file_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NotificationsOptions.hooks_file)
}

// .uploader.v1.AMQPHooksOptions amqp_hook_opts = 9 [json_name = "amqpHookOpts"];
inline bool NotificationsOptions::has_amqp_hook_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.amqp_hook_opts_ != nullptr);
  return value;
}
inline void NotificationsOptions::clear_amqp_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.amqp_hook_opts_ != nullptr) _impl_.amqp_hook_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::uploader::v1::AMQPHooksOptions& NotificationsOptions::_internal_amqp_hook_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::AMQPHooksOptions* p = _impl_.amqp_hook_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::AMQPHooksOptions&>(::uploader::v1::_AMQPHooksOptions_default_instance_);
}
inline const ::uploader::v1::AMQPHooksOptions& NotificationsOptions::amqp_hook_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.amqp_hook_opts)
  return _internal_amqp_hook_opts();
}
inline void NotificationsOptions::unsafe_arena_set_allocated_amqp_hook_opts(
    ::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amqp_hook_opts_);
  }
  _impl_.amqp_hook_opts_ = reinterpret_cast<::uploader::v1::AMQPHooksOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.NotificationsOptions.amqp_hook_opts)
}
inline ::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE NotificationsOptions::release_amqp_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::uploader::v1::AMQPHooksOptions* released = _impl_.amqp_hook_opts_;
  _impl_.amqp_hook_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE NotificationsOptions::unsafe_arena_release_amqp_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NotificationsOptions.amqp_hook_opts)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::uploader::v1::AMQPHooksOptions* temp = _impl_.amqp_hook_opts_;
  _impl_.amqp_hook_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::AMQPHooksOptions* PROTOBUF_NONNULL NotificationsOptions::_internal_mutable_amqp_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.amqp_hook_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::AMQPHooksOptions>(GetArena());
    _impl_.amqp_hook_opts_ = reinterpret_cast<::uploader::v1::AMQPHooksOptions*>(p);
  }
  return _impl_.amqp_hook_opts_;
}
inline ::uploader::v1::AMQPHooksOptions* PROTOBUF_NONNULL NotificationsOptions::mutable_amqp_hook_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::uploader::v1::AMQPHooksOptions* _msg = _internal_mutable_amqp_hook_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.amqp_hook_opts)
  return _msg;
}
inline void NotificationsOptions::set_allocated_amqp_hook_opts(::uploader::v1::AMQPHooksOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.amqp_hook_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.amqp_hook_opts_ = reinterpret_cast<::uploader::v1::AMQPHooksOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NotificationsOptions.amqp_hook_opts)
}

// .uploader.v1.KafkaHookOptions kafka_hook_opts = 10 [json_name = "kafkaHookOpts"];
inline bool NotificationsOptions::has_kafka_hook_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kafka_hook_opts_ != nullptr);
  return value;
}
inline void NotificationsOptions::clear_kafka_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kafka_hook_opts_ != nullptr) _impl_.kafka_hook_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::uploader::v1::KafkaHookOptions& NotificationsOptions::_internal_kafka_hook_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::KafkaHookOptions* p = _impl_.kafka_hook_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::KafkaHookOptions&>(::uploader::v1::_KafkaHookOptions_default_instance_);
}
inline const ::uploader::v1::KafkaHookOptions& NotificationsOptions::kafka_hook_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.kafka_hook_opts)
  return _internal_kafka_hook_opts();
}
inline void NotificationsOptions::unsafe_arena_set_allocated_kafka_hook_opts(
    ::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kafka_hook_opts_);
  }
  _impl_.kafka_hook_opts_ = reinterpret_cast<::uploader::v1::KafkaHookOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.NotificationsOptions.kafka_hook_opts)
}
inline ::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE NotificationsOptions::release_kafka_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::uploader::v1::KafkaHookOptions* released = _impl_.kafka_hook_opts_;
  _impl_.kafka_hook_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE NotificationsOptions::unsafe_arena_release_kafka_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NotificationsOptions.kafka_hook_opts)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::uploader::v1::KafkaHookOptions* temp = _impl_.kafka_hook_opts_;
  _impl_.kafka_hook_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::KafkaHookOptions* PROTOBUF_NONNULL NotificationsOptions::_internal_mutable_kafka_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.kafka_hook_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::KafkaHookOptions>(GetArena());
    _impl_.kafka_hook_opts_ = reinterpret_cast<::uploader::v1::KafkaHookOptions*>(p);
  }
  return _impl_.kafka_hook_opts_;
}
inline ::uploader::v1::KafkaHookOptions* PROTOBUF_NONNULL NotificationsOptions::mutable_kafka_hook_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::uploader::v1::KafkaHookOptions* _msg = _internal_mutable_kafka_hook_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.kafka_hook_opts)
  return _msg;
}
inline void NotificationsOptions::set_allocated_kafka_hook_opts(::uploader::v1::KafkaHookOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kafka_hook_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.kafka_hook_opts_ = reinterpret_cast<::uploader::v1::KafkaHookOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NotificationsOptions.kafka_hook_opts)
}

// .uploader.v1.NatsHookOptions nats_hook_opts = 11 [json_name = "natsHookOpts"];
inline bool NotificationsOptions::has_nats_hook_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.nats_hook_opts_ != nullptr);
  return value;
}
inline void NotificationsOptions::clear_nats_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nats_hook_opts_ != nullptr) _impl_.nats_hook_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::uploader::v1::NatsHookOptions& NotificationsOptions::_internal_nats_hook_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::NatsHookOptions* p = _impl_.nats_hook_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::NatsHookOptions&>(::uploader::v1::_NatsHookOptions_default_instance_);
}
inline const ::uploader::v1::NatsHookOptions& NotificationsOptions::nats_hook_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.NotificationsOptions.nats_hook_opts)
  return _internal_nats_hook_opts();
}
inline void NotificationsOptions::unsafe_arena_set_allocated_nats_hook_opts(
    ::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nats_hook_opts_);
  }
  _impl_.nats_hook_opts_ = reinterpret_cast<::uploader::v1::NatsHookOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.NotificationsOptions.nats_hook_opts)
}
inline ::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE NotificationsOptions::release_nats_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::uploader::v1::NatsHookOptions* released = _impl_.nats_hook_opts_;
  _impl_.nats_hook_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE NotificationsOptions::unsafe_arena_release_nats_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.NotificationsOptions.nats_hook_opts)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::uploader::v1::NatsHookOptions* temp = _impl_.nats_hook_opts_;
  _impl_.nats_hook_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::NatsHookOptions* PROTOBUF_NONNULL NotificationsOptions::_internal_mutable_nats_hook_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.nats_hook_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::NatsHookOptions>(GetArena());
    _impl_.nats_hook_opts_ = reinterpret_cast<::uploader::v1::NatsHookOptions*>(p);
  }
  return _impl_.nats_hook_opts_;
}
inline ::uploader::v1::NatsHookOptions* PROTOBUF_NONNULL NotificationsOptions::mutable_nats_hook_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::uploader::v1::NatsHookOptions* _msg = _internal_mutable_nats_hook_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.NotificationsOptions.nats_hook_opts)
  return _msg;
}
inline void NotificationsOptions::set_allocated_nats_hook_opts(::uploader::v1::NatsHookOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.nats_hook_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.nats_hook_opts_ = reinterpret_cast<::uploader::v1::NatsHookOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.NotificationsOptions.nats_hook_opts)
}

// -------------------------------------------------------------------

// SentryOptions

// optional string dsn = 1 [json_name = "dsn"];
inline bool SentryOptions::has_dsn() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SentryOptions::clear_dsn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dsn_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& SentryOptions::dsn() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.SentryOptions.dsn)
  return _internal_dsn();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void SentryOptions::set_dsn(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dsn_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.SentryOptions.dsn)
}
inline ::std::string* PROTOBUF_NONNULL SentryOptions::mutable_dsn()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_dsn();
  // @@protoc_insertion_point(field_mutable:uploader.v1.SentryOptions.dsn)
  return _s;
}
inline const ::std::string& SentryOptions::_internal_dsn() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dsn_.Get();
}
inline void SentryOptions::_internal_set_dsn(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dsn_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL SentryOptions::_internal_mutable_dsn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.dsn_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE SentryOptions::release_dsn() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.SentryOptions.dsn)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.dsn_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.dsn_.Set("", GetArena());
  }
  return released;
}
inline void SentryOptions::set_allocated_dsn(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.dsn_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.dsn_.IsDefault()) {
    _impl_.dsn_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.SentryOptions.dsn)
}

// float sample_rate = 2 [json_name = "sampleRate"];
inline void SentryOptions::clear_sample_rate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SentryOptions::sample_rate() const {
  // @@protoc_insertion_point(field_get:uploader.v1.SentryOptions.sample_rate)
  return _internal_sample_rate();
}
inline void SentryOptions::set_sample_rate(float value) {
  _internal_set_sample_rate(value);
  _impl_._has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_set:uploader.v1.SentryOptions.sample_rate)
}
inline float SentryOptions::_internal_sample_rate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_rate_;
}
inline void SentryOptions::_internal_set_sample_rate(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_rate_ = value;
}

// -------------------------------------------------------------------

// RustusConf

// string host = 1 [json_name = "host"];
inline void RustusConf::clear_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.host_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& RustusConf::host() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.host)
  return _internal_host();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RustusConf::set_host(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.host)
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::mutable_host()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.host)
  return _s;
}
inline const ::std::string& RustusConf::_internal_host() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.host_.Get();
}
inline void RustusConf::_internal_set_host(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.host_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::_internal_mutable_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.host_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RustusConf::release_host() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.host)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.host_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.host_.Set("", GetArena());
  }
  return released;
}
inline void RustusConf::set_allocated_host(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.host_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.host_.IsDefault()) {
    _impl_.host_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.host)
}

// uint32 port = 2 [json_name = "port"];
inline void RustusConf::clear_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline ::uint32_t RustusConf::port() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.port)
  return _internal_port();
}
inline void RustusConf::set_port(::uint32_t value) {
  _internal_set_port(value);
  _impl_._has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.port)
}
inline ::uint32_t RustusConf::_internal_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.port_;
}
inline void RustusConf::_internal_set_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.port_ = value;
}

// bool disable_health_access_log = 3 [json_name = "disableHealthAccessLog"];
inline void RustusConf::clear_disable_health_access_log() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_health_access_log_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool RustusConf::disable_health_access_log() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.disable_health_access_log)
  return _internal_disable_health_access_log();
}
inline void RustusConf::set_disable_health_access_log(bool value) {
  _internal_set_disable_health_access_log(value);
  _impl_._has_bits_[0] |= 0x00000400u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.disable_health_access_log)
}
inline bool RustusConf::_internal_disable_health_access_log() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.disable_health_access_log_;
}
inline void RustusConf::_internal_set_disable_health_access_log(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.disable_health_access_log_ = value;
}

// string url = 4 [json_name = "url"];
inline void RustusConf::clear_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.url_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& RustusConf::url() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.url)
  return _internal_url();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RustusConf::set_url(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.url)
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::mutable_url()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.url)
  return _s;
}
inline const ::std::string& RustusConf::_internal_url() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.url_.Get();
}
inline void RustusConf::_internal_set_url(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.url_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::_internal_mutable_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.url_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RustusConf::release_url() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.url)
  if ((_impl_._has_bits_[0] & 0x00000002u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* released = _impl_.url_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.url_.Set("", GetArena());
  }
  return released;
}
inline void RustusConf::set_allocated_url(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.url_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.url_.IsDefault()) {
    _impl_.url_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.url)
}

// repeated string cors = 5 [json_name = "cors"];
inline int RustusConf::_internal_cors_size() const {
  return _internal_cors().size();
}
inline int RustusConf::cors_size() const {
  return _internal_cors_size();
}
inline void RustusConf::clear_cors() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cors_.Clear();
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::add_cors()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::std::string* _s = _internal_mutable_cors()->Add();
  // @@protoc_insertion_point(field_add_mutable:uploader.v1.RustusConf.cors)
  return _s;
}
inline const ::std::string& RustusConf::cors(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.cors)
  return _internal_cors().Get(index);
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::mutable_cors(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.cors)
  return _internal_mutable_cors()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void RustusConf::set_cors(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(*_internal_mutable_cors()->Mutable(index), ::std::forward<Arg_>(value),
                        args... );
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.cors)
}
template <typename Arg_, typename... Args_>
inline void RustusConf::add_cors(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_cors(),
                               ::std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:uploader.v1.RustusConf.cors)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>& RustusConf::cors()
    const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:uploader.v1.RustusConf.cors)
  return _internal_cors();
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RustusConf::mutable_cors() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:uploader.v1.RustusConf.cors)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cors();
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RustusConf::_internal_cors() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cors_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>* PROTOBUF_NONNULL
RustusConf::_internal_mutable_cors() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cors_;
}

// uint32 max_body_size = 6 [json_name = "maxBodySize"];
inline void RustusConf::clear_max_body_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_body_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::uint32_t RustusConf::max_body_size() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.max_body_size)
  return _internal_max_body_size();
}
inline void RustusConf::set_max_body_size(::uint32_t value) {
  _internal_set_max_body_size(value);
  _impl_._has_bits_[0] |= 0x00000100u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.max_body_size)
}
inline ::uint32_t RustusConf::_internal_max_body_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_body_size_;
}
inline void RustusConf::_internal_set_max_body_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_body_size_ = value;
}

// string log_level = 7 [json_name = "logLevel"];
inline void RustusConf::clear_log_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.log_level_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& RustusConf::log_level() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.log_level)
  return _internal_log_level();
}
template <typename Arg_, typename... Args_>
PROTOBUF_ALWAYS_INLINE void RustusConf::set_log_level(Arg_&& arg, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.log_level_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.log_level)
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::mutable_log_level()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::std::string* _s = _internal_mutable_log_level();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.log_level)
  return _s;
}
inline const ::std::string& RustusConf::_internal_log_level() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.log_level_.Get();
}
inline void RustusConf::_internal_set_log_level(const ::std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.log_level_.Set(value, GetArena());
}
inline ::std::string* PROTOBUF_NONNULL RustusConf::_internal_mutable_log_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_._has_bits_[0] |= 0x00000004u;
  return _impl_.log_level_.Mutable( GetArena());
}
inline ::std::string* PROTOBUF_NULLABLE RustusConf::release_log_level() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.log_level)
  if ((_impl_._has_bits_[0] & 0x00000004u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000004u;
  auto* released = _impl_.log_level_.Release();
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString()) {
    _impl_.log_level_.Set("", GetArena());
  }
  return released;
}
inline void RustusConf::set_allocated_log_level(::std::string* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.log_level_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.log_level_.IsDefault()) {
    _impl_.log_level_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.log_level)
}

// optional uint32 workers = 8 [json_name = "workers"];
inline bool RustusConf::has_workers() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline void RustusConf::clear_workers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workers_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::uint32_t RustusConf::workers() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.workers)
  return _internal_workers();
}
inline void RustusConf::set_workers(::uint32_t value) {
  _internal_set_workers(value);
  _impl_._has_bits_[0] |= 0x00000200u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.workers)
}
inline ::uint32_t RustusConf::_internal_workers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.workers_;
}
inline void RustusConf::_internal_set_workers(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.workers_ = value;
}

// repeated .uploader.v1.Extensions tus_extensions = 9 [json_name = "tusExtensions"];
inline int RustusConf::_internal_tus_extensions_size() const {
  return _internal_tus_extensions().size();
}
inline int RustusConf::tus_extensions_size() const {
  return _internal_tus_extensions_size();
}
inline void RustusConf::clear_tus_extensions() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tus_extensions_.Clear();
}
inline ::uploader::v1::Extensions RustusConf::tus_extensions(int index) const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.tus_extensions)
  return static_cast<::uploader::v1::Extensions>(_internal_tus_extensions().Get(index));
}
inline void RustusConf::set_tus_extensions(int index, ::uploader::v1::Extensions value) {
  _internal_mutable_tus_extensions()->Set(index, value);
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.tus_extensions)
}
inline void RustusConf::add_tus_extensions(::uploader::v1::Extensions value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_tus_extensions()->Add(value);
  // @@protoc_insertion_point(field_add:uploader.v1.RustusConf.tus_extensions)
}
inline const ::google::protobuf::RepeatedField<int>& RustusConf::tus_extensions() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:uploader.v1.RustusConf.tus_extensions)
  return _internal_tus_extensions();
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL RustusConf::mutable_tus_extensions()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:uploader.v1.RustusConf.tus_extensions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tus_extensions();
}
inline const ::google::protobuf::RepeatedField<int>& RustusConf::_internal_tus_extensions()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tus_extensions_;
}
inline ::google::protobuf::RepeatedField<int>* PROTOBUF_NONNULL
RustusConf::_internal_mutable_tus_extensions() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tus_extensions_;
}

// bool allow_empty = 10 [json_name = "allowEmpty"];
inline void RustusConf::clear_allow_empty() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_empty_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool RustusConf::allow_empty() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.allow_empty)
  return _internal_allow_empty();
}
inline void RustusConf::set_allow_empty(bool value) {
  _internal_set_allow_empty(value);
  _impl_._has_bits_[0] |= 0x00000800u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.allow_empty)
}
inline bool RustusConf::_internal_allow_empty() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.allow_empty_;
}
inline void RustusConf::_internal_set_allow_empty(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.allow_empty_ = value;
}

// bool remove_parts = 11 [json_name = "removeParts"];
inline void RustusConf::clear_remove_parts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remove_parts_ = false;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline bool RustusConf::remove_parts() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.remove_parts)
  return _internal_remove_parts();
}
inline void RustusConf::set_remove_parts(bool value) {
  _internal_set_remove_parts(value);
  _impl_._has_bits_[0] |= 0x00001000u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.remove_parts)
}
inline bool RustusConf::_internal_remove_parts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.remove_parts_;
}
inline void RustusConf::_internal_set_remove_parts(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.remove_parts_ = value;
}

// optional uint32 max_file_size = 12 [json_name = "maxFileSize"];
inline bool RustusConf::has_max_file_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline void RustusConf::clear_max_file_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_file_size_ = 0u;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline ::uint32_t RustusConf::max_file_size() const {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.max_file_size)
  return _internal_max_file_size();
}
inline void RustusConf::set_max_file_size(::uint32_t value) {
  _internal_set_max_file_size(value);
  _impl_._has_bits_[0] |= 0x00002000u;
  // @@protoc_insertion_point(field_set:uploader.v1.RustusConf.max_file_size)
}
inline ::uint32_t RustusConf::_internal_max_file_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_file_size_;
}
inline void RustusConf::_internal_set_max_file_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_file_size_ = value;
}

// .uploader.v1.DataStorageOptions storage_opts = 13 [json_name = "storageOpts"];
inline bool RustusConf::has_storage_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.storage_opts_ != nullptr);
  return value;
}
inline void RustusConf::clear_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.storage_opts_ != nullptr) _impl_.storage_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::uploader::v1::DataStorageOptions& RustusConf::_internal_storage_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::DataStorageOptions* p = _impl_.storage_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::DataStorageOptions&>(::uploader::v1::_DataStorageOptions_default_instance_);
}
inline const ::uploader::v1::DataStorageOptions& RustusConf::storage_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.storage_opts)
  return _internal_storage_opts();
}
inline void RustusConf::unsafe_arena_set_allocated_storage_opts(
    ::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_opts_);
  }
  _impl_.storage_opts_ = reinterpret_cast<::uploader::v1::DataStorageOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.RustusConf.storage_opts)
}
inline ::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE RustusConf::release_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::uploader::v1::DataStorageOptions* released = _impl_.storage_opts_;
  _impl_.storage_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE RustusConf::unsafe_arena_release_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.storage_opts)

  _impl_._has_bits_[0] &= ~0x00000008u;
  ::uploader::v1::DataStorageOptions* temp = _impl_.storage_opts_;
  _impl_.storage_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::DataStorageOptions* PROTOBUF_NONNULL RustusConf::_internal_mutable_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.storage_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::DataStorageOptions>(GetArena());
    _impl_.storage_opts_ = reinterpret_cast<::uploader::v1::DataStorageOptions*>(p);
  }
  return _impl_.storage_opts_;
}
inline ::uploader::v1::DataStorageOptions* PROTOBUF_NONNULL RustusConf::mutable_storage_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000008u;
  ::uploader::v1::DataStorageOptions* _msg = _internal_mutable_storage_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.storage_opts)
  return _msg;
}
inline void RustusConf::set_allocated_storage_opts(::uploader::v1::DataStorageOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.storage_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }

  _impl_.storage_opts_ = reinterpret_cast<::uploader::v1::DataStorageOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.storage_opts)
}

// .uploader.v1.InfoStoreOptions info_storage_opts = 14 [json_name = "infoStorageOpts"];
inline bool RustusConf::has_info_storage_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.info_storage_opts_ != nullptr);
  return value;
}
inline void RustusConf::clear_info_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_storage_opts_ != nullptr) _impl_.info_storage_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::uploader::v1::InfoStoreOptions& RustusConf::_internal_info_storage_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::InfoStoreOptions* p = _impl_.info_storage_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::InfoStoreOptions&>(::uploader::v1::_InfoStoreOptions_default_instance_);
}
inline const ::uploader::v1::InfoStoreOptions& RustusConf::info_storage_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.info_storage_opts)
  return _internal_info_storage_opts();
}
inline void RustusConf::unsafe_arena_set_allocated_info_storage_opts(
    ::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_storage_opts_);
  }
  _impl_.info_storage_opts_ = reinterpret_cast<::uploader::v1::InfoStoreOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.RustusConf.info_storage_opts)
}
inline ::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE RustusConf::release_info_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::uploader::v1::InfoStoreOptions* released = _impl_.info_storage_opts_;
  _impl_.info_storage_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE RustusConf::unsafe_arena_release_info_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.info_storage_opts)

  _impl_._has_bits_[0] &= ~0x00000010u;
  ::uploader::v1::InfoStoreOptions* temp = _impl_.info_storage_opts_;
  _impl_.info_storage_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::InfoStoreOptions* PROTOBUF_NONNULL RustusConf::_internal_mutable_info_storage_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.info_storage_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::InfoStoreOptions>(GetArena());
    _impl_.info_storage_opts_ = reinterpret_cast<::uploader::v1::InfoStoreOptions*>(p);
  }
  return _impl_.info_storage_opts_;
}
inline ::uploader::v1::InfoStoreOptions* PROTOBUF_NONNULL RustusConf::mutable_info_storage_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000010u;
  ::uploader::v1::InfoStoreOptions* _msg = _internal_mutable_info_storage_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.info_storage_opts)
  return _msg;
}
inline void RustusConf::set_allocated_info_storage_opts(::uploader::v1::InfoStoreOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.info_storage_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }

  _impl_.info_storage_opts_ = reinterpret_cast<::uploader::v1::InfoStoreOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.info_storage_opts)
}

// .uploader.v1.NotificationsOptions notification_opts = 15 [json_name = "notificationOpts"];
inline bool RustusConf::has_notification_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.notification_opts_ != nullptr);
  return value;
}
inline void RustusConf::clear_notification_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.notification_opts_ != nullptr) _impl_.notification_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::uploader::v1::NotificationsOptions& RustusConf::_internal_notification_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::NotificationsOptions* p = _impl_.notification_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::NotificationsOptions&>(::uploader::v1::_NotificationsOptions_default_instance_);
}
inline const ::uploader::v1::NotificationsOptions& RustusConf::notification_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.notification_opts)
  return _internal_notification_opts();
}
inline void RustusConf::unsafe_arena_set_allocated_notification_opts(
    ::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.notification_opts_);
  }
  _impl_.notification_opts_ = reinterpret_cast<::uploader::v1::NotificationsOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.RustusConf.notification_opts)
}
inline ::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE RustusConf::release_notification_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::uploader::v1::NotificationsOptions* released = _impl_.notification_opts_;
  _impl_.notification_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE RustusConf::unsafe_arena_release_notification_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.notification_opts)

  _impl_._has_bits_[0] &= ~0x00000020u;
  ::uploader::v1::NotificationsOptions* temp = _impl_.notification_opts_;
  _impl_.notification_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::NotificationsOptions* PROTOBUF_NONNULL RustusConf::_internal_mutable_notification_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.notification_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::NotificationsOptions>(GetArena());
    _impl_.notification_opts_ = reinterpret_cast<::uploader::v1::NotificationsOptions*>(p);
  }
  return _impl_.notification_opts_;
}
inline ::uploader::v1::NotificationsOptions* PROTOBUF_NONNULL RustusConf::mutable_notification_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000020u;
  ::uploader::v1::NotificationsOptions* _msg = _internal_mutable_notification_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.notification_opts)
  return _msg;
}
inline void RustusConf::set_allocated_notification_opts(::uploader::v1::NotificationsOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.notification_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }

  _impl_.notification_opts_ = reinterpret_cast<::uploader::v1::NotificationsOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.notification_opts)
}

// .uploader.v1.SentryOptions sentry_opts = 16 [json_name = "sentryOpts"];
inline bool RustusConf::has_sentry_opts() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.sentry_opts_ != nullptr);
  return value;
}
inline void RustusConf::clear_sentry_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sentry_opts_ != nullptr) _impl_.sentry_opts_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::uploader::v1::SentryOptions& RustusConf::_internal_sentry_opts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::uploader::v1::SentryOptions* p = _impl_.sentry_opts_;
  return p != nullptr ? *p : reinterpret_cast<const ::uploader::v1::SentryOptions&>(::uploader::v1::_SentryOptions_default_instance_);
}
inline const ::uploader::v1::SentryOptions& RustusConf::sentry_opts() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:uploader.v1.RustusConf.sentry_opts)
  return _internal_sentry_opts();
}
inline void RustusConf::unsafe_arena_set_allocated_sentry_opts(
    ::uploader::v1::SentryOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sentry_opts_);
  }
  _impl_.sentry_opts_ = reinterpret_cast<::uploader::v1::SentryOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:uploader.v1.RustusConf.sentry_opts)
}
inline ::uploader::v1::SentryOptions* PROTOBUF_NULLABLE RustusConf::release_sentry_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::uploader::v1::SentryOptions* released = _impl_.sentry_opts_;
  _impl_.sentry_opts_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::uploader::v1::SentryOptions* PROTOBUF_NULLABLE RustusConf::unsafe_arena_release_sentry_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:uploader.v1.RustusConf.sentry_opts)

  _impl_._has_bits_[0] &= ~0x00000040u;
  ::uploader::v1::SentryOptions* temp = _impl_.sentry_opts_;
  _impl_.sentry_opts_ = nullptr;
  return temp;
}
inline ::uploader::v1::SentryOptions* PROTOBUF_NONNULL RustusConf::_internal_mutable_sentry_opts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.sentry_opts_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::uploader::v1::SentryOptions>(GetArena());
    _impl_.sentry_opts_ = reinterpret_cast<::uploader::v1::SentryOptions*>(p);
  }
  return _impl_.sentry_opts_;
}
inline ::uploader::v1::SentryOptions* PROTOBUF_NONNULL RustusConf::mutable_sentry_opts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000040u;
  ::uploader::v1::SentryOptions* _msg = _internal_mutable_sentry_opts();
  // @@protoc_insertion_point(field_mutable:uploader.v1.RustusConf.sentry_opts)
  return _msg;
}
inline void RustusConf::set_allocated_sentry_opts(::uploader::v1::SentryOptions* PROTOBUF_NULLABLE value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.sentry_opts_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = value->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }

  _impl_.sentry_opts_ = reinterpret_cast<::uploader::v1::SentryOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:uploader.v1.RustusConf.sentry_opts)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace uploader


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::uploader::v1::AvailableDataStorages> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::uploader::v1::AvailableDataStorages>() {
  return ::uploader::v1::AvailableDataStorages_descriptor();
}
template <>
struct is_proto_enum<::uploader::v1::AvailableInfoStorages> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::uploader::v1::AvailableInfoStorages>() {
  return ::uploader::v1::AvailableInfoStorages_descriptor();
}
template <>
struct is_proto_enum<::uploader::v1::Format> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::uploader::v1::Format>() {
  return ::uploader::v1::Format_descriptor();
}
template <>
struct is_proto_enum<::uploader::v1::Hook> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::uploader::v1::Hook>() {
  return ::uploader::v1::Hook_descriptor();
}
template <>
struct is_proto_enum<::uploader::v1::Extensions> : std::true_type {};
template <>
inline const EnumDescriptor* PROTOBUF_NONNULL GetEnumDescriptor<::uploader::v1::Extensions>() {
  return ::uploader::v1::Extensions_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // uploader_2fv1_2fconfig_2eproto_2epb_2eh
