// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: uploader/v1/config.proto
// Protobuf C++ Version: 6.31.1

#include "uploader/v1/config.pb.h"

#include <algorithm>
#include <type_traits>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/generated_message_tctable_impl.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::google::protobuf;
namespace _pbi = ::google::protobuf::internal;
namespace _fl = ::google::protobuf::internal::field_layout;
namespace uploader {
namespace v1 {

inline constexpr SentryOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        dsn_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        sample_rate_{0} {}

template <typename>
PROTOBUF_CONSTEXPR SentryOptions::SentryOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(SentryOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct SentryOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SentryOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SentryOptionsDefaultTypeInternal() {}
  union {
    SentryOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SentryOptionsDefaultTypeInternal _SentryOptions_default_instance_;

inline constexpr NatsHookOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        urls_{},
        username_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        password_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        token_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        wait_for_replies_{false},
        subject_or_prefix_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR NatsHookOptions::NatsHookOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NatsHookOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NatsHookOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NatsHookOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NatsHookOptionsDefaultTypeInternal() {}
  union {
    NatsHookOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NatsHookOptionsDefaultTypeInternal _NatsHookOptions_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::MapEntry(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_.base()){}
#else   // PROTOBUF_CUSTOM_VTABLE
    : KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::MapEntry() {
}
#endif  // PROTOBUF_CUSTOM_VTABLE
struct KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUseDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUseDefaultTypeInternal _KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_default_instance_;

inline constexpr InfoStoreOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        info_dir_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        info_db_dsn_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        redis_info_expiration_{::uint64_t{0u}},
        info_storage_{static_cast< ::uploader::v1::AvailableInfoStorages >(0)} {}

template <typename>
PROTOBUF_CONSTEXPR InfoStoreOptions::InfoStoreOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(InfoStoreOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct InfoStoreOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InfoStoreOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InfoStoreOptionsDefaultTypeInternal() {}
  union {
    InfoStoreOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InfoStoreOptionsDefaultTypeInternal _InfoStoreOptions_default_instance_;

inline constexpr DataStorageOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        data_dir_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        dir_structure_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_bucket_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_region_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_access_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_access_key_path_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_secret_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_secret_key_path_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_security_token_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_session_token_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_profile_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        s3_headers_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        storage_{static_cast< ::uploader::v1::AvailableDataStorages >(0)},
        force_fsync_{false},
        s3_force_path_style_{false},
        s3_concat_concurrent_downloads_{0u} {}

template <typename>
PROTOBUF_CONSTEXPR DataStorageOptions::DataStorageOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(DataStorageOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct DataStorageOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DataStorageOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~DataStorageOptionsDefaultTypeInternal() {}
  union {
    DataStorageOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DataStorageOptionsDefaultTypeInternal _DataStorageOptions_default_instance_;

inline constexpr AMQPHooksOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        exchange_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        exchange_kind_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        routing_key_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        queues_prefix_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        declare_exchange_{false},
        declare_queues_{false},
        durable_exchange_{false},
        durable_queues_{false},
        celery_{false},
        auto_delete_{false},
        connection_pool_size_{::uint64_t{0u}},
        channel_pool_size_{::uint64_t{0u}},
        idle_connection_timeout_{::uint64_t{0u}},
        idle_channels_timeout_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR AMQPHooksOptions::AMQPHooksOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(AMQPHooksOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct AMQPHooksOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AMQPHooksOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~AMQPHooksOptionsDefaultTypeInternal() {}
  union {
    AMQPHooksOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AMQPHooksOptionsDefaultTypeInternal _AMQPHooksOptions_default_instance_;

inline constexpr KafkaHookOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        extra_kafka_opts_{},
        urls_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        client_id_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        required_acks_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        compression_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        idle_timeout_{::uint64_t{0u}},
        send_timeout_{::uint64_t{0u}},
        topic_or_prefix_{},
        _oneof_case_{} {}

template <typename>
PROTOBUF_CONSTEXPR KafkaHookOptions::KafkaHookOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(KafkaHookOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct KafkaHookOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR KafkaHookOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~KafkaHookOptionsDefaultTypeInternal() {}
  union {
    KafkaHookOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 KafkaHookOptionsDefaultTypeInternal _KafkaHookOptions_default_instance_;

inline constexpr NotificationsOptions::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        hooks_{},
        _hooks_cached_byte_size_{0},
        hooks_http_urls_{},
        hooks_http_proxy_headers_{},
        hooks_dir_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        hooks_file_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        amqp_hook_opts_{nullptr},
        kafka_hook_opts_{nullptr},
        nats_hook_opts_{nullptr},
        hooks_format_{static_cast< ::uploader::v1::Format >(0)},
        behind_proxy_{false},
        http_hook_timeout_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR NotificationsOptions::NotificationsOptions(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(NotificationsOptions_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct NotificationsOptionsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NotificationsOptionsDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~NotificationsOptionsDefaultTypeInternal() {}
  union {
    NotificationsOptions _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NotificationsOptionsDefaultTypeInternal _NotificationsOptions_default_instance_;

inline constexpr RustusConf::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : _cached_size_{0},
        cors_{},
        tus_extensions_{},
        _tus_extensions_cached_byte_size_{0},
        host_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        log_level_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        storage_opts_{nullptr},
        info_storage_opts_{nullptr},
        notification_opts_{nullptr},
        sentry_opts_{nullptr},
        port_{0u},
        disable_health_access_log_{false},
        allow_empty_{false},
        remove_parts_{false},
        max_body_size_{::uint64_t{0u}},
        workers_{::uint64_t{0u}},
        max_file_size_{::uint64_t{0u}} {}

template <typename>
PROTOBUF_CONSTEXPR RustusConf::RustusConf(::_pbi::ConstantInitialized)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(RustusConf_class_data_.base()),
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(),
#endif  // PROTOBUF_CUSTOM_VTABLE
      _impl_(::_pbi::ConstantInitialized()) {
}
struct RustusConfDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RustusConfDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~RustusConfDefaultTypeInternal() {}
  union {
    RustusConf _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RustusConfDefaultTypeInternal _RustusConf_default_instance_;
}  // namespace v1
}  // namespace uploader
static const ::_pb::EnumDescriptor* PROTOBUF_NONNULL
    file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor *PROTOBUF_NONNULL *PROTOBUF_NULLABLE
    file_level_service_descriptors_uploader_2fv1_2fconfig_2eproto = nullptr;
const ::uint32_t
    TableStruct_uploader_2fv1_2fconfig_2eproto::offsets[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        protodesc_cold) = {
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_._has_bits_),
        20, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.storage_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.data_dir_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.dir_structure_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.force_fsync_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_bucket_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_region_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_access_key_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_access_key_path_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_secret_key_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_secret_key_path_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_url_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_force_path_style_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_security_token_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_session_token_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_profile_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_headers_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::DataStorageOptions, _impl_.s3_concat_concurrent_downloads_),
        13,
        0,
        1,
        14,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        15,
        9,
        10,
        11,
        12,
        16,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::InfoStoreOptions, _impl_._has_bits_),
        7, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::InfoStoreOptions, _impl_.info_storage_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::InfoStoreOptions, _impl_.info_dir_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::InfoStoreOptions, _impl_.info_db_dsn_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::InfoStoreOptions, _impl_.redis_info_expiration_),
        3,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_._has_bits_),
        18, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.url_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.declare_exchange_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.declare_queues_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.durable_exchange_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.durable_queues_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.celery_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.exchange_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.exchange_kind_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.routing_key_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.queues_prefix_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.connection_pool_size_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.channel_pool_size_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.idle_connection_timeout_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.idle_channels_timeout_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::AMQPHooksOptions, _impl_.auto_delete_),
        0,
        5,
        6,
        7,
        8,
        9,
        1,
        2,
        3,
        4,
        11,
        12,
        13,
        14,
        10,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_.key_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_.value_),
        0,
        1,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_._oneof_case_[0]),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.urls_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.client_id_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.required_acks_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.compression_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.idle_timeout_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.send_timeout_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.extra_kafka_opts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_.topic_or_prefix_),
        0,
        1,
        ~0u,
        ~0u,
        2,
        3,
        4,
        5,
        ~0u,
        0x085, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_._has_bits_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_._oneof_case_[0]),
        12, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_.urls_),
        ::_pbi::kInvalidFieldOffsetTag,
        ::_pbi::kInvalidFieldOffsetTag,
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_.wait_for_replies_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_.username_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_.password_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_.token_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_.subject_or_prefix_),
        ~0u,
        ~0u,
        ~0u,
        3,
        0,
        1,
        2,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_._has_bits_),
        14, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.hooks_format_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.hooks_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.behind_proxy_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.hooks_http_urls_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.http_hook_timeout_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.hooks_http_proxy_headers_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.hooks_dir_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.hooks_file_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.amqp_hook_opts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.kafka_hook_opts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::NotificationsOptions, _impl_.nats_hook_opts_),
        5,
        ~0u,
        6,
        ~0u,
        7,
        ~0u,
        0,
        1,
        2,
        3,
        4,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::SentryOptions, _impl_._has_bits_),
        5, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::SentryOptions, _impl_.dsn_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::SentryOptions, _impl_.sample_rate_),
        0,
        1,
        0x081, // bitmap
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_._has_bits_),
        19, // hasbit index offset
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.host_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.port_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.disable_health_access_log_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.url_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.cors_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.max_body_size_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.log_level_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.workers_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.tus_extensions_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.allow_empty_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.remove_parts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.max_file_size_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.storage_opts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.info_storage_opts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.notification_opts_),
        PROTOBUF_FIELD_OFFSET(::uploader::v1::RustusConf, _impl_.sentry_opts_),
        0,
        7,
        8,
        1,
        ~0u,
        11,
        2,
        12,
        ~0u,
        9,
        10,
        13,
        3,
        4,
        5,
        6,
};

static const ::_pbi::MigrationSchema
    schemas[] ABSL_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
        {0, sizeof(::uploader::v1::DataStorageOptions)},
        {37, sizeof(::uploader::v1::InfoStoreOptions)},
        {48, sizeof(::uploader::v1::AMQPHooksOptions)},
        {81, sizeof(::uploader::v1::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse)},
        {88, sizeof(::uploader::v1::KafkaHookOptions)},
        {111, sizeof(::uploader::v1::NatsHookOptions)},
        {130, sizeof(::uploader::v1::NotificationsOptions)},
        {155, sizeof(::uploader::v1::SentryOptions)},
        {162, sizeof(::uploader::v1::RustusConf)},
};
static const ::_pb::Message* PROTOBUF_NONNULL const file_default_instances[] = {
    &::uploader::v1::_DataStorageOptions_default_instance_._instance,
    &::uploader::v1::_InfoStoreOptions_default_instance_._instance,
    &::uploader::v1::_AMQPHooksOptions_default_instance_._instance,
    &::uploader::v1::_KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_default_instance_._instance,
    &::uploader::v1::_KafkaHookOptions_default_instance_._instance,
    &::uploader::v1::_NatsHookOptions_default_instance_._instance,
    &::uploader::v1::_NotificationsOptions_default_instance_._instance,
    &::uploader::v1::_SentryOptions_default_instance_._instance,
    &::uploader::v1::_RustusConf_default_instance_._instance,
};
const char descriptor_table_protodef_uploader_2fv1_2fconfig_2eproto[] ABSL_ATTRIBUTE_SECTION_VARIABLE(
    protodesc_cold) = {
    "\n\030uploader/v1/config.proto\022\013uploader.v1\""
    "\247\007\n\022DataStorageOptions\022<\n\007storage\030\001 \001(\0162"
    "\".uploader.v1.AvailableDataStoragesR\007sto"
    "rage\022\031\n\010data_dir\030\002 \001(\tR\007dataDir\022#\n\rdir_s"
    "tructure\030\003 \001(\tR\014dirStructure\022\037\n\013force_fs"
    "ync\030\004 \001(\010R\nforceFsync\022 \n\ts3_bucket\030\n \001(\t"
    "H\000R\010s3Bucket\210\001\001\022 \n\ts3_region\030\013 \001(\tH\001R\010s3"
    "Region\210\001\001\022\'\n\rs3_access_key\030\014 \001(\tH\002R\013s3Ac"
    "cessKey\210\001\001\0220\n\022s3_access_key_path\030\r \001(\tH\003"
    "R\017s3AccessKeyPath\210\001\001\022\'\n\rs3_secret_key\030\016 "
    "\001(\tH\004R\013s3SecretKey\210\001\001\0220\n\022s3_secret_key_p"
    "ath\030\017 \001(\tH\005R\017s3SecretKeyPath\210\001\001\022\032\n\006s3_ur"
    "l\030\020 \001(\tH\006R\005s3Url\210\001\001\022-\n\023s3_force_path_sty"
    "le\030\021 \001(\010R\020s3ForcePathStyle\022/\n\021s3_securit"
    "y_token\030\022 \001(\tH\007R\017s3SecurityToken\210\001\001\022-\n\020s"
    "3_session_token\030\023 \001(\tH\010R\016s3SessionToken\210"
    "\001\001\022\"\n\ns3_profile\030\024 \001(\tH\tR\ts3Profile\210\001\001\022\""
    "\n\ns3_headers\030\025 \001(\tH\nR\ts3Headers\210\001\001\022C\n\036s3"
    "_concat_concurrent_downloads\030\026 \001(\rR\033s3Co"
    "ncatConcurrentDownloadsB\014\n\n_s3_bucketB\014\n"
    "\n_s3_regionB\020\n\016_s3_access_keyB\025\n\023_s3_acc"
    "ess_key_pathB\020\n\016_s3_secret_keyB\025\n\023_s3_se"
    "cret_key_pathB\t\n\007_s3_urlB\024\n\022_s3_security"
    "_tokenB\023\n\021_s3_session_tokenB\r\n\013_s3_profi"
    "leB\r\n\013_s3_headers\"\374\001\n\020InfoStoreOptions\022E"
    "\n\014info_storage\030\001 \001(\0162\".uploader.v1.Avail"
    "ableInfoStoragesR\013infoStorage\022\031\n\010info_di"
    "r\030\002 \001(\tR\007infoDir\022#\n\013info_db_dsn\030\003 \001(\tH\000R"
    "\tinfoDbDsn\210\001\001\0227\n\025redis_info_expiration\030\004"
    " \001(\004H\001R\023redisInfoExpiration\210\001\001B\016\n\014_info_"
    "db_dsnB\030\n\026_redis_info_expiration\"\264\005\n\020AMQ"
    "PHooksOptions\022\025\n\003url\030\001 \001(\tH\000R\003url\210\001\001\022)\n\020"
    "declare_exchange\030\002 \001(\010R\017declareExchange\022"
    "%\n\016declare_queues\030\003 \001(\010R\rdeclareQueues\022)"
    "\n\020durable_exchange\030\004 \001(\010R\017durableExchang"
    "e\022%\n\016durable_queues\030\005 \001(\010R\rdurableQueues"
    "\022\026\n\006celery\030\006 \001(\010R\006celery\022\032\n\010exchange\030\n \001"
    "(\tR\010exchange\022#\n\rexchange_kind\030\013 \001(\tR\014exc"
    "hangeKind\022$\n\013routing_key\030\014 \001(\tH\001R\nroutin"
    "gKey\210\001\001\022#\n\rqueues_prefix\030\r \001(\tR\014queuesPr"
    "efix\0220\n\024connection_pool_size\030\016 \001(\004R\022conn"
    "ectionPoolSize\022*\n\021channel_pool_size\030\017 \001("
    "\004R\017channelPoolSize\022;\n\027idle_connection_ti"
    "meout\030\020 \001(\004H\002R\025idleConnectionTimeout\210\001\001\022"
    "7\n\025idle_channels_timeout\030\021 \001(\004H\003R\023idleCh"
    "annelsTimeout\210\001\001\022\037\n\013auto_delete\030\022 \001(\010R\na"
    "utoDeleteB\006\n\004_urlB\016\n\014_routing_keyB\032\n\030_id"
    "le_connection_timeoutB\030\n\026_idle_channels_"
    "timeout\"\256\004\n\020KafkaHookOptions\022\027\n\004urls\030\001 \001"
    "(\tH\001R\004urls\210\001\001\022 \n\tclient_id\030\002 \001(\tH\002R\010clie"
    "ntId\210\001\001\022\026\n\005topic\030\003 \001(\tH\000R\005topic\022\030\n\006prefi"
    "x\030\004 \001(\tH\000R\006prefix\022(\n\rrequired_acks\030\005 \001(\t"
    "H\003R\014requiredAcks\210\001\001\022%\n\013compression\030\006 \001(\t"
    "H\004R\013compression\210\001\001\022&\n\014idle_timeout\030\007 \001(\004"
    "H\005R\013idleTimeout\210\001\001\022&\n\014send_timeout\030\010 \001(\004"
    "H\006R\013sendTimeout\210\001\001\022[\n\020extra_kafka_opts\030\024"
    " \003(\01321.uploader.v1.KafkaHookOptions.Extr"
    "aKafkaOptsEntryR\016extraKafkaOpts\032A\n\023Extra"
    "KafkaOptsEntry\022\020\n\003key\030\001 \001(\tR\003key\022\024\n\005valu"
    "e\030\002 \001(\tR\005value:\0028\001B\021\n\017topic_or_prefixB\007\n"
    "\005_urlsB\014\n\n_client_idB\020\n\016_required_acksB\016"
    "\n\014_compressionB\017\n\r_idle_timeoutB\017\n\r_send"
    "_timeout\"\233\002\n\017NatsHookOptions\022\022\n\004urls\030\001 \003"
    "(\tR\004urls\022\032\n\007subject\030\002 \001(\tH\000R\007subject\022\030\n\006"
    "prefix\030\003 \001(\tH\000R\006prefix\022(\n\020wait_for_repli"
    "es\030\004 \001(\010R\016waitForReplies\022\037\n\010username\030\n \001"
    "(\tH\001R\010username\210\001\001\022\037\n\010password\030\013 \001(\tH\002R\010p"
    "assword\210\001\001\022\031\n\005token\030\014 \001(\tH\003R\005token\210\001\001B\023\n"
    "\021subject_or_prefixB\013\n\t_usernameB\013\n\t_pass"
    "wordB\010\n\006_token\"\365\004\n\024NotificationsOptions\022"
    "6\n\014hooks_format\030\001 \001(\0162\023.uploader.v1.Form"
    "atR\013hooksFormat\022\'\n\005hooks\030\002 \003(\0162\021.uploade"
    "r.v1.HookR\005hooks\022!\n\014behind_proxy\030\003 \001(\010R\013"
    "behindProxy\022&\n\017hooks_http_urls\030\004 \003(\tR\rho"
    "oksHttpUrls\022/\n\021http_hook_timeout\030\005 \001(\004H\000"
    "R\017httpHookTimeout\210\001\001\0227\n\030hooks_http_proxy"
    "_headers\030\006 \003(\tR\025hooksHttpProxyHeaders\022 \n"
    "\thooks_dir\030\n \001(\tH\001R\010hooksDir\210\001\001\022\"\n\nhooks"
    "_file\030\013 \001(\tH\002R\thooksFile\210\001\001\022C\n\016amqp_hook"
    "_opts\030\024 \001(\0132\035.uploader.v1.AMQPHooksOptio"
    "nsR\014amqpHookOpts\022E\n\017kafka_hook_opts\030\025 \001("
    "\0132\035.uploader.v1.KafkaHookOptionsR\rkafkaH"
    "ookOpts\022B\n\016nats_hook_opts\030\026 \001(\0132\034.upload"
    "er.v1.NatsHookOptionsR\014natsHookOptsB\024\n\022_"
    "http_hook_timeoutB\014\n\n_hooks_dirB\r\n\013_hook"
    "s_file\"O\n\rSentryOptions\022\025\n\003dsn\030\001 \001(\tH\000R\003"
    "dsn\210\001\001\022\037\n\013sample_rate\030\002 \001(\002R\nsampleRateB"
    "\006\n\004_dsn\"\333\005\n\nRustusConf\022\022\n\004host\030\001 \001(\tR\004ho"
    "st\022\022\n\004port\030\002 \001(\rR\004port\0229\n\031disable_health"
    "_access_log\030\003 \001(\010R\026disableHealthAccessLo"
    "g\022\020\n\003url\030\004 \001(\tR\003url\022\022\n\004cors\030\n \003(\tR\004cors\022"
    "\"\n\rmax_body_size\030\013 \001(\004R\013maxBodySize\022\033\n\tl"
    "og_level\030\014 \001(\tR\010logLevel\022\035\n\007workers\030\r \001("
    "\004H\000R\007workers\210\001\001\022=\n\016tus_extensions\030\016 \003(\0162"
    "\026.uploader.v1.ExtensionR\rtusExtensions\022\037"
    "\n\013allow_empty\030\017 \001(\010R\nallowEmpty\022!\n\014remov"
    "e_parts\030\020 \001(\010R\013removeParts\022\'\n\rmax_file_s"
    "ize\030\021 \001(\004H\001R\013maxFileSize\210\001\001\022B\n\014storage_o"
    "pts\030\024 \001(\0132\037.uploader.v1.DataStorageOptio"
    "nsR\013storageOpts\022I\n\021info_storage_opts\030\025 \001"
    "(\0132\035.uploader.v1.InfoStoreOptionsR\017infoS"
    "torageOpts\022N\n\021notification_opts\030\026 \001(\0132!."
    "uploader.v1.NotificationsOptionsR\020notifi"
    "cationOpts\022;\n\013sentry_opts\030\027 \001(\0132\032.upload"
    "er.v1.SentryOptionsR\nsentryOptsB\n\n\010_work"
    "ersB\020\n\016_max_file_size*i\n\025AvailableDataSt"
    "orages\022\'\n#AVAILABLE_DATA_STORAGES_UNSPEC"
    "IFIED\020\000\022\020\n\014FILE_STORAGE\020\001\022\006\n\002S3\020\002\022\r\n\tHYB"
    "RID_S3\020\003*d\n\025AvailableInfoStorages\022\'\n#AVA"
    "ILABLE_INFO_STORAGES_UNSPECIFIED\020\000\022\t\n\005FI"
    "LES\020\001\022\t\n\005REDIS\020\002\022\014\n\010POSTGRES\020\003*\207\001\n\004Hook\022"
    "\024\n\020HOOK_UNSPECIFIED\020\000\022\016\n\nPRE_CREATE\020\001\022\017\n"
    "\013POST_CREATE\020\002\022\020\n\014POST_RECEIVE\020\003\022\021\n\rPRE_"
    "TERMINATE\020\004\022\022\n\016POST_TERMINATE\020\005\022\017\n\013POST_"
    "FINISH\020\006*5\n\006Format\022\026\n\022FORMAT_UNSPECIFIED"
    "\020\000\022\013\n\007DEFAULT\020\001\022\006\n\002V2\020\002*\250\001\n\tExtension\022\031\n"
    "\025EXTENSION_UNSPECIFIED\020\000\022\013\n\007GETTING\020\001\022\014\n"
    "\010CREATION\020\002\022\030\n\024CREATION_WITH_UPLOAD\020\003\022\031\n"
    "\025CREATION_DEFER_LENGTH\020\004\022\017\n\013TERMINATION\020"
    "\005\022\021\n\rCONCATENATION\020\006\022\014\n\010CHECKSUM\020\007Bu\n\034or"
    "g.megacommerce.uploader.v1B\013ConfigProtoZ"
    "Egithub.com/ahmad-khatib0-org/megacommer"
    "ce-proto/gen/go/uploader/v1;v1\370\001\001b\006proto"
    "3"
};
static ::absl::once_flag descriptor_table_uploader_2fv1_2fconfig_2eproto_once;
PROTOBUF_CONSTINIT const ::_pbi::DescriptorTable descriptor_table_uploader_2fv1_2fconfig_2eproto = {
    false,
    false,
    4921,
    descriptor_table_protodef_uploader_2fv1_2fconfig_2eproto,
    "uploader/v1/config.proto",
    &descriptor_table_uploader_2fv1_2fconfig_2eproto_once,
    nullptr,
    0,
    9,
    schemas,
    file_default_instances,
    TableStruct_uploader_2fv1_2fconfig_2eproto::offsets,
    file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto,
    file_level_service_descriptors_uploader_2fv1_2fconfig_2eproto,
};
namespace uploader {
namespace v1 {
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AvailableDataStorages_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_uploader_2fv1_2fconfig_2eproto);
  return file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto[0];
}
PROTOBUF_CONSTINIT const uint32_t AvailableDataStorages_internal_data_[] = {
    262144u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL AvailableInfoStorages_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_uploader_2fv1_2fconfig_2eproto);
  return file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto[1];
}
PROTOBUF_CONSTINIT const uint32_t AvailableInfoStorages_internal_data_[] = {
    262144u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Hook_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_uploader_2fv1_2fconfig_2eproto);
  return file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto[2];
}
PROTOBUF_CONSTINIT const uint32_t Hook_internal_data_[] = {
    458752u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Format_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_uploader_2fv1_2fconfig_2eproto);
  return file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto[3];
}
PROTOBUF_CONSTINIT const uint32_t Format_internal_data_[] = {
    196608u, 0u, };
const ::google::protobuf::EnumDescriptor* PROTOBUF_NONNULL Extension_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&descriptor_table_uploader_2fv1_2fconfig_2eproto);
  return file_level_enum_descriptors_uploader_2fv1_2fconfig_2eproto[4];
}
PROTOBUF_CONSTINIT const uint32_t Extension_internal_data_[] = {
    524288u, 0u, };
// ===================================================================

class DataStorageOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<DataStorageOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_._has_bits_);
};

DataStorageOptions::DataStorageOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DataStorageOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.DataStorageOptions)
}
PROTOBUF_NDEBUG_INLINE DataStorageOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::DataStorageOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        data_dir_(arena, from.data_dir_),
        dir_structure_(arena, from.dir_structure_),
        s3_bucket_(arena, from.s3_bucket_),
        s3_region_(arena, from.s3_region_),
        s3_access_key_(arena, from.s3_access_key_),
        s3_access_key_path_(arena, from.s3_access_key_path_),
        s3_secret_key_(arena, from.s3_secret_key_),
        s3_secret_key_path_(arena, from.s3_secret_key_path_),
        s3_url_(arena, from.s3_url_),
        s3_security_token_(arena, from.s3_security_token_),
        s3_session_token_(arena, from.s3_session_token_),
        s3_profile_(arena, from.s3_profile_),
        s3_headers_(arena, from.s3_headers_) {}

DataStorageOptions::DataStorageOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const DataStorageOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, DataStorageOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  DataStorageOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, storage_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, storage_),
           offsetof(Impl_, s3_concat_concurrent_downloads_) -
               offsetof(Impl_, storage_) +
               sizeof(Impl_::s3_concat_concurrent_downloads_));

  // @@protoc_insertion_point(copy_constructor:uploader.v1.DataStorageOptions)
}
PROTOBUF_NDEBUG_INLINE DataStorageOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        data_dir_(arena),
        dir_structure_(arena),
        s3_bucket_(arena),
        s3_region_(arena),
        s3_access_key_(arena),
        s3_access_key_path_(arena),
        s3_secret_key_(arena),
        s3_secret_key_path_(arena),
        s3_url_(arena),
        s3_security_token_(arena),
        s3_session_token_(arena),
        s3_profile_(arena),
        s3_headers_(arena) {}

inline void DataStorageOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, storage_),
           0,
           offsetof(Impl_, s3_concat_concurrent_downloads_) -
               offsetof(Impl_, storage_) +
               sizeof(Impl_::s3_concat_concurrent_downloads_));
}
DataStorageOptions::~DataStorageOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.DataStorageOptions)
  SharedDtor(*this);
}
inline void DataStorageOptions::SharedDtor(MessageLite& self) {
  DataStorageOptions& this_ = static_cast<DataStorageOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.data_dir_.Destroy();
  this_._impl_.dir_structure_.Destroy();
  this_._impl_.s3_bucket_.Destroy();
  this_._impl_.s3_region_.Destroy();
  this_._impl_.s3_access_key_.Destroy();
  this_._impl_.s3_access_key_path_.Destroy();
  this_._impl_.s3_secret_key_.Destroy();
  this_._impl_.s3_secret_key_path_.Destroy();
  this_._impl_.s3_url_.Destroy();
  this_._impl_.s3_security_token_.Destroy();
  this_._impl_.s3_session_token_.Destroy();
  this_._impl_.s3_profile_.Destroy();
  this_._impl_.s3_headers_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL DataStorageOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) DataStorageOptions(arena);
}
constexpr auto DataStorageOptions::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(DataStorageOptions),
                                            alignof(DataStorageOptions));
}
constexpr auto DataStorageOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_DataStorageOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &DataStorageOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<DataStorageOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &DataStorageOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<DataStorageOptions>(), &DataStorageOptions::ByteSizeLong,
              &DataStorageOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_._cached_size_),
          false,
      },
      &DataStorageOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull DataStorageOptions_class_data_ =
        DataStorageOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
DataStorageOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&DataStorageOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(DataStorageOptions_class_data_.tc_table);
  return DataStorageOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 17, 0, 215, 2>
DataStorageOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_._has_bits_),
    0, // no _extensions_
    22, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4290773488,  // skipmap
    offsetof(decltype(_table_), field_entries),
    17,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    DataStorageOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::DataStorageOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .uploader.v1.AvailableDataStorages storage = 1 [json_name = "storage"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(DataStorageOptions, _impl_.storage_), 13>(),
     {8, 13, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.storage_)}},
    // string data_dir = 2 [json_name = "dataDir"];
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.data_dir_)}},
    // string dir_structure = 3 [json_name = "dirStructure"];
    {::_pbi::TcParser::FastUS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.dir_structure_)}},
    // bool force_fsync = 4 [json_name = "forceFsync"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(DataStorageOptions, _impl_.force_fsync_), 14>(),
     {32, 14, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.force_fsync_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string s3_bucket = 10 [json_name = "s3Bucket"];
    {::_pbi::TcParser::FastUS1,
     {82, 2, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_bucket_)}},
    // optional string s3_region = 11 [json_name = "s3Region"];
    {::_pbi::TcParser::FastUS1,
     {90, 3, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_region_)}},
    // optional string s3_access_key = 12 [json_name = "s3AccessKey"];
    {::_pbi::TcParser::FastUS1,
     {98, 4, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_access_key_)}},
    // optional string s3_access_key_path = 13 [json_name = "s3AccessKeyPath"];
    {::_pbi::TcParser::FastUS1,
     {106, 5, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_access_key_path_)}},
    // optional string s3_secret_key = 14 [json_name = "s3SecretKey"];
    {::_pbi::TcParser::FastUS1,
     {114, 6, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_secret_key_)}},
    // optional string s3_secret_key_path = 15 [json_name = "s3SecretKeyPath"];
    {::_pbi::TcParser::FastUS1,
     {122, 7, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_secret_key_path_)}},
    // optional string s3_url = 16 [json_name = "s3Url"];
    {::_pbi::TcParser::FastUS2,
     {386, 8, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_url_)}},
    // bool s3_force_path_style = 17 [json_name = "s3ForcePathStyle"];
    {::_pbi::TcParser::FastV8S2,
     {392, 15, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_force_path_style_)}},
    // optional string s3_security_token = 18 [json_name = "s3SecurityToken"];
    {::_pbi::TcParser::FastUS2,
     {402, 9, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_security_token_)}},
    // optional string s3_session_token = 19 [json_name = "s3SessionToken"];
    {::_pbi::TcParser::FastUS2,
     {410, 10, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_session_token_)}},
    // optional string s3_profile = 20 [json_name = "s3Profile"];
    {::_pbi::TcParser::FastUS2,
     {418, 11, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_profile_)}},
    // optional string s3_headers = 21 [json_name = "s3Headers"];
    {::_pbi::TcParser::FastUS2,
     {426, 12, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_headers_)}},
    // uint32 s3_concat_concurrent_downloads = 22 [json_name = "s3ConcatConcurrentDownloads"];
    {::_pbi::TcParser::FastV32S2,
     {432, 16, 0, PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_concat_concurrent_downloads_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .uploader.v1.AvailableDataStorages storage = 1 [json_name = "storage"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.storage_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string data_dir = 2 [json_name = "dataDir"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.data_dir_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string dir_structure = 3 [json_name = "dirStructure"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.dir_structure_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool force_fsync = 4 [json_name = "forceFsync"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.force_fsync_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string s3_bucket = 10 [json_name = "s3Bucket"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_bucket_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_region = 11 [json_name = "s3Region"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_region_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_access_key = 12 [json_name = "s3AccessKey"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_access_key_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_access_key_path = 13 [json_name = "s3AccessKeyPath"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_access_key_path_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_secret_key = 14 [json_name = "s3SecretKey"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_secret_key_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_secret_key_path = 15 [json_name = "s3SecretKeyPath"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_secret_key_path_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_url = 16 [json_name = "s3Url"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_url_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool s3_force_path_style = 17 [json_name = "s3ForcePathStyle"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_force_path_style_), _Internal::kHasBitsOffset + 15, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string s3_security_token = 18 [json_name = "s3SecurityToken"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_security_token_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_session_token = 19 [json_name = "s3SessionToken"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_session_token_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_profile = 20 [json_name = "s3Profile"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_profile_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string s3_headers = 21 [json_name = "s3Headers"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_headers_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 s3_concat_concurrent_downloads = 22 [json_name = "s3ConcatConcurrentDownloads"];
    {PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_concat_concurrent_downloads_), _Internal::kHasBitsOffset + 16, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
  }},
  // no aux_entries
  {{
    "\36\0\10\15\0\11\11\15\22\15\22\6\0\21\20\12\12\0\0\0\0\0\0\0"
    "uploader.v1.DataStorageOptions"
    "data_dir"
    "dir_structure"
    "s3_bucket"
    "s3_region"
    "s3_access_key"
    "s3_access_key_path"
    "s3_secret_key"
    "s3_secret_key_path"
    "s3_url"
    "s3_security_token"
    "s3_session_token"
    "s3_profile"
    "s3_headers"
  }},
};
PROTOBUF_NOINLINE void DataStorageOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.DataStorageOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.data_dir_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.dir_structure_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.s3_bucket_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.s3_region_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.s3_access_key_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _impl_.s3_access_key_path_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _impl_.s3_secret_key_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _impl_.s3_secret_key_path_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x00001f00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _impl_.s3_url_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _impl_.s3_security_token_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      _impl_.s3_session_token_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      _impl_.s3_profile_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      _impl_.s3_headers_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000e000u) != 0) {
    ::memset(&_impl_.storage_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.s3_force_path_style_) -
        reinterpret_cast<char*>(&_impl_.storage_)) + sizeof(_impl_.s3_force_path_style_));
  }
  _impl_.s3_concat_concurrent_downloads_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL DataStorageOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const DataStorageOptions& this_ = static_cast<const DataStorageOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL DataStorageOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const DataStorageOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.DataStorageOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .uploader.v1.AvailableDataStorages storage = 1 [json_name = "storage"];
  if ((this_._impl_._has_bits_[0] & 0x00002000u) != 0) {
    if (this_._internal_storage() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_storage(), target);
    }
  }

  // string data_dir = 2 [json_name = "dataDir"];
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_data_dir().empty()) {
      const ::std::string& _s = this_._internal_data_dir();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.data_dir");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  // string dir_structure = 3 [json_name = "dirStructure"];
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_dir_structure().empty()) {
      const ::std::string& _s = this_._internal_dir_structure();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.dir_structure");
      target = stream->WriteStringMaybeAliased(3, _s, target);
    }
  }

  // bool force_fsync = 4 [json_name = "forceFsync"];
  if ((this_._impl_._has_bits_[0] & 0x00004000u) != 0) {
    if (this_._internal_force_fsync() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_force_fsync(), target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string s3_bucket = 10 [json_name = "s3Bucket"];
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_s3_bucket();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_bucket");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // optional string s3_region = 11 [json_name = "s3Region"];
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_s3_region();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_region");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // optional string s3_access_key = 12 [json_name = "s3AccessKey"];
  if ((cached_has_bits & 0x00000010u) != 0) {
    const ::std::string& _s = this_._internal_s3_access_key();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_access_key");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // optional string s3_access_key_path = 13 [json_name = "s3AccessKeyPath"];
  if ((cached_has_bits & 0x00000020u) != 0) {
    const ::std::string& _s = this_._internal_s3_access_key_path();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_access_key_path");
    target = stream->WriteStringMaybeAliased(13, _s, target);
  }

  // optional string s3_secret_key = 14 [json_name = "s3SecretKey"];
  if ((cached_has_bits & 0x00000040u) != 0) {
    const ::std::string& _s = this_._internal_s3_secret_key();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_secret_key");
    target = stream->WriteStringMaybeAliased(14, _s, target);
  }

  // optional string s3_secret_key_path = 15 [json_name = "s3SecretKeyPath"];
  if ((cached_has_bits & 0x00000080u) != 0) {
    const ::std::string& _s = this_._internal_s3_secret_key_path();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_secret_key_path");
    target = stream->WriteStringMaybeAliased(15, _s, target);
  }

  // optional string s3_url = 16 [json_name = "s3Url"];
  if ((cached_has_bits & 0x00000100u) != 0) {
    const ::std::string& _s = this_._internal_s3_url();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_url");
    target = stream->WriteStringMaybeAliased(16, _s, target);
  }

  // bool s3_force_path_style = 17 [json_name = "s3ForcePathStyle"];
  if ((cached_has_bits & 0x00008000u) != 0) {
    if (this_._internal_s3_force_path_style() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          17, this_._internal_s3_force_path_style(), target);
    }
  }

  // optional string s3_security_token = 18 [json_name = "s3SecurityToken"];
  if ((cached_has_bits & 0x00000200u) != 0) {
    const ::std::string& _s = this_._internal_s3_security_token();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_security_token");
    target = stream->WriteStringMaybeAliased(18, _s, target);
  }

  // optional string s3_session_token = 19 [json_name = "s3SessionToken"];
  if ((cached_has_bits & 0x00000400u) != 0) {
    const ::std::string& _s = this_._internal_s3_session_token();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_session_token");
    target = stream->WriteStringMaybeAliased(19, _s, target);
  }

  // optional string s3_profile = 20 [json_name = "s3Profile"];
  if ((cached_has_bits & 0x00000800u) != 0) {
    const ::std::string& _s = this_._internal_s3_profile();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_profile");
    target = stream->WriteStringMaybeAliased(20, _s, target);
  }

  // optional string s3_headers = 21 [json_name = "s3Headers"];
  if ((cached_has_bits & 0x00001000u) != 0) {
    const ::std::string& _s = this_._internal_s3_headers();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.DataStorageOptions.s3_headers");
    target = stream->WriteStringMaybeAliased(21, _s, target);
  }

  // uint32 s3_concat_concurrent_downloads = 22 [json_name = "s3ConcatConcurrentDownloads"];
  if ((cached_has_bits & 0x00010000u) != 0) {
    if (this_._internal_s3_concat_concurrent_downloads() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          22, this_._internal_s3_concat_concurrent_downloads(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.DataStorageOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t DataStorageOptions::ByteSizeLong(const MessageLite& base) {
  const DataStorageOptions& this_ = static_cast<const DataStorageOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t DataStorageOptions::ByteSizeLong() const {
  const DataStorageOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.DataStorageOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // string data_dir = 2 [json_name = "dataDir"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_data_dir().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_data_dir());
      }
    }
    // string dir_structure = 3 [json_name = "dirStructure"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_dir_structure().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_dir_structure());
      }
    }
    // optional string s3_bucket = 10 [json_name = "s3Bucket"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_bucket());
    }
    // optional string s3_region = 11 [json_name = "s3Region"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_region());
    }
    // optional string s3_access_key = 12 [json_name = "s3AccessKey"];
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_access_key());
    }
    // optional string s3_access_key_path = 13 [json_name = "s3AccessKeyPath"];
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_access_key_path());
    }
    // optional string s3_secret_key = 14 [json_name = "s3SecretKey"];
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_secret_key());
    }
    // optional string s3_secret_key_path = 15 [json_name = "s3SecretKeyPath"];
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_secret_key_path());
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    // optional string s3_url = 16 [json_name = "s3Url"];
    if ((cached_has_bits & 0x00000100u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_url());
    }
    // optional string s3_security_token = 18 [json_name = "s3SecurityToken"];
    if ((cached_has_bits & 0x00000200u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_security_token());
    }
    // optional string s3_session_token = 19 [json_name = "s3SessionToken"];
    if ((cached_has_bits & 0x00000400u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_session_token());
    }
    // optional string s3_profile = 20 [json_name = "s3Profile"];
    if ((cached_has_bits & 0x00000800u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_profile());
    }
    // optional string s3_headers = 21 [json_name = "s3Headers"];
    if ((cached_has_bits & 0x00001000u) != 0) {
      total_size += 2 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_s3_headers());
    }
    // .uploader.v1.AvailableDataStorages storage = 1 [json_name = "storage"];
    if ((cached_has_bits & 0x00002000u) != 0) {
      if (this_._internal_storage() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_storage());
      }
    }
    // bool force_fsync = 4 [json_name = "forceFsync"];
    if ((cached_has_bits & 0x00004000u) != 0) {
      if (this_._internal_force_fsync() != 0) {
        total_size += 2;
      }
    }
    // bool s3_force_path_style = 17 [json_name = "s3ForcePathStyle"];
    if ((cached_has_bits & 0x00008000u) != 0) {
      if (this_._internal_s3_force_path_style() != 0) {
        total_size += 3;
      }
    }
  }
   {
    // uint32 s3_concat_concurrent_downloads = 22 [json_name = "s3ConcatConcurrentDownloads"];
    if ((cached_has_bits & 0x00010000u) != 0) {
      if (this_._internal_s3_concat_concurrent_downloads() != 0) {
        total_size += 2 + ::_pbi::WireFormatLite::UInt32Size(
                                        this_._internal_s3_concat_concurrent_downloads());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void DataStorageOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<DataStorageOptions*>(&to_msg);
  auto& from = static_cast<const DataStorageOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.DataStorageOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_data_dir().empty()) {
        _this->_internal_set_data_dir(from._internal_data_dir());
      } else {
        if (_this->_impl_.data_dir_.IsDefault()) {
          _this->_internal_set_data_dir("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_dir_structure().empty()) {
        _this->_internal_set_dir_structure(from._internal_dir_structure());
      } else {
        if (_this->_impl_.dir_structure_.IsDefault()) {
          _this->_internal_set_dir_structure("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_s3_bucket(from._internal_s3_bucket());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_s3_region(from._internal_s3_region());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_internal_set_s3_access_key(from._internal_s3_access_key());
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_internal_set_s3_access_key_path(from._internal_s3_access_key_path());
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      _this->_internal_set_s3_secret_key(from._internal_s3_secret_key());
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_internal_set_s3_secret_key_path(from._internal_s3_secret_key_path());
    }
  }
  if ((cached_has_bits & 0x0000ff00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      _this->_internal_set_s3_url(from._internal_s3_url());
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      _this->_internal_set_s3_security_token(from._internal_s3_security_token());
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      _this->_internal_set_s3_session_token(from._internal_s3_session_token());
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      _this->_internal_set_s3_profile(from._internal_s3_profile());
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      _this->_internal_set_s3_headers(from._internal_s3_headers());
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      if (from._internal_storage() != 0) {
        _this->_impl_.storage_ = from._impl_.storage_;
      }
    }
    if ((cached_has_bits & 0x00004000u) != 0) {
      if (from._internal_force_fsync() != 0) {
        _this->_impl_.force_fsync_ = from._impl_.force_fsync_;
      }
    }
    if ((cached_has_bits & 0x00008000u) != 0) {
      if (from._internal_s3_force_path_style() != 0) {
        _this->_impl_.s3_force_path_style_ = from._impl_.s3_force_path_style_;
      }
    }
  }
  if ((cached_has_bits & 0x00010000u) != 0) {
    if (from._internal_s3_concat_concurrent_downloads() != 0) {
      _this->_impl_.s3_concat_concurrent_downloads_ = from._impl_.s3_concat_concurrent_downloads_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void DataStorageOptions::CopyFrom(const DataStorageOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.DataStorageOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void DataStorageOptions::InternalSwap(DataStorageOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.data_dir_, &other->_impl_.data_dir_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dir_structure_, &other->_impl_.dir_structure_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_bucket_, &other->_impl_.s3_bucket_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_region_, &other->_impl_.s3_region_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_access_key_, &other->_impl_.s3_access_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_access_key_path_, &other->_impl_.s3_access_key_path_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_secret_key_, &other->_impl_.s3_secret_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_secret_key_path_, &other->_impl_.s3_secret_key_path_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_url_, &other->_impl_.s3_url_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_security_token_, &other->_impl_.s3_security_token_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_session_token_, &other->_impl_.s3_session_token_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_profile_, &other->_impl_.s3_profile_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.s3_headers_, &other->_impl_.s3_headers_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.s3_concat_concurrent_downloads_)
      + sizeof(DataStorageOptions::_impl_.s3_concat_concurrent_downloads_)
      - PROTOBUF_FIELD_OFFSET(DataStorageOptions, _impl_.storage_)>(
          reinterpret_cast<char*>(&_impl_.storage_),
          reinterpret_cast<char*>(&other->_impl_.storage_));
}

::google::protobuf::Metadata DataStorageOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class InfoStoreOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<InfoStoreOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_._has_bits_);
};

InfoStoreOptions::InfoStoreOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, InfoStoreOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.InfoStoreOptions)
}
PROTOBUF_NDEBUG_INLINE InfoStoreOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::InfoStoreOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        info_dir_(arena, from.info_dir_),
        info_db_dsn_(arena, from.info_db_dsn_) {}

InfoStoreOptions::InfoStoreOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const InfoStoreOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, InfoStoreOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  InfoStoreOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, redis_info_expiration_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, redis_info_expiration_),
           offsetof(Impl_, info_storage_) -
               offsetof(Impl_, redis_info_expiration_) +
               sizeof(Impl_::info_storage_));

  // @@protoc_insertion_point(copy_constructor:uploader.v1.InfoStoreOptions)
}
PROTOBUF_NDEBUG_INLINE InfoStoreOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        info_dir_(arena),
        info_db_dsn_(arena) {}

inline void InfoStoreOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, redis_info_expiration_),
           0,
           offsetof(Impl_, info_storage_) -
               offsetof(Impl_, redis_info_expiration_) +
               sizeof(Impl_::info_storage_));
}
InfoStoreOptions::~InfoStoreOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.InfoStoreOptions)
  SharedDtor(*this);
}
inline void InfoStoreOptions::SharedDtor(MessageLite& self) {
  InfoStoreOptions& this_ = static_cast<InfoStoreOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.info_dir_.Destroy();
  this_._impl_.info_db_dsn_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL InfoStoreOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) InfoStoreOptions(arena);
}
constexpr auto InfoStoreOptions::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(InfoStoreOptions),
                                            alignof(InfoStoreOptions));
}
constexpr auto InfoStoreOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_InfoStoreOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &InfoStoreOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<InfoStoreOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &InfoStoreOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<InfoStoreOptions>(), &InfoStoreOptions::ByteSizeLong,
              &InfoStoreOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_._cached_size_),
          false,
      },
      &InfoStoreOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull InfoStoreOptions_class_data_ =
        InfoStoreOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
InfoStoreOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&InfoStoreOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(InfoStoreOptions_class_data_.tc_table);
  return InfoStoreOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 4, 0, 56, 2>
InfoStoreOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_._has_bits_),
    0, // no _extensions_
    4, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967280,  // skipmap
    offsetof(decltype(_table_), field_entries),
    4,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    InfoStoreOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::InfoStoreOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint64 redis_info_expiration = 4 [json_name = "redisInfoExpiration"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(InfoStoreOptions, _impl_.redis_info_expiration_), 2>(),
     {32, 2, 0, PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.redis_info_expiration_)}},
    // .uploader.v1.AvailableInfoStorages info_storage = 1 [json_name = "infoStorage"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(InfoStoreOptions, _impl_.info_storage_), 3>(),
     {8, 3, 0, PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_storage_)}},
    // string info_dir = 2 [json_name = "infoDir"];
    {::_pbi::TcParser::FastUS1,
     {18, 0, 0, PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_dir_)}},
    // optional string info_db_dsn = 3 [json_name = "infoDbDsn"];
    {::_pbi::TcParser::FastUS1,
     {26, 1, 0, PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_db_dsn_)}},
  }}, {{
    65535, 65535
  }}, {{
    // .uploader.v1.AvailableInfoStorages info_storage = 1 [json_name = "infoStorage"];
    {PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_storage_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // string info_dir = 2 [json_name = "infoDir"];
    {PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_dir_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string info_db_dsn = 3 [json_name = "infoDbDsn"];
    {PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_db_dsn_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional uint64 redis_info_expiration = 4 [json_name = "redisInfoExpiration"];
    {PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.redis_info_expiration_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
  }},
  // no aux_entries
  {{
    "\34\0\10\13\0\0\0\0"
    "uploader.v1.InfoStoreOptions"
    "info_dir"
    "info_db_dsn"
  }},
};
PROTOBUF_NOINLINE void InfoStoreOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.InfoStoreOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.info_dir_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.info_db_dsn_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x0000000cu) != 0) {
    ::memset(&_impl_.redis_info_expiration_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.info_storage_) -
        reinterpret_cast<char*>(&_impl_.redis_info_expiration_)) + sizeof(_impl_.info_storage_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL InfoStoreOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const InfoStoreOptions& this_ = static_cast<const InfoStoreOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL InfoStoreOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const InfoStoreOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.InfoStoreOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .uploader.v1.AvailableInfoStorages info_storage = 1 [json_name = "infoStorage"];
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_info_storage() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_info_storage(), target);
    }
  }

  // string info_dir = 2 [json_name = "infoDir"];
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_info_dir().empty()) {
      const ::std::string& _s = this_._internal_info_dir();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.InfoStoreOptions.info_dir");
      target = stream->WriteStringMaybeAliased(2, _s, target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string info_db_dsn = 3 [json_name = "infoDbDsn"];
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_info_db_dsn();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.InfoStoreOptions.info_db_dsn");
    target = stream->WriteStringMaybeAliased(3, _s, target);
  }

  // optional uint64 redis_info_expiration = 4 [json_name = "redisInfoExpiration"];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        4, this_._internal_redis_info_expiration(), target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.InfoStoreOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t InfoStoreOptions::ByteSizeLong(const MessageLite& base) {
  const InfoStoreOptions& this_ = static_cast<const InfoStoreOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t InfoStoreOptions::ByteSizeLong() const {
  const InfoStoreOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.InfoStoreOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // string info_dir = 2 [json_name = "infoDir"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_info_dir().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_info_dir());
      }
    }
    // optional string info_db_dsn = 3 [json_name = "infoDbDsn"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_info_db_dsn());
    }
    // optional uint64 redis_info_expiration = 4 [json_name = "redisInfoExpiration"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_redis_info_expiration());
    }
    // .uploader.v1.AvailableInfoStorages info_storage = 1 [json_name = "infoStorage"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_info_storage() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_info_storage());
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void InfoStoreOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<InfoStoreOptions*>(&to_msg);
  auto& from = static_cast<const InfoStoreOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.InfoStoreOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_info_dir().empty()) {
        _this->_internal_set_info_dir(from._internal_info_dir());
      } else {
        if (_this->_impl_.info_dir_.IsDefault()) {
          _this->_internal_set_info_dir("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_info_db_dsn(from._internal_info_db_dsn());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_impl_.redis_info_expiration_ = from._impl_.redis_info_expiration_;
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_info_storage() != 0) {
        _this->_impl_.info_storage_ = from._impl_.info_storage_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void InfoStoreOptions::CopyFrom(const InfoStoreOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.InfoStoreOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void InfoStoreOptions::InternalSwap(InfoStoreOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.info_dir_, &other->_impl_.info_dir_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.info_db_dsn_, &other->_impl_.info_db_dsn_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.info_storage_)
      + sizeof(InfoStoreOptions::_impl_.info_storage_)
      - PROTOBUF_FIELD_OFFSET(InfoStoreOptions, _impl_.redis_info_expiration_)>(
          reinterpret_cast<char*>(&_impl_.redis_info_expiration_),
          reinterpret_cast<char*>(&other->_impl_.redis_info_expiration_));
}

::google::protobuf::Metadata InfoStoreOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class AMQPHooksOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<AMQPHooksOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_._has_bits_);
};

AMQPHooksOptions::AMQPHooksOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AMQPHooksOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.AMQPHooksOptions)
}
PROTOBUF_NDEBUG_INLINE AMQPHooksOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::AMQPHooksOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        url_(arena, from.url_),
        exchange_(arena, from.exchange_),
        exchange_kind_(arena, from.exchange_kind_),
        routing_key_(arena, from.routing_key_),
        queues_prefix_(arena, from.queues_prefix_) {}

AMQPHooksOptions::AMQPHooksOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const AMQPHooksOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, AMQPHooksOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  AMQPHooksOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, declare_exchange_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, declare_exchange_),
           offsetof(Impl_, idle_channels_timeout_) -
               offsetof(Impl_, declare_exchange_) +
               sizeof(Impl_::idle_channels_timeout_));

  // @@protoc_insertion_point(copy_constructor:uploader.v1.AMQPHooksOptions)
}
PROTOBUF_NDEBUG_INLINE AMQPHooksOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        url_(arena),
        exchange_(arena),
        exchange_kind_(arena),
        routing_key_(arena),
        queues_prefix_(arena) {}

inline void AMQPHooksOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, declare_exchange_),
           0,
           offsetof(Impl_, idle_channels_timeout_) -
               offsetof(Impl_, declare_exchange_) +
               sizeof(Impl_::idle_channels_timeout_));
}
AMQPHooksOptions::~AMQPHooksOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.AMQPHooksOptions)
  SharedDtor(*this);
}
inline void AMQPHooksOptions::SharedDtor(MessageLite& self) {
  AMQPHooksOptions& this_ = static_cast<AMQPHooksOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.url_.Destroy();
  this_._impl_.exchange_.Destroy();
  this_._impl_.exchange_kind_.Destroy();
  this_._impl_.routing_key_.Destroy();
  this_._impl_.queues_prefix_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL AMQPHooksOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) AMQPHooksOptions(arena);
}
constexpr auto AMQPHooksOptions::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(AMQPHooksOptions),
                                            alignof(AMQPHooksOptions));
}
constexpr auto AMQPHooksOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_AMQPHooksOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &AMQPHooksOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<AMQPHooksOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &AMQPHooksOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<AMQPHooksOptions>(), &AMQPHooksOptions::ByteSizeLong,
              &AMQPHooksOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_._cached_size_),
          false,
      },
      &AMQPHooksOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull AMQPHooksOptions_class_data_ =
        AMQPHooksOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
AMQPHooksOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&AMQPHooksOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(AMQPHooksOptions_class_data_.tc_table);
  return AMQPHooksOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 15, 0, 93, 2>
AMQPHooksOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_._has_bits_),
    0, // no _extensions_
    18, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294705600,  // skipmap
    offsetof(decltype(_table_), field_entries),
    15,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    AMQPHooksOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::AMQPHooksOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint64 idle_connection_timeout = 16 [json_name = "idleConnectionTimeout"];
    {::_pbi::TcParser::FastV64S2,
     {384, 13, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.idle_connection_timeout_)}},
    // optional string url = 1 [json_name = "url"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.url_)}},
    // bool declare_exchange = 2 [json_name = "declareExchange"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AMQPHooksOptions, _impl_.declare_exchange_), 5>(),
     {16, 5, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.declare_exchange_)}},
    // bool declare_queues = 3 [json_name = "declareQueues"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AMQPHooksOptions, _impl_.declare_queues_), 6>(),
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.declare_queues_)}},
    // bool durable_exchange = 4 [json_name = "durableExchange"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AMQPHooksOptions, _impl_.durable_exchange_), 7>(),
     {32, 7, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.durable_exchange_)}},
    // bool durable_queues = 5 [json_name = "durableQueues"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AMQPHooksOptions, _impl_.durable_queues_), 8>(),
     {40, 8, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.durable_queues_)}},
    // bool celery = 6 [json_name = "celery"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(AMQPHooksOptions, _impl_.celery_), 9>(),
     {48, 9, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.celery_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // string exchange = 10 [json_name = "exchange"];
    {::_pbi::TcParser::FastUS1,
     {82, 1, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.exchange_)}},
    // string exchange_kind = 11 [json_name = "exchangeKind"];
    {::_pbi::TcParser::FastUS1,
     {90, 2, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.exchange_kind_)}},
    // optional string routing_key = 12 [json_name = "routingKey"];
    {::_pbi::TcParser::FastUS1,
     {98, 3, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.routing_key_)}},
    // string queues_prefix = 13 [json_name = "queuesPrefix"];
    {::_pbi::TcParser::FastUS1,
     {106, 4, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.queues_prefix_)}},
    // uint64 connection_pool_size = 14 [json_name = "connectionPoolSize"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(AMQPHooksOptions, _impl_.connection_pool_size_), 11>(),
     {112, 11, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.connection_pool_size_)}},
    // uint64 channel_pool_size = 15 [json_name = "channelPoolSize"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(AMQPHooksOptions, _impl_.channel_pool_size_), 12>(),
     {120, 12, 0, PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.channel_pool_size_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string url = 1 [json_name = "url"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.url_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool declare_exchange = 2 [json_name = "declareExchange"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.declare_exchange_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool declare_queues = 3 [json_name = "declareQueues"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.declare_queues_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool durable_exchange = 4 [json_name = "durableExchange"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.durable_exchange_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool durable_queues = 5 [json_name = "durableQueues"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.durable_queues_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool celery = 6 [json_name = "celery"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.celery_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string exchange = 10 [json_name = "exchange"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.exchange_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string exchange_kind = 11 [json_name = "exchangeKind"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.exchange_kind_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string routing_key = 12 [json_name = "routingKey"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.routing_key_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string queues_prefix = 13 [json_name = "queuesPrefix"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.queues_prefix_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint64 connection_pool_size = 14 [json_name = "connectionPoolSize"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.connection_pool_size_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // uint64 channel_pool_size = 15 [json_name = "channelPoolSize"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.channel_pool_size_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 idle_connection_timeout = 16 [json_name = "idleConnectionTimeout"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.idle_connection_timeout_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 idle_channels_timeout = 17 [json_name = "idleChannelsTimeout"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.idle_channels_timeout_), _Internal::kHasBitsOffset + 14, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // bool auto_delete = 18 [json_name = "autoDelete"];
    {PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.auto_delete_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
  }},
  // no aux_entries
  {{
    "\34\3\0\0\0\0\0\10\15\13\15\0\0\0\0\0"
    "uploader.v1.AMQPHooksOptions"
    "url"
    "exchange"
    "exchange_kind"
    "routing_key"
    "queues_prefix"
  }},
};
PROTOBUF_NOINLINE void AMQPHooksOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.AMQPHooksOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.exchange_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.exchange_kind_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.routing_key_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _impl_.queues_prefix_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x000000e0u) != 0) {
    ::memset(&_impl_.declare_exchange_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.durable_exchange_) -
        reinterpret_cast<char*>(&_impl_.declare_exchange_)) + sizeof(_impl_.durable_exchange_));
  }
  if ((cached_has_bits & 0x00007f00u) != 0) {
    ::memset(&_impl_.durable_queues_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.idle_channels_timeout_) -
        reinterpret_cast<char*>(&_impl_.durable_queues_)) + sizeof(_impl_.idle_channels_timeout_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL AMQPHooksOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const AMQPHooksOptions& this_ = static_cast<const AMQPHooksOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL AMQPHooksOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const AMQPHooksOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.AMQPHooksOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string url = 1 [json_name = "url"];
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_url();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.AMQPHooksOptions.url");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // bool declare_exchange = 2 [json_name = "declareExchange"];
  if ((cached_has_bits & 0x00000020u) != 0) {
    if (this_._internal_declare_exchange() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          2, this_._internal_declare_exchange(), target);
    }
  }

  // bool declare_queues = 3 [json_name = "declareQueues"];
  if ((cached_has_bits & 0x00000040u) != 0) {
    if (this_._internal_declare_queues() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_declare_queues(), target);
    }
  }

  // bool durable_exchange = 4 [json_name = "durableExchange"];
  if ((cached_has_bits & 0x00000080u) != 0) {
    if (this_._internal_durable_exchange() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_durable_exchange(), target);
    }
  }

  // bool durable_queues = 5 [json_name = "durableQueues"];
  if ((cached_has_bits & 0x00000100u) != 0) {
    if (this_._internal_durable_queues() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          5, this_._internal_durable_queues(), target);
    }
  }

  // bool celery = 6 [json_name = "celery"];
  if ((cached_has_bits & 0x00000200u) != 0) {
    if (this_._internal_celery() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          6, this_._internal_celery(), target);
    }
  }

  // string exchange = 10 [json_name = "exchange"];
  if ((cached_has_bits & 0x00000002u) != 0) {
    if (!this_._internal_exchange().empty()) {
      const ::std::string& _s = this_._internal_exchange();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.AMQPHooksOptions.exchange");
      target = stream->WriteStringMaybeAliased(10, _s, target);
    }
  }

  // string exchange_kind = 11 [json_name = "exchangeKind"];
  if ((cached_has_bits & 0x00000004u) != 0) {
    if (!this_._internal_exchange_kind().empty()) {
      const ::std::string& _s = this_._internal_exchange_kind();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.AMQPHooksOptions.exchange_kind");
      target = stream->WriteStringMaybeAliased(11, _s, target);
    }
  }

  // optional string routing_key = 12 [json_name = "routingKey"];
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_routing_key();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.AMQPHooksOptions.routing_key");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  // string queues_prefix = 13 [json_name = "queuesPrefix"];
  if ((cached_has_bits & 0x00000010u) != 0) {
    if (!this_._internal_queues_prefix().empty()) {
      const ::std::string& _s = this_._internal_queues_prefix();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.AMQPHooksOptions.queues_prefix");
      target = stream->WriteStringMaybeAliased(13, _s, target);
    }
  }

  // uint64 connection_pool_size = 14 [json_name = "connectionPoolSize"];
  if ((cached_has_bits & 0x00000800u) != 0) {
    if (this_._internal_connection_pool_size() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          14, this_._internal_connection_pool_size(), target);
    }
  }

  // uint64 channel_pool_size = 15 [json_name = "channelPoolSize"];
  if ((cached_has_bits & 0x00001000u) != 0) {
    if (this_._internal_channel_pool_size() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          15, this_._internal_channel_pool_size(), target);
    }
  }

  // optional uint64 idle_connection_timeout = 16 [json_name = "idleConnectionTimeout"];
  if ((cached_has_bits & 0x00002000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        16, this_._internal_idle_connection_timeout(), target);
  }

  // optional uint64 idle_channels_timeout = 17 [json_name = "idleChannelsTimeout"];
  if ((cached_has_bits & 0x00004000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        17, this_._internal_idle_channels_timeout(), target);
  }

  // bool auto_delete = 18 [json_name = "autoDelete"];
  if ((cached_has_bits & 0x00000400u) != 0) {
    if (this_._internal_auto_delete() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          18, this_._internal_auto_delete(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.AMQPHooksOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t AMQPHooksOptions::ByteSizeLong(const MessageLite& base) {
  const AMQPHooksOptions& this_ = static_cast<const AMQPHooksOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t AMQPHooksOptions::ByteSizeLong() const {
  const AMQPHooksOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.AMQPHooksOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // optional string url = 1 [json_name = "url"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_url());
    }
    // string exchange = 10 [json_name = "exchange"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_exchange().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_exchange());
      }
    }
    // string exchange_kind = 11 [json_name = "exchangeKind"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (!this_._internal_exchange_kind().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_exchange_kind());
      }
    }
    // optional string routing_key = 12 [json_name = "routingKey"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_routing_key());
    }
    // string queues_prefix = 13 [json_name = "queuesPrefix"];
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (!this_._internal_queues_prefix().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_queues_prefix());
      }
    }
    // bool declare_exchange = 2 [json_name = "declareExchange"];
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_declare_exchange() != 0) {
        total_size += 2;
      }
    }
    // bool declare_queues = 3 [json_name = "declareQueues"];
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_declare_queues() != 0) {
        total_size += 2;
      }
    }
    // bool durable_exchange = 4 [json_name = "durableExchange"];
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_durable_exchange() != 0) {
        total_size += 2;
      }
    }
  }
  if ((cached_has_bits & 0x00007f00u) != 0) {
    // bool durable_queues = 5 [json_name = "durableQueues"];
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (this_._internal_durable_queues() != 0) {
        total_size += 2;
      }
    }
    // bool celery = 6 [json_name = "celery"];
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (this_._internal_celery() != 0) {
        total_size += 2;
      }
    }
    // bool auto_delete = 18 [json_name = "autoDelete"];
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (this_._internal_auto_delete() != 0) {
        total_size += 3;
      }
    }
    // uint64 connection_pool_size = 14 [json_name = "connectionPoolSize"];
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (this_._internal_connection_pool_size() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_connection_pool_size());
      }
    }
    // uint64 channel_pool_size = 15 [json_name = "channelPoolSize"];
    if ((cached_has_bits & 0x00001000u) != 0) {
      if (this_._internal_channel_pool_size() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_channel_pool_size());
      }
    }
    // optional uint64 idle_connection_timeout = 16 [json_name = "idleConnectionTimeout"];
    if ((cached_has_bits & 0x00002000u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this_._internal_idle_connection_timeout());
    }
    // optional uint64 idle_channels_timeout = 17 [json_name = "idleChannelsTimeout"];
    if ((cached_has_bits & 0x00004000u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this_._internal_idle_channels_timeout());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void AMQPHooksOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<AMQPHooksOptions*>(&to_msg);
  auto& from = static_cast<const AMQPHooksOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.AMQPHooksOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_url(from._internal_url());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_exchange().empty()) {
        _this->_internal_set_exchange(from._internal_exchange());
      } else {
        if (_this->_impl_.exchange_.IsDefault()) {
          _this->_internal_set_exchange("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (!from._internal_exchange_kind().empty()) {
        _this->_internal_set_exchange_kind(from._internal_exchange_kind());
      } else {
        if (_this->_impl_.exchange_kind_.IsDefault()) {
          _this->_internal_set_exchange_kind("");
        }
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_routing_key(from._internal_routing_key());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      if (!from._internal_queues_prefix().empty()) {
        _this->_internal_set_queues_prefix(from._internal_queues_prefix());
      } else {
        if (_this->_impl_.queues_prefix_.IsDefault()) {
          _this->_internal_set_queues_prefix("");
        }
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_declare_exchange() != 0) {
        _this->_impl_.declare_exchange_ = from._impl_.declare_exchange_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_declare_queues() != 0) {
        _this->_impl_.declare_queues_ = from._impl_.declare_queues_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_durable_exchange() != 0) {
        _this->_impl_.durable_exchange_ = from._impl_.durable_exchange_;
      }
    }
  }
  if ((cached_has_bits & 0x00007f00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (from._internal_durable_queues() != 0) {
        _this->_impl_.durable_queues_ = from._impl_.durable_queues_;
      }
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (from._internal_celery() != 0) {
        _this->_impl_.celery_ = from._impl_.celery_;
      }
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (from._internal_auto_delete() != 0) {
        _this->_impl_.auto_delete_ = from._impl_.auto_delete_;
      }
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (from._internal_connection_pool_size() != 0) {
        _this->_impl_.connection_pool_size_ = from._impl_.connection_pool_size_;
      }
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      if (from._internal_channel_pool_size() != 0) {
        _this->_impl_.channel_pool_size_ = from._impl_.channel_pool_size_;
      }
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      _this->_impl_.idle_connection_timeout_ = from._impl_.idle_connection_timeout_;
    }
    if ((cached_has_bits & 0x00004000u) != 0) {
      _this->_impl_.idle_channels_timeout_ = from._impl_.idle_channels_timeout_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void AMQPHooksOptions::CopyFrom(const AMQPHooksOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.AMQPHooksOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void AMQPHooksOptions::InternalSwap(AMQPHooksOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.url_, &other->_impl_.url_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.exchange_, &other->_impl_.exchange_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.exchange_kind_, &other->_impl_.exchange_kind_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.routing_key_, &other->_impl_.routing_key_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.queues_prefix_, &other->_impl_.queues_prefix_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.idle_channels_timeout_)
      + sizeof(AMQPHooksOptions::_impl_.idle_channels_timeout_)
      - PROTOBUF_FIELD_OFFSET(AMQPHooksOptions, _impl_.declare_exchange_)>(
          reinterpret_cast<char*>(&_impl_.declare_exchange_),
          reinterpret_cast<char*>(&other->_impl_.declare_exchange_));
}

::google::protobuf::Metadata AMQPHooksOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

#if defined(PROTOBUF_CUSTOM_VTABLE)
KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse()
    : SuperType(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_.base()) {}
KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
    : SuperType(arena, KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_.base()) {}
#else   // PROTOBUF_CUSTOM_VTABLE
KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse() : SuperType() {}
KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse(::google::protobuf::Arena* PROTOBUF_NULLABLE arena) : SuperType(arena) {}
#endif  // PROTOBUF_CUSTOM_VTABLE
inline void* PROTOBUF_NONNULL KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse(arena);
}
constexpr auto KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse),
                                            alignof(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse));
}
constexpr auto KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::SharedDtor,
          static_cast<void (::google::protobuf::MessageLite::*)()>(&KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::ClearImpl),
              ::google::protobuf::Message::ByteSizeLongImpl, ::google::protobuf::Message::_InternalSerializeImpl
              ,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_._cached_size_),
          false,
      },
      &KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_ =
        KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_.tc_table);
  return KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 65, 2>
KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::DiscardEverythingFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // string value = 2 [json_name = "value"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_.value_)}},
    // string key = 1 [json_name = "key"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_.key_)}},
  }}, {{
    65535, 65535
  }}, {{
    // string key = 1 [json_name = "key"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_.key_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string value = 2 [json_name = "value"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions_ExtraKafkaOptsEntry_DoNotUse, _impl_.value_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\60\3\5\0\0\0\0\0"
    "uploader.v1.KafkaHookOptions.ExtraKafkaOptsEntry"
    "key"
    "value"
  }},
};
// ===================================================================

class KafkaHookOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<KafkaHookOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::uploader::v1::KafkaHookOptions, _impl_._oneof_case_);
};

KafkaHookOptions::KafkaHookOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KafkaHookOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.KafkaHookOptions)
}
PROTOBUF_NDEBUG_INLINE KafkaHookOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::KafkaHookOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        extra_kafka_opts_{visibility, arena, from.extra_kafka_opts_},
        urls_(arena, from.urls_),
        client_id_(arena, from.client_id_),
        required_acks_(arena, from.required_acks_),
        compression_(arena, from.compression_),
        topic_or_prefix_{},
        _oneof_case_{from._oneof_case_[0]} {}

KafkaHookOptions::KafkaHookOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const KafkaHookOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, KafkaHookOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  KafkaHookOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, idle_timeout_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, idle_timeout_),
           offsetof(Impl_, send_timeout_) -
               offsetof(Impl_, idle_timeout_) +
               sizeof(Impl_::send_timeout_));
  switch (topic_or_prefix_case()) {
    case TOPIC_OR_PREFIX_NOT_SET:
      break;
      case kTopic:
        new (&_impl_.topic_or_prefix_.topic_) decltype(_impl_.topic_or_prefix_.topic_){arena, from._impl_.topic_or_prefix_.topic_};
        break;
      case kPrefix:
        new (&_impl_.topic_or_prefix_.prefix_) decltype(_impl_.topic_or_prefix_.prefix_){arena, from._impl_.topic_or_prefix_.prefix_};
        break;
  }

  // @@protoc_insertion_point(copy_constructor:uploader.v1.KafkaHookOptions)
}
PROTOBUF_NDEBUG_INLINE KafkaHookOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        extra_kafka_opts_{visibility, arena},
        urls_(arena),
        client_id_(arena),
        required_acks_(arena),
        compression_(arena),
        topic_or_prefix_{},
        _oneof_case_{} {}

inline void KafkaHookOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, idle_timeout_),
           0,
           offsetof(Impl_, send_timeout_) -
               offsetof(Impl_, idle_timeout_) +
               sizeof(Impl_::send_timeout_));
}
KafkaHookOptions::~KafkaHookOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.KafkaHookOptions)
  SharedDtor(*this);
}
inline void KafkaHookOptions::SharedDtor(MessageLite& self) {
  KafkaHookOptions& this_ = static_cast<KafkaHookOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.urls_.Destroy();
  this_._impl_.client_id_.Destroy();
  this_._impl_.required_acks_.Destroy();
  this_._impl_.compression_.Destroy();
  if (this_.has_topic_or_prefix()) {
    this_.clear_topic_or_prefix();
  }
  this_._impl_.~Impl_();
}

void KafkaHookOptions::clear_topic_or_prefix() {
// @@protoc_insertion_point(one_of_clear_start:uploader.v1.KafkaHookOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (topic_or_prefix_case()) {
    case kTopic: {
      _impl_.topic_or_prefix_.topic_.Destroy();
      break;
    }
    case kPrefix: {
      _impl_.topic_or_prefix_.prefix_.Destroy();
      break;
    }
    case TOPIC_OR_PREFIX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TOPIC_OR_PREFIX_NOT_SET;
}


inline void* PROTOBUF_NONNULL KafkaHookOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) KafkaHookOptions(arena);
}
constexpr auto KafkaHookOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.extra_kafka_opts_) +
          decltype(KafkaHookOptions::_impl_.extra_kafka_opts_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.extra_kafka_opts_) +
          decltype(KafkaHookOptions::_impl_.extra_kafka_opts_)::
              InternalGetArenaOffsetAlt(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(KafkaHookOptions), alignof(KafkaHookOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&KafkaHookOptions::PlacementNew_,
                                 sizeof(KafkaHookOptions),
                                 alignof(KafkaHookOptions));
  }
}
constexpr auto KafkaHookOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_KafkaHookOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &KafkaHookOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<KafkaHookOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &KafkaHookOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<KafkaHookOptions>(), &KafkaHookOptions::ByteSizeLong,
              &KafkaHookOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_._cached_size_),
          false,
      },
      &KafkaHookOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull KafkaHookOptions_class_data_ =
        KafkaHookOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
KafkaHookOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&KafkaHookOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(KafkaHookOptions_class_data_.tc_table);
  return KafkaHookOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<3, 9, 1, 109, 2>
KafkaHookOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_._has_bits_),
    0, // no _extensions_
    20, 56,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294442752,  // skipmap
    offsetof(decltype(_table_), field_entries),
    9,  // num_field_entries
    1,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    KafkaHookOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::KafkaHookOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // optional uint64 send_timeout = 8 [json_name = "sendTimeout"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(KafkaHookOptions, _impl_.send_timeout_), 5>(),
     {64, 5, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.send_timeout_)}},
    // optional string urls = 1 [json_name = "urls"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.urls_)}},
    // optional string client_id = 2 [json_name = "clientId"];
    {::_pbi::TcParser::FastUS1,
     {18, 1, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.client_id_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string required_acks = 5 [json_name = "requiredAcks"];
    {::_pbi::TcParser::FastUS1,
     {42, 2, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.required_acks_)}},
    // optional string compression = 6 [json_name = "compression"];
    {::_pbi::TcParser::FastUS1,
     {50, 3, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.compression_)}},
    // optional uint64 idle_timeout = 7 [json_name = "idleTimeout"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(KafkaHookOptions, _impl_.idle_timeout_), 4>(),
     {56, 4, 0, PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.idle_timeout_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string urls = 1 [json_name = "urls"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.urls_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string client_id = 2 [json_name = "clientId"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.client_id_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string topic = 3 [json_name = "topic"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.topic_or_prefix_.topic_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string prefix = 4 [json_name = "prefix"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.topic_or_prefix_.prefix_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string required_acks = 5 [json_name = "requiredAcks"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.required_acks_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string compression = 6 [json_name = "compression"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.compression_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional uint64 idle_timeout = 7 [json_name = "idleTimeout"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.idle_timeout_), _Internal::kHasBitsOffset + 4, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // optional uint64 send_timeout = 8 [json_name = "sendTimeout"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.send_timeout_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // map<string, string> extra_kafka_opts = 20 [json_name = "extraKafkaOpts"];
    {PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.extra_kafka_opts_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kMap)},
  }},
  {{
      {::_pbi::TcParser::GetMapAuxInfo(1, 0, 0,
                                       9, 9,
                                       0)},
  }},
  {{
    "\34\4\11\5\6\15\13\0\0\20\0\0\0\0\0\0"
    "uploader.v1.KafkaHookOptions"
    "urls"
    "client_id"
    "topic"
    "prefix"
    "required_acks"
    "compression"
    "extra_kafka_opts"
  }},
};
PROTOBUF_NOINLINE void KafkaHookOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.KafkaHookOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.extra_kafka_opts_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.urls_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.client_id_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.required_acks_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _impl_.compression_.ClearNonDefaultToEmpty();
    }
  }
  if ((cached_has_bits & 0x00000030u) != 0) {
    ::memset(&_impl_.idle_timeout_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.send_timeout_) -
        reinterpret_cast<char*>(&_impl_.idle_timeout_)) + sizeof(_impl_.send_timeout_));
  }
  clear_topic_or_prefix();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL KafkaHookOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const KafkaHookOptions& this_ = static_cast<const KafkaHookOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL KafkaHookOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const KafkaHookOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.KafkaHookOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string urls = 1 [json_name = "urls"];
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_urls();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.urls");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // optional string client_id = 2 [json_name = "clientId"];
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_client_id();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.client_id");
    target = stream->WriteStringMaybeAliased(2, _s, target);
  }

  switch (this_.topic_or_prefix_case()) {
    case kTopic: {
      const ::std::string& _s = this_._internal_topic();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.topic");
      target = stream->WriteStringMaybeAliased(3, _s, target);
      break;
    }
    case kPrefix: {
      const ::std::string& _s = this_._internal_prefix();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.prefix");
      target = stream->WriteStringMaybeAliased(4, _s, target);
      break;
    }
    default:
      break;
  }
  // optional string required_acks = 5 [json_name = "requiredAcks"];
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_required_acks();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.required_acks");
    target = stream->WriteStringMaybeAliased(5, _s, target);
  }

  // optional string compression = 6 [json_name = "compression"];
  if ((cached_has_bits & 0x00000008u) != 0) {
    const ::std::string& _s = this_._internal_compression();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.compression");
    target = stream->WriteStringMaybeAliased(6, _s, target);
  }

  // optional uint64 idle_timeout = 7 [json_name = "idleTimeout"];
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        7, this_._internal_idle_timeout(), target);
  }

  // optional uint64 send_timeout = 8 [json_name = "sendTimeout"];
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        8, this_._internal_send_timeout(), target);
  }

  // map<string, string> extra_kafka_opts = 20 [json_name = "extraKafkaOpts"];
  if (!this_._internal_extra_kafka_opts().empty()) {
    using MapType = ::google::protobuf::Map<std::string, std::string>;
    using WireHelper = _pbi::MapEntryFuncs<std::string, std::string,
                                   _pbi::WireFormatLite::TYPE_STRING,
                                   _pbi::WireFormatLite::TYPE_STRING>;
    const auto& field = this_._internal_extra_kafka_opts();

    if (stream->IsSerializationDeterministic() && field.size() > 1) {
      for (const auto& entry : ::google::protobuf::internal::MapSorterPtr<MapType>(field)) {
        target = WireHelper::InternalSerialize(
            20, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.extra_kafka_opts");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.extra_kafka_opts");
      }
    } else {
      for (const auto& entry : field) {
        target = WireHelper::InternalSerialize(
            20, entry.first, entry.second, target, stream);
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.first.data(), static_cast<int>(entry.first.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.extra_kafka_opts");
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            entry.second.data(), static_cast<int>(entry.second.length()),
 ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.KafkaHookOptions.extra_kafka_opts");
      }
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.KafkaHookOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t KafkaHookOptions::ByteSizeLong(const MessageLite& base) {
  const KafkaHookOptions& this_ = static_cast<const KafkaHookOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t KafkaHookOptions::ByteSizeLong() const {
  const KafkaHookOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.KafkaHookOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // map<string, string> extra_kafka_opts = 20 [json_name = "extraKafkaOpts"];
    {
      total_size +=
          2 * ::google::protobuf::internal::FromIntSize(this_._internal_extra_kafka_opts_size());
      for (const auto& entry : this_._internal_extra_kafka_opts()) {
        total_size += _pbi::MapEntryFuncs<std::string, std::string,
                                       _pbi::WireFormatLite::TYPE_STRING,
                                       _pbi::WireFormatLite::TYPE_STRING>::ByteSizeLong(entry.first, entry.second);
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    // optional string urls = 1 [json_name = "urls"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_urls());
    }
    // optional string client_id = 2 [json_name = "clientId"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_client_id());
    }
    // optional string required_acks = 5 [json_name = "requiredAcks"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_required_acks());
    }
    // optional string compression = 6 [json_name = "compression"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_compression());
    }
    // optional uint64 idle_timeout = 7 [json_name = "idleTimeout"];
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_idle_timeout());
    }
    // optional uint64 send_timeout = 8 [json_name = "sendTimeout"];
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_send_timeout());
    }
  }
  switch (this_.topic_or_prefix_case()) {
    // string topic = 3 [json_name = "topic"];
    case kTopic: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_topic());
      break;
    }
    // string prefix = 4 [json_name = "prefix"];
    case kPrefix: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_prefix());
      break;
    }
    case TOPIC_OR_PREFIX_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void KafkaHookOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<KafkaHookOptions*>(&to_msg);
  auto& from = static_cast<const KafkaHookOptions&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.KafkaHookOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.extra_kafka_opts_.MergeFrom(from._impl_.extra_kafka_opts_);
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000003fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_urls(from._internal_urls());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_client_id(from._internal_client_id());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_required_acks(from._internal_required_acks());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      _this->_internal_set_compression(from._internal_compression());
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      _this->_impl_.idle_timeout_ = from._impl_.idle_timeout_;
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      _this->_impl_.send_timeout_ = from._impl_.send_timeout_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_topic_or_prefix();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kTopic: {
        if (oneof_needs_init) {
          _this->_impl_.topic_or_prefix_.topic_.InitDefault();
        }
        _this->_impl_.topic_or_prefix_.topic_.Set(from._internal_topic(), arena);
        break;
      }
      case kPrefix: {
        if (oneof_needs_init) {
          _this->_impl_.topic_or_prefix_.prefix_.InitDefault();
        }
        _this->_impl_.topic_or_prefix_.prefix_.Set(from._internal_prefix(), arena);
        break;
      }
      case TOPIC_OR_PREFIX_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void KafkaHookOptions::CopyFrom(const KafkaHookOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.KafkaHookOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void KafkaHookOptions::InternalSwap(KafkaHookOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.extra_kafka_opts_.InternalSwap(&other->_impl_.extra_kafka_opts_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.urls_, &other->_impl_.urls_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.client_id_, &other->_impl_.client_id_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.required_acks_, &other->_impl_.required_acks_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.compression_, &other->_impl_.compression_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.send_timeout_)
      + sizeof(KafkaHookOptions::_impl_.send_timeout_)
      - PROTOBUF_FIELD_OFFSET(KafkaHookOptions, _impl_.idle_timeout_)>(
          reinterpret_cast<char*>(&_impl_.idle_timeout_),
          reinterpret_cast<char*>(&other->_impl_.idle_timeout_));
  swap(_impl_.topic_or_prefix_, other->_impl_.topic_or_prefix_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata KafkaHookOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NatsHookOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NatsHookOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
      PROTOBUF_FIELD_OFFSET(::uploader::v1::NatsHookOptions, _impl_._oneof_case_);
};

NatsHookOptions::NatsHookOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NatsHookOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.NatsHookOptions)
}
PROTOBUF_NDEBUG_INLINE NatsHookOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::NatsHookOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        urls_{visibility, arena, from.urls_},
        username_(arena, from.username_),
        password_(arena, from.password_),
        token_(arena, from.token_),
        subject_or_prefix_{},
        _oneof_case_{from._oneof_case_[0]} {}

NatsHookOptions::NatsHookOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NatsHookOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NatsHookOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NatsHookOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.wait_for_replies_ = from._impl_.wait_for_replies_;
  switch (subject_or_prefix_case()) {
    case SUBJECT_OR_PREFIX_NOT_SET:
      break;
      case kSubject:
        new (&_impl_.subject_or_prefix_.subject_) decltype(_impl_.subject_or_prefix_.subject_){arena, from._impl_.subject_or_prefix_.subject_};
        break;
      case kPrefix:
        new (&_impl_.subject_or_prefix_.prefix_) decltype(_impl_.subject_or_prefix_.prefix_){arena, from._impl_.subject_or_prefix_.prefix_};
        break;
  }

  // @@protoc_insertion_point(copy_constructor:uploader.v1.NatsHookOptions)
}
PROTOBUF_NDEBUG_INLINE NatsHookOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        urls_{visibility, arena},
        username_(arena),
        password_(arena),
        token_(arena),
        subject_or_prefix_{},
        _oneof_case_{} {}

inline void NatsHookOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.wait_for_replies_ = {};
}
NatsHookOptions::~NatsHookOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.NatsHookOptions)
  SharedDtor(*this);
}
inline void NatsHookOptions::SharedDtor(MessageLite& self) {
  NatsHookOptions& this_ = static_cast<NatsHookOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.username_.Destroy();
  this_._impl_.password_.Destroy();
  this_._impl_.token_.Destroy();
  if (this_.has_subject_or_prefix()) {
    this_.clear_subject_or_prefix();
  }
  this_._impl_.~Impl_();
}

void NatsHookOptions::clear_subject_or_prefix() {
// @@protoc_insertion_point(one_of_clear_start:uploader.v1.NatsHookOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  switch (subject_or_prefix_case()) {
    case kSubject: {
      _impl_.subject_or_prefix_.subject_.Destroy();
      break;
    }
    case kPrefix: {
      _impl_.subject_or_prefix_.prefix_.Destroy();
      break;
    }
    case SUBJECT_OR_PREFIX_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = SUBJECT_OR_PREFIX_NOT_SET;
}


inline void* PROTOBUF_NONNULL NatsHookOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NatsHookOptions(arena);
}
constexpr auto NatsHookOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.urls_) +
          decltype(NatsHookOptions::_impl_.urls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(NatsHookOptions), alignof(NatsHookOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&NatsHookOptions::PlacementNew_,
                                 sizeof(NatsHookOptions),
                                 alignof(NatsHookOptions));
  }
}
constexpr auto NatsHookOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NatsHookOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NatsHookOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NatsHookOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NatsHookOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NatsHookOptions>(), &NatsHookOptions::ByteSizeLong,
              &NatsHookOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_._cached_size_),
          false,
      },
      &NatsHookOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NatsHookOptions_class_data_ =
        NatsHookOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NatsHookOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NatsHookOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NatsHookOptions_class_data_.tc_table);
  return NatsHookOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<2, 7, 0, 74, 2>
NatsHookOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_._has_bits_),
    0, // no _extensions_
    12, 24,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294963696,  // skipmap
    offsetof(decltype(_table_), field_entries),
    7,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    NatsHookOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::NatsHookOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // bool wait_for_replies = 4 [json_name = "waitForReplies"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(NatsHookOptions, _impl_.wait_for_replies_), 3>(),
     {32, 3, 0, PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.wait_for_replies_)}},
    // repeated string urls = 1 [json_name = "urls"];
    {::_pbi::TcParser::FastUR1,
     {10, 63, 0, PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.urls_)}},
    // optional string username = 10 [json_name = "username"];
    {::_pbi::TcParser::FastUS1,
     {82, 0, 0, PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.username_)}},
    // optional string password = 11 [json_name = "password"];
    {::_pbi::TcParser::FastUS1,
     {90, 1, 0, PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.password_)}},
  }}, {{
    65535, 65535
  }}, {{
    // repeated string urls = 1 [json_name = "urls"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.urls_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // string subject = 2 [json_name = "subject"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.subject_or_prefix_.subject_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // string prefix = 3 [json_name = "prefix"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.subject_or_prefix_.prefix_), _Internal::kOneofCaseOffset + 0, 0,
    (0 | ::_fl::kFcOneof | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // bool wait_for_replies = 4 [json_name = "waitForReplies"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.wait_for_replies_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional string username = 10 [json_name = "username"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.username_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string password = 11 [json_name = "password"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.password_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string token = 12 [json_name = "token"];
    {PROTOBUF_FIELD_OFFSET(NatsHookOptions, _impl_.token_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
  }},
  // no aux_entries
  {{
    "\33\4\7\6\0\10\10\5"
    "uploader.v1.NatsHookOptions"
    "urls"
    "subject"
    "prefix"
    "username"
    "password"
    "token"
  }},
};
PROTOBUF_NOINLINE void NatsHookOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.NatsHookOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.urls_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000007u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.username_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.password_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
  }
  _impl_.wait_for_replies_ = false;
  clear_subject_or_prefix();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NatsHookOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NatsHookOptions& this_ = static_cast<const NatsHookOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NatsHookOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NatsHookOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.NatsHookOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // repeated string urls = 1 [json_name = "urls"];
  for (int i = 0, n = this_._internal_urls_size(); i < n; ++i) {
    const auto& s = this_._internal_urls().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NatsHookOptions.urls");
    target = stream->WriteString(1, s, target);
  }

  switch (this_.subject_or_prefix_case()) {
    case kSubject: {
      const ::std::string& _s = this_._internal_subject();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NatsHookOptions.subject");
      target = stream->WriteStringMaybeAliased(2, _s, target);
      break;
    }
    case kPrefix: {
      const ::std::string& _s = this_._internal_prefix();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NatsHookOptions.prefix");
      target = stream->WriteStringMaybeAliased(3, _s, target);
      break;
    }
    default:
      break;
  }
  // bool wait_for_replies = 4 [json_name = "waitForReplies"];
  if ((this_._impl_._has_bits_[0] & 0x00000008u) != 0) {
    if (this_._internal_wait_for_replies() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          4, this_._internal_wait_for_replies(), target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string username = 10 [json_name = "username"];
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_username();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NatsHookOptions.username");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // optional string password = 11 [json_name = "password"];
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_password();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NatsHookOptions.password");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // optional string token = 12 [json_name = "token"];
  if ((cached_has_bits & 0x00000004u) != 0) {
    const ::std::string& _s = this_._internal_token();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NatsHookOptions.token");
    target = stream->WriteStringMaybeAliased(12, _s, target);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.NatsHookOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NatsHookOptions::ByteSizeLong(const MessageLite& base) {
  const NatsHookOptions& this_ = static_cast<const NatsHookOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NatsHookOptions::ByteSizeLong() const {
  const NatsHookOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.NatsHookOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string urls = 1 [json_name = "urls"];
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_urls().size());
      for (int i = 0, n = this_._internal_urls().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_urls().Get(i));
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    // optional string username = 10 [json_name = "username"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_username());
    }
    // optional string password = 11 [json_name = "password"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_password());
    }
    // optional string token = 12 [json_name = "token"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_token());
    }
    // bool wait_for_replies = 4 [json_name = "waitForReplies"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (this_._internal_wait_for_replies() != 0) {
        total_size += 2;
      }
    }
  }
  switch (this_.subject_or_prefix_case()) {
    // string subject = 2 [json_name = "subject"];
    case kSubject: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_subject());
      break;
    }
    // string prefix = 3 [json_name = "prefix"];
    case kPrefix: {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_prefix());
      break;
    }
    case SUBJECT_OR_PREFIX_NOT_SET: {
      break;
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NatsHookOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<NatsHookOptions*>(&to_msg);
  auto& from = static_cast<const NatsHookOptions&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.NatsHookOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_urls()->MergeFrom(from._internal_urls());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000000fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_username(from._internal_username());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_password(from._internal_password());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _this->_internal_set_token(from._internal_token());
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      if (from._internal_wait_for_replies() != 0) {
        _this->_impl_.wait_for_replies_ = from._impl_.wait_for_replies_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  if (const uint32_t oneof_from_case = from._impl_._oneof_case_[0]) {
    const uint32_t oneof_to_case = _this->_impl_._oneof_case_[0];
    const bool oneof_needs_init = oneof_to_case != oneof_from_case;
    if (oneof_needs_init) {
      if (oneof_to_case != 0) {
        _this->clear_subject_or_prefix();
      }
      _this->_impl_._oneof_case_[0] = oneof_from_case;
    }

    switch (oneof_from_case) {
      case kSubject: {
        if (oneof_needs_init) {
          _this->_impl_.subject_or_prefix_.subject_.InitDefault();
        }
        _this->_impl_.subject_or_prefix_.subject_.Set(from._internal_subject(), arena);
        break;
      }
      case kPrefix: {
        if (oneof_needs_init) {
          _this->_impl_.subject_or_prefix_.prefix_.InitDefault();
        }
        _this->_impl_.subject_or_prefix_.prefix_.Set(from._internal_prefix(), arena);
        break;
      }
      case SUBJECT_OR_PREFIX_NOT_SET:
        break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NatsHookOptions::CopyFrom(const NatsHookOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.NatsHookOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NatsHookOptions::InternalSwap(NatsHookOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.urls_.InternalSwap(&other->_impl_.urls_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.username_, &other->_impl_.username_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.password_, &other->_impl_.password_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.token_, &other->_impl_.token_, arena);
  swap(_impl_.wait_for_replies_, other->_impl_.wait_for_replies_);
  swap(_impl_.subject_or_prefix_, other->_impl_.subject_or_prefix_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::google::protobuf::Metadata NatsHookOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class NotificationsOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<NotificationsOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_._has_bits_);
};

NotificationsOptions::NotificationsOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NotificationsOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.NotificationsOptions)
}
PROTOBUF_NDEBUG_INLINE NotificationsOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::NotificationsOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        hooks_{visibility, arena, from.hooks_},
        _hooks_cached_byte_size_{0},
        hooks_http_urls_{visibility, arena, from.hooks_http_urls_},
        hooks_http_proxy_headers_{visibility, arena, from.hooks_http_proxy_headers_},
        hooks_dir_(arena, from.hooks_dir_),
        hooks_file_(arena, from.hooks_file_) {}

NotificationsOptions::NotificationsOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const NotificationsOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, NotificationsOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  NotificationsOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.amqp_hook_opts_ = ((cached_has_bits & 0x00000004u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.amqp_hook_opts_)
                : nullptr;
  _impl_.kafka_hook_opts_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.kafka_hook_opts_)
                : nullptr;
  _impl_.nats_hook_opts_ = ((cached_has_bits & 0x00000010u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.nats_hook_opts_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, hooks_format_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, hooks_format_),
           offsetof(Impl_, http_hook_timeout_) -
               offsetof(Impl_, hooks_format_) +
               sizeof(Impl_::http_hook_timeout_));

  // @@protoc_insertion_point(copy_constructor:uploader.v1.NotificationsOptions)
}
PROTOBUF_NDEBUG_INLINE NotificationsOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        hooks_{visibility, arena},
        _hooks_cached_byte_size_{0},
        hooks_http_urls_{visibility, arena},
        hooks_http_proxy_headers_{visibility, arena},
        hooks_dir_(arena),
        hooks_file_(arena) {}

inline void NotificationsOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, amqp_hook_opts_),
           0,
           offsetof(Impl_, http_hook_timeout_) -
               offsetof(Impl_, amqp_hook_opts_) +
               sizeof(Impl_::http_hook_timeout_));
}
NotificationsOptions::~NotificationsOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.NotificationsOptions)
  SharedDtor(*this);
}
inline void NotificationsOptions::SharedDtor(MessageLite& self) {
  NotificationsOptions& this_ = static_cast<NotificationsOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.hooks_dir_.Destroy();
  this_._impl_.hooks_file_.Destroy();
  delete this_._impl_.amqp_hook_opts_;
  delete this_._impl_.kafka_hook_opts_;
  delete this_._impl_.nats_hook_opts_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL NotificationsOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) NotificationsOptions(arena);
}
constexpr auto NotificationsOptions::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_) +
          decltype(NotificationsOptions::_impl_.hooks_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_http_urls_) +
          decltype(NotificationsOptions::_impl_.hooks_http_urls_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_http_proxy_headers_) +
          decltype(NotificationsOptions::_impl_.hooks_http_proxy_headers_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(NotificationsOptions), alignof(NotificationsOptions), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&NotificationsOptions::PlacementNew_,
                                 sizeof(NotificationsOptions),
                                 alignof(NotificationsOptions));
  }
}
constexpr auto NotificationsOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_NotificationsOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &NotificationsOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<NotificationsOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &NotificationsOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<NotificationsOptions>(), &NotificationsOptions::ByteSizeLong,
              &NotificationsOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_._cached_size_),
          false,
      },
      &NotificationsOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull NotificationsOptions_class_data_ =
        NotificationsOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
NotificationsOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&NotificationsOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(NotificationsOptions_class_data_.tc_table);
  return NotificationsOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<4, 11, 3, 107, 2>
NotificationsOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_._has_bits_),
    0, // no _extensions_
    22, 120,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4291295680,  // skipmap
    offsetof(decltype(_table_), field_entries),
    11,  // num_field_entries
    3,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    NotificationsOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::NotificationsOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // .uploader.v1.Format hooks_format = 1 [json_name = "hooksFormat"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(NotificationsOptions, _impl_.hooks_format_), 5>(),
     {8, 5, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_format_)}},
    // repeated .uploader.v1.Hook hooks = 2 [json_name = "hooks"];
    {::_pbi::TcParser::FastV32P1,
     {18, 63, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_)}},
    // bool behind_proxy = 3 [json_name = "behindProxy"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(NotificationsOptions, _impl_.behind_proxy_), 6>(),
     {24, 6, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.behind_proxy_)}},
    // repeated string hooks_http_urls = 4 [json_name = "hooksHttpUrls"];
    {::_pbi::TcParser::FastUR1,
     {34, 63, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_http_urls_)}},
    // optional uint64 http_hook_timeout = 5 [json_name = "httpHookTimeout"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(NotificationsOptions, _impl_.http_hook_timeout_), 7>(),
     {40, 7, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.http_hook_timeout_)}},
    // repeated string hooks_http_proxy_headers = 6 [json_name = "hooksHttpProxyHeaders"];
    {::_pbi::TcParser::FastUR1,
     {50, 63, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_http_proxy_headers_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // optional string hooks_dir = 10 [json_name = "hooksDir"];
    {::_pbi::TcParser::FastUS1,
     {82, 0, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_dir_)}},
    // optional string hooks_file = 11 [json_name = "hooksFile"];
    {::_pbi::TcParser::FastUS1,
     {90, 1, 0, PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_file_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // .uploader.v1.Format hooks_format = 1 [json_name = "hooksFormat"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_format_), _Internal::kHasBitsOffset + 5, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kOpenEnum)},
    // repeated .uploader.v1.Hook hooks = 2 [json_name = "hooks"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // bool behind_proxy = 3 [json_name = "behindProxy"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.behind_proxy_), _Internal::kHasBitsOffset + 6, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // repeated string hooks_http_urls = 4 [json_name = "hooksHttpUrls"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_http_urls_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // optional uint64 http_hook_timeout = 5 [json_name = "httpHookTimeout"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.http_hook_timeout_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated string hooks_http_proxy_headers = 6 [json_name = "hooksHttpProxyHeaders"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_http_proxy_headers_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // optional string hooks_dir = 10 [json_name = "hooksDir"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_dir_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional string hooks_file = 11 [json_name = "hooksFile"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.hooks_file_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // .uploader.v1.AMQPHooksOptions amqp_hook_opts = 20 [json_name = "amqpHookOpts"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.amqp_hook_opts_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .uploader.v1.KafkaHookOptions kafka_hook_opts = 21 [json_name = "kafkaHookOpts"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.kafka_hook_opts_), _Internal::kHasBitsOffset + 3, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .uploader.v1.NatsHookOptions nats_hook_opts = 22 [json_name = "natsHookOpts"];
    {PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.nats_hook_opts_), _Internal::kHasBitsOffset + 4, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::uploader::v1::AMQPHooksOptions>()},
      {::_pbi::TcParser::GetTable<::uploader::v1::KafkaHookOptions>()},
      {::_pbi::TcParser::GetTable<::uploader::v1::NatsHookOptions>()},
  }},
  {{
    "\40\0\0\0\17\0\30\11\12\0\0\0\0\0\0\0"
    "uploader.v1.NotificationsOptions"
    "hooks_http_urls"
    "hooks_http_proxy_headers"
    "hooks_dir"
    "hooks_file"
  }},
};
PROTOBUF_NOINLINE void NotificationsOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.NotificationsOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hooks_.Clear();
  _impl_.hooks_http_urls_.Clear();
  _impl_.hooks_http_proxy_headers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000001fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.hooks_dir_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.hooks_file_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(_impl_.amqp_hook_opts_ != nullptr);
      _impl_.amqp_hook_opts_->Clear();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.kafka_hook_opts_ != nullptr);
      _impl_.kafka_hook_opts_->Clear();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(_impl_.nats_hook_opts_ != nullptr);
      _impl_.nats_hook_opts_->Clear();
    }
  }
  if ((cached_has_bits & 0x000000e0u) != 0) {
    ::memset(&_impl_.hooks_format_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.http_hook_timeout_) -
        reinterpret_cast<char*>(&_impl_.hooks_format_)) + sizeof(_impl_.http_hook_timeout_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL NotificationsOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const NotificationsOptions& this_ = static_cast<const NotificationsOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL NotificationsOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const NotificationsOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.NotificationsOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // .uploader.v1.Format hooks_format = 1 [json_name = "hooksFormat"];
  if ((this_._impl_._has_bits_[0] & 0x00000020u) != 0) {
    if (this_._internal_hooks_format() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteEnumToArray(
          1, this_._internal_hooks_format(), target);
    }
  }

  // repeated .uploader.v1.Hook hooks = 2 [json_name = "hooks"];
  {
    ::size_t byte_size = this_._impl_._hooks_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, this_._internal_hooks(), byte_size, target);
    }
  }

  // bool behind_proxy = 3 [json_name = "behindProxy"];
  if ((this_._impl_._has_bits_[0] & 0x00000040u) != 0) {
    if (this_._internal_behind_proxy() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_behind_proxy(), target);
    }
  }

  // repeated string hooks_http_urls = 4 [json_name = "hooksHttpUrls"];
  for (int i = 0, n = this_._internal_hooks_http_urls_size(); i < n; ++i) {
    const auto& s = this_._internal_hooks_http_urls().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NotificationsOptions.hooks_http_urls");
    target = stream->WriteString(4, s, target);
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 http_hook_timeout = 5 [json_name = "httpHookTimeout"];
  if ((cached_has_bits & 0x00000080u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this_._internal_http_hook_timeout(), target);
  }

  // repeated string hooks_http_proxy_headers = 6 [json_name = "hooksHttpProxyHeaders"];
  for (int i = 0, n = this_._internal_hooks_http_proxy_headers_size(); i < n; ++i) {
    const auto& s = this_._internal_hooks_http_proxy_headers().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NotificationsOptions.hooks_http_proxy_headers");
    target = stream->WriteString(6, s, target);
  }

  // optional string hooks_dir = 10 [json_name = "hooksDir"];
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_hooks_dir();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NotificationsOptions.hooks_dir");
    target = stream->WriteStringMaybeAliased(10, _s, target);
  }

  // optional string hooks_file = 11 [json_name = "hooksFile"];
  if ((cached_has_bits & 0x00000002u) != 0) {
    const ::std::string& _s = this_._internal_hooks_file();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.NotificationsOptions.hooks_file");
    target = stream->WriteStringMaybeAliased(11, _s, target);
  }

  // .uploader.v1.AMQPHooksOptions amqp_hook_opts = 20 [json_name = "amqpHookOpts"];
  if ((cached_has_bits & 0x00000004u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        20, *this_._impl_.amqp_hook_opts_, this_._impl_.amqp_hook_opts_->GetCachedSize(), target,
        stream);
  }

  // .uploader.v1.KafkaHookOptions kafka_hook_opts = 21 [json_name = "kafkaHookOpts"];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        21, *this_._impl_.kafka_hook_opts_, this_._impl_.kafka_hook_opts_->GetCachedSize(), target,
        stream);
  }

  // .uploader.v1.NatsHookOptions nats_hook_opts = 22 [json_name = "natsHookOpts"];
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        22, *this_._impl_.nats_hook_opts_, this_._impl_.nats_hook_opts_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.NotificationsOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t NotificationsOptions::ByteSizeLong(const MessageLite& base) {
  const NotificationsOptions& this_ = static_cast<const NotificationsOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t NotificationsOptions::ByteSizeLong() const {
  const NotificationsOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.NotificationsOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated .uploader.v1.Hook hooks = 2 [json_name = "hooks"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_hooks(), 1, this_._impl_._hooks_cached_byte_size_);
    }
    // repeated string hooks_http_urls = 4 [json_name = "hooksHttpUrls"];
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_hooks_http_urls().size());
      for (int i = 0, n = this_._internal_hooks_http_urls().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_hooks_http_urls().Get(i));
      }
    }
    // repeated string hooks_http_proxy_headers = 6 [json_name = "hooksHttpProxyHeaders"];
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_hooks_http_proxy_headers().size());
      for (int i = 0, n = this_._internal_hooks_http_proxy_headers().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_hooks_http_proxy_headers().Get(i));
      }
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // optional string hooks_dir = 10 [json_name = "hooksDir"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_hooks_dir());
    }
    // optional string hooks_file = 11 [json_name = "hooksFile"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_hooks_file());
    }
    // .uploader.v1.AMQPHooksOptions amqp_hook_opts = 20 [json_name = "amqpHookOpts"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.amqp_hook_opts_);
    }
    // .uploader.v1.KafkaHookOptions kafka_hook_opts = 21 [json_name = "kafkaHookOpts"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.kafka_hook_opts_);
    }
    // .uploader.v1.NatsHookOptions nats_hook_opts = 22 [json_name = "natsHookOpts"];
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.nats_hook_opts_);
    }
    // .uploader.v1.Format hooks_format = 1 [json_name = "hooksFormat"];
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (this_._internal_hooks_format() != 0) {
        total_size += 1 +
                      ::_pbi::WireFormatLite::EnumSize(this_._internal_hooks_format());
      }
    }
    // bool behind_proxy = 3 [json_name = "behindProxy"];
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (this_._internal_behind_proxy() != 0) {
        total_size += 2;
      }
    }
    // optional uint64 http_hook_timeout = 5 [json_name = "httpHookTimeout"];
    if ((cached_has_bits & 0x00000080u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_http_hook_timeout());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void NotificationsOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<NotificationsOptions*>(&to_msg);
  auto& from = static_cast<const NotificationsOptions&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.NotificationsOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_hooks()->MergeFrom(from._internal_hooks());
  _this->_internal_mutable_hooks_http_urls()->MergeFrom(from._internal_hooks_http_urls());
  _this->_internal_mutable_hooks_http_proxy_headers()->MergeFrom(from._internal_hooks_http_proxy_headers());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_hooks_dir(from._internal_hooks_dir());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _this->_internal_set_hooks_file(from._internal_hooks_file());
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      ABSL_DCHECK(from._impl_.amqp_hook_opts_ != nullptr);
      if (_this->_impl_.amqp_hook_opts_ == nullptr) {
        _this->_impl_.amqp_hook_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.amqp_hook_opts_);
      } else {
        _this->_impl_.amqp_hook_opts_->MergeFrom(*from._impl_.amqp_hook_opts_);
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.kafka_hook_opts_ != nullptr);
      if (_this->_impl_.kafka_hook_opts_ == nullptr) {
        _this->_impl_.kafka_hook_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.kafka_hook_opts_);
      } else {
        _this->_impl_.kafka_hook_opts_->MergeFrom(*from._impl_.kafka_hook_opts_);
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(from._impl_.nats_hook_opts_ != nullptr);
      if (_this->_impl_.nats_hook_opts_ == nullptr) {
        _this->_impl_.nats_hook_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.nats_hook_opts_);
      } else {
        _this->_impl_.nats_hook_opts_->MergeFrom(*from._impl_.nats_hook_opts_);
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      if (from._internal_hooks_format() != 0) {
        _this->_impl_.hooks_format_ = from._impl_.hooks_format_;
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      if (from._internal_behind_proxy() != 0) {
        _this->_impl_.behind_proxy_ = from._impl_.behind_proxy_;
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      _this->_impl_.http_hook_timeout_ = from._impl_.http_hook_timeout_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void NotificationsOptions::CopyFrom(const NotificationsOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.NotificationsOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void NotificationsOptions::InternalSwap(NotificationsOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.hooks_.InternalSwap(&other->_impl_.hooks_);
  _impl_.hooks_http_urls_.InternalSwap(&other->_impl_.hooks_http_urls_);
  _impl_.hooks_http_proxy_headers_.InternalSwap(&other->_impl_.hooks_http_proxy_headers_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hooks_dir_, &other->_impl_.hooks_dir_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.hooks_file_, &other->_impl_.hooks_file_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.http_hook_timeout_)
      + sizeof(NotificationsOptions::_impl_.http_hook_timeout_)
      - PROTOBUF_FIELD_OFFSET(NotificationsOptions, _impl_.amqp_hook_opts_)>(
          reinterpret_cast<char*>(&_impl_.amqp_hook_opts_),
          reinterpret_cast<char*>(&other->_impl_.amqp_hook_opts_));
}

::google::protobuf::Metadata NotificationsOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class SentryOptions::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<SentryOptions>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_._has_bits_);
};

SentryOptions::SentryOptions(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SentryOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.SentryOptions)
}
PROTOBUF_NDEBUG_INLINE SentryOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::SentryOptions& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        dsn_(arena, from.dsn_) {}

SentryOptions::SentryOptions(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const SentryOptions& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, SentryOptions_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SentryOptions* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  _impl_.sample_rate_ = from._impl_.sample_rate_;

  // @@protoc_insertion_point(copy_constructor:uploader.v1.SentryOptions)
}
PROTOBUF_NDEBUG_INLINE SentryOptions::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        dsn_(arena) {}

inline void SentryOptions::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  _impl_.sample_rate_ = {};
}
SentryOptions::~SentryOptions() {
  // @@protoc_insertion_point(destructor:uploader.v1.SentryOptions)
  SharedDtor(*this);
}
inline void SentryOptions::SharedDtor(MessageLite& self) {
  SentryOptions& this_ = static_cast<SentryOptions&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.dsn_.Destroy();
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL SentryOptions::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) SentryOptions(arena);
}
constexpr auto SentryOptions::InternalNewImpl_() {
  return ::google::protobuf::internal::MessageCreator::CopyInit(sizeof(SentryOptions),
                                            alignof(SentryOptions));
}
constexpr auto SentryOptions::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_SentryOptions_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &SentryOptions::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<SentryOptions>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &SentryOptions::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<SentryOptions>(), &SentryOptions::ByteSizeLong,
              &SentryOptions::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_._cached_size_),
          false,
      },
      &SentryOptions::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull SentryOptions_class_data_ =
        SentryOptions::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
SentryOptions::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&SentryOptions_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(SentryOptions_class_data_.tc_table);
  return SentryOptions_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<1, 2, 0, 37, 2>
SentryOptions::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_._has_bits_),
    0, // no _extensions_
    2, 8,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4294967292,  // skipmap
    offsetof(decltype(_table_), field_entries),
    2,  // num_field_entries
    0,  // num_aux_entries
    offsetof(decltype(_table_), field_names),  // no aux_entries
    SentryOptions_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::SentryOptions>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    // float sample_rate = 2 [json_name = "sampleRate"];
    {::_pbi::TcParser::FastF32S1,
     {21, 1, 0, PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_.sample_rate_)}},
    // optional string dsn = 1 [json_name = "dsn"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_.dsn_)}},
  }}, {{
    65535, 65535
  }}, {{
    // optional string dsn = 1 [json_name = "dsn"];
    {PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_.dsn_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // float sample_rate = 2 [json_name = "sampleRate"];
    {PROTOBUF_FIELD_OFFSET(SentryOptions, _impl_.sample_rate_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kFloat)},
  }},
  // no aux_entries
  {{
    "\31\3\0\0\0\0\0\0"
    "uploader.v1.SentryOptions"
    "dsn"
  }},
};
PROTOBUF_NOINLINE void SentryOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.SentryOptions)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000001u) != 0) {
    _impl_.dsn_.ClearNonDefaultToEmpty();
  }
  _impl_.sample_rate_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL SentryOptions::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const SentryOptions& this_ = static_cast<const SentryOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL SentryOptions::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const SentryOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.SentryOptions)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional string dsn = 1 [json_name = "dsn"];
  if ((cached_has_bits & 0x00000001u) != 0) {
    const ::std::string& _s = this_._internal_dsn();
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.SentryOptions.dsn");
    target = stream->WriteStringMaybeAliased(1, _s, target);
  }

  // float sample_rate = 2 [json_name = "sampleRate"];
  if ((cached_has_bits & 0x00000002u) != 0) {
    if (::absl::bit_cast<::uint32_t>(this_._internal_sample_rate()) != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteFloatToArray(
          2, this_._internal_sample_rate(), target);
    }
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.SentryOptions)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t SentryOptions::ByteSizeLong(const MessageLite& base) {
  const SentryOptions& this_ = static_cast<const SentryOptions&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t SentryOptions::ByteSizeLong() const {
  const SentryOptions& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.SentryOptions)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    // optional string dsn = 1 [json_name = "dsn"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                      this_._internal_dsn());
    }
    // float sample_rate = 2 [json_name = "sampleRate"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (::absl::bit_cast<::uint32_t>(this_._internal_sample_rate()) != 0) {
        total_size += 5;
      }
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void SentryOptions::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<SentryOptions*>(&to_msg);
  auto& from = static_cast<const SentryOptions&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.SentryOptions)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x00000003u) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _this->_internal_set_dsn(from._internal_dsn());
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (::absl::bit_cast<::uint32_t>(from._internal_sample_rate()) != 0) {
        _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
      }
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void SentryOptions::CopyFrom(const SentryOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.SentryOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void SentryOptions::InternalSwap(SentryOptions* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.dsn_, &other->_impl_.dsn_, arena);
  swap(_impl_.sample_rate_, other->_impl_.sample_rate_);
}

::google::protobuf::Metadata SentryOptions::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// ===================================================================

class RustusConf::_Internal {
 public:
  using HasBits =
      decltype(::std::declval<RustusConf>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
      8 * PROTOBUF_FIELD_OFFSET(RustusConf, _impl_._has_bits_);
};

RustusConf::RustusConf(::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RustusConf_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:uploader.v1.RustusConf)
}
PROTOBUF_NDEBUG_INLINE RustusConf::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena, const Impl_& from,
    const ::uploader::v1::RustusConf& from_msg)
      : _has_bits_{from._has_bits_},
        _cached_size_{0},
        cors_{visibility, arena, from.cors_},
        tus_extensions_{visibility, arena, from.tus_extensions_},
        _tus_extensions_cached_byte_size_{0},
        host_(arena, from.host_),
        url_(arena, from.url_),
        log_level_(arena, from.log_level_) {}

RustusConf::RustusConf(
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena,
    const RustusConf& from)
#if defined(PROTOBUF_CUSTOM_VTABLE)
    : ::google::protobuf::Message(arena, RustusConf_class_data_.base()) {
#else   // PROTOBUF_CUSTOM_VTABLE
    : ::google::protobuf::Message(arena) {
#endif  // PROTOBUF_CUSTOM_VTABLE
  RustusConf* const _this = this;
  (void)_this;
  _internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(
      from._internal_metadata_);
  new (&_impl_) Impl_(internal_visibility(), arena, from._impl_, from);
  ::uint32_t cached_has_bits = _impl_._has_bits_[0];
  _impl_.storage_opts_ = ((cached_has_bits & 0x00000008u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.storage_opts_)
                : nullptr;
  _impl_.info_storage_opts_ = ((cached_has_bits & 0x00000010u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.info_storage_opts_)
                : nullptr;
  _impl_.notification_opts_ = ((cached_has_bits & 0x00000020u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.notification_opts_)
                : nullptr;
  _impl_.sentry_opts_ = ((cached_has_bits & 0x00000040u) != 0)
                ? ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.sentry_opts_)
                : nullptr;
  ::memcpy(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, port_),
           reinterpret_cast<const char *>(&from._impl_) +
               offsetof(Impl_, port_),
           offsetof(Impl_, max_file_size_) -
               offsetof(Impl_, port_) +
               sizeof(Impl_::max_file_size_));

  // @@protoc_insertion_point(copy_constructor:uploader.v1.RustusConf)
}
PROTOBUF_NDEBUG_INLINE RustusConf::Impl_::Impl_(
    ::google::protobuf::internal::InternalVisibility visibility,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena)
      : _cached_size_{0},
        cors_{visibility, arena},
        tus_extensions_{visibility, arena},
        _tus_extensions_cached_byte_size_{0},
        host_(arena),
        url_(arena),
        log_level_(arena) {}

inline void RustusConf::SharedCtor(::_pb::Arena* PROTOBUF_NULLABLE arena) {
  new (&_impl_) Impl_(internal_visibility(), arena);
  ::memset(reinterpret_cast<char *>(&_impl_) +
               offsetof(Impl_, storage_opts_),
           0,
           offsetof(Impl_, max_file_size_) -
               offsetof(Impl_, storage_opts_) +
               sizeof(Impl_::max_file_size_));
}
RustusConf::~RustusConf() {
  // @@protoc_insertion_point(destructor:uploader.v1.RustusConf)
  SharedDtor(*this);
}
inline void RustusConf::SharedDtor(MessageLite& self) {
  RustusConf& this_ = static_cast<RustusConf&>(self);
  this_._internal_metadata_.Delete<::google::protobuf::UnknownFieldSet>();
  ABSL_DCHECK(this_.GetArena() == nullptr);
  this_._impl_.host_.Destroy();
  this_._impl_.url_.Destroy();
  this_._impl_.log_level_.Destroy();
  delete this_._impl_.storage_opts_;
  delete this_._impl_.info_storage_opts_;
  delete this_._impl_.notification_opts_;
  delete this_._impl_.sentry_opts_;
  this_._impl_.~Impl_();
}

inline void* PROTOBUF_NONNULL RustusConf::PlacementNew_(
    const void* PROTOBUF_NONNULL, void* PROTOBUF_NONNULL mem,
    ::google::protobuf::Arena* PROTOBUF_NULLABLE arena) {
  return ::new (mem) RustusConf(arena);
}
constexpr auto RustusConf::InternalNewImpl_() {
  constexpr auto arena_bits = ::google::protobuf::internal::EncodePlacementArenaOffsets({
      PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.cors_) +
          decltype(RustusConf::_impl_.cors_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
      PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.tus_extensions_) +
          decltype(RustusConf::_impl_.tus_extensions_)::
              InternalGetArenaOffset(
                  ::google::protobuf::Message::internal_visibility()),
  });
  if (arena_bits.has_value()) {
    return ::google::protobuf::internal::MessageCreator::CopyInit(
        sizeof(RustusConf), alignof(RustusConf), *arena_bits);
  } else {
    return ::google::protobuf::internal::MessageCreator(&RustusConf::PlacementNew_,
                                 sizeof(RustusConf),
                                 alignof(RustusConf));
  }
}
constexpr auto RustusConf::InternalGenerateClassData_() {
  return ::google::protobuf::internal::ClassDataFull{
      ::google::protobuf::internal::ClassData{
          &_RustusConf_default_instance_._instance,
          &_table_.header,
          nullptr,  // OnDemandRegisterArenaDtor
          nullptr,  // IsInitialized
          &RustusConf::MergeImpl,
          ::google::protobuf::Message::GetNewImpl<RustusConf>(),
#if defined(PROTOBUF_CUSTOM_VTABLE)
          &RustusConf::SharedDtor,
          ::google::protobuf::Message::GetClearImpl<RustusConf>(), &RustusConf::ByteSizeLong,
              &RustusConf::_InternalSerialize,
#endif  // PROTOBUF_CUSTOM_VTABLE
          PROTOBUF_FIELD_OFFSET(RustusConf, _impl_._cached_size_),
          false,
      },
      &RustusConf::kDescriptorMethods,
      &descriptor_table_uploader_2fv1_2fconfig_2eproto,
      nullptr,  // tracker
  };
}

PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 const
    ::google::protobuf::internal::ClassDataFull RustusConf_class_data_ =
        RustusConf::InternalGenerateClassData_();

PROTOBUF_ATTRIBUTE_WEAK const ::google::protobuf::internal::ClassData* PROTOBUF_NONNULL
RustusConf::GetClassData() const {
  ::google::protobuf::internal::PrefetchToLocalCache(&RustusConf_class_data_);
  ::google::protobuf::internal::PrefetchToLocalCache(RustusConf_class_data_.tc_table);
  return RustusConf_class_data_.base();
}
PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1
const ::_pbi::TcParseTable<5, 16, 4, 67, 2>
RustusConf::_table_ = {
  {
    PROTOBUF_FIELD_OFFSET(RustusConf, _impl_._has_bits_),
    0, // no _extensions_
    23, 248,  // max_field_number, fast_idx_mask
    offsetof(decltype(_table_), field_lookup_table),
    4286972400,  // skipmap
    offsetof(decltype(_table_), field_entries),
    16,  // num_field_entries
    4,  // num_aux_entries
    offsetof(decltype(_table_), aux_entries),
    RustusConf_class_data_.base(),
    nullptr,  // post_loop_handler
    ::_pbi::TcParser::GenericFallback,  // fallback
    #ifdef PROTOBUF_PREFETCH_PARSE_TABLE
    ::_pbi::TcParser::GetTable<::uploader::v1::RustusConf>(),  // to_prefetch
    #endif  // PROTOBUF_PREFETCH_PARSE_TABLE
  }, {{
    {::_pbi::TcParser::MiniParse, {}},
    // string host = 1 [json_name = "host"];
    {::_pbi::TcParser::FastUS1,
     {10, 0, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.host_)}},
    // uint32 port = 2 [json_name = "port"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint32_t, offsetof(RustusConf, _impl_.port_), 7>(),
     {16, 7, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.port_)}},
    // bool disable_health_access_log = 3 [json_name = "disableHealthAccessLog"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(RustusConf, _impl_.disable_health_access_log_), 8>(),
     {24, 8, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.disable_health_access_log_)}},
    // string url = 4 [json_name = "url"];
    {::_pbi::TcParser::FastUS1,
     {34, 1, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.url_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // repeated string cors = 10 [json_name = "cors"];
    {::_pbi::TcParser::FastUR1,
     {82, 63, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.cors_)}},
    // uint64 max_body_size = 11 [json_name = "maxBodySize"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RustusConf, _impl_.max_body_size_), 11>(),
     {88, 11, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.max_body_size_)}},
    // string log_level = 12 [json_name = "logLevel"];
    {::_pbi::TcParser::FastUS1,
     {98, 2, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.log_level_)}},
    // optional uint64 workers = 13 [json_name = "workers"];
    {::_pbi::TcParser::SingularVarintNoZag1<::uint64_t, offsetof(RustusConf, _impl_.workers_), 12>(),
     {104, 12, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.workers_)}},
    // repeated .uploader.v1.Extension tus_extensions = 14 [json_name = "tusExtensions"];
    {::_pbi::TcParser::FastV32P1,
     {114, 63, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.tus_extensions_)}},
    // bool allow_empty = 15 [json_name = "allowEmpty"];
    {::_pbi::TcParser::SingularVarintNoZag1<bool, offsetof(RustusConf, _impl_.allow_empty_), 9>(),
     {120, 9, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.allow_empty_)}},
    // bool remove_parts = 16 [json_name = "removeParts"];
    {::_pbi::TcParser::FastV8S2,
     {384, 10, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.remove_parts_)}},
    // optional uint64 max_file_size = 17 [json_name = "maxFileSize"];
    {::_pbi::TcParser::FastV64S2,
     {392, 13, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.max_file_size_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    // .uploader.v1.DataStorageOptions storage_opts = 20 [json_name = "storageOpts"];
    {::_pbi::TcParser::FastMtS2,
     {418, 3, 0, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.storage_opts_)}},
    // .uploader.v1.InfoStoreOptions info_storage_opts = 21 [json_name = "infoStorageOpts"];
    {::_pbi::TcParser::FastMtS2,
     {426, 4, 1, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.info_storage_opts_)}},
    // .uploader.v1.NotificationsOptions notification_opts = 22 [json_name = "notificationOpts"];
    {::_pbi::TcParser::FastMtS2,
     {434, 5, 2, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.notification_opts_)}},
    // .uploader.v1.SentryOptions sentry_opts = 23 [json_name = "sentryOpts"];
    {::_pbi::TcParser::FastMtS2,
     {442, 6, 3, PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.sentry_opts_)}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
    {::_pbi::TcParser::MiniParse, {}},
  }}, {{
    65535, 65535
  }}, {{
    // string host = 1 [json_name = "host"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.host_), _Internal::kHasBitsOffset + 0, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // uint32 port = 2 [json_name = "port"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.port_), _Internal::kHasBitsOffset + 7, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt32)},
    // bool disable_health_access_log = 3 [json_name = "disableHealthAccessLog"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.disable_health_access_log_), _Internal::kHasBitsOffset + 8, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // string url = 4 [json_name = "url"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.url_), _Internal::kHasBitsOffset + 1, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // repeated string cors = 10 [json_name = "cors"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.cors_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kUtf8String | ::_fl::kRepSString)},
    // uint64 max_body_size = 11 [json_name = "maxBodySize"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.max_body_size_), _Internal::kHasBitsOffset + 11, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // string log_level = 12 [json_name = "logLevel"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.log_level_), _Internal::kHasBitsOffset + 2, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUtf8String | ::_fl::kRepAString)},
    // optional uint64 workers = 13 [json_name = "workers"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.workers_), _Internal::kHasBitsOffset + 12, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // repeated .uploader.v1.Extension tus_extensions = 14 [json_name = "tusExtensions"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.tus_extensions_), -1, 0,
    (0 | ::_fl::kFcRepeated | ::_fl::kPackedOpenEnum)},
    // bool allow_empty = 15 [json_name = "allowEmpty"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.allow_empty_), _Internal::kHasBitsOffset + 9, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // bool remove_parts = 16 [json_name = "removeParts"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.remove_parts_), _Internal::kHasBitsOffset + 10, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kBool)},
    // optional uint64 max_file_size = 17 [json_name = "maxFileSize"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.max_file_size_), _Internal::kHasBitsOffset + 13, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kUInt64)},
    // .uploader.v1.DataStorageOptions storage_opts = 20 [json_name = "storageOpts"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.storage_opts_), _Internal::kHasBitsOffset + 3, 0,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .uploader.v1.InfoStoreOptions info_storage_opts = 21 [json_name = "infoStorageOpts"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.info_storage_opts_), _Internal::kHasBitsOffset + 4, 1,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .uploader.v1.NotificationsOptions notification_opts = 22 [json_name = "notificationOpts"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.notification_opts_), _Internal::kHasBitsOffset + 5, 2,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
    // .uploader.v1.SentryOptions sentry_opts = 23 [json_name = "sentryOpts"];
    {PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.sentry_opts_), _Internal::kHasBitsOffset + 6, 3,
    (0 | ::_fl::kFcOptional | ::_fl::kMessage | ::_fl::kTvTable)},
  }},
  {{
      {::_pbi::TcParser::GetTable<::uploader::v1::DataStorageOptions>()},
      {::_pbi::TcParser::GetTable<::uploader::v1::InfoStoreOptions>()},
      {::_pbi::TcParser::GetTable<::uploader::v1::NotificationsOptions>()},
      {::_pbi::TcParser::GetTable<::uploader::v1::SentryOptions>()},
  }},
  {{
    "\26\4\0\0\3\4\0\11\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
    "uploader.v1.RustusConf"
    "host"
    "url"
    "cors"
    "log_level"
  }},
};
PROTOBUF_NOINLINE void RustusConf::Clear() {
// @@protoc_insertion_point(message_clear_start:uploader.v1.RustusConf)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.cors_.Clear();
  _impl_.tus_extensions_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if ((cached_has_bits & 0x0000007fu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      _impl_.host_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      _impl_.url_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      _impl_.log_level_.ClearNonDefaultToEmpty();
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(_impl_.storage_opts_ != nullptr);
      _impl_.storage_opts_->Clear();
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(_impl_.info_storage_opts_ != nullptr);
      _impl_.info_storage_opts_->Clear();
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      ABSL_DCHECK(_impl_.notification_opts_ != nullptr);
      _impl_.notification_opts_->Clear();
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      ABSL_DCHECK(_impl_.sentry_opts_ != nullptr);
      _impl_.sentry_opts_->Clear();
    }
  }
  _impl_.port_ = 0u;
  if ((cached_has_bits & 0x00003f00u) != 0) {
    ::memset(&_impl_.disable_health_access_log_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.max_file_size_) -
        reinterpret_cast<char*>(&_impl_.disable_health_access_log_)) + sizeof(_impl_.max_file_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::google::protobuf::UnknownFieldSet>();
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::uint8_t* PROTOBUF_NONNULL RustusConf::_InternalSerialize(
    const ::google::protobuf::MessageLite& base, ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) {
  const RustusConf& this_ = static_cast<const RustusConf&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::uint8_t* PROTOBUF_NONNULL RustusConf::_InternalSerialize(
    ::uint8_t* PROTOBUF_NONNULL target,
    ::google::protobuf::io::EpsCopyOutputStream* PROTOBUF_NONNULL stream) const {
  const RustusConf& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(serialize_to_array_start:uploader.v1.RustusConf)
  ::uint32_t cached_has_bits = 0;
  (void)cached_has_bits;

  // string host = 1 [json_name = "host"];
  if ((this_._impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!this_._internal_host().empty()) {
      const ::std::string& _s = this_._internal_host();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.RustusConf.host");
      target = stream->WriteStringMaybeAliased(1, _s, target);
    }
  }

  // uint32 port = 2 [json_name = "port"];
  if ((this_._impl_._has_bits_[0] & 0x00000080u) != 0) {
    if (this_._internal_port() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
          2, this_._internal_port(), target);
    }
  }

  // bool disable_health_access_log = 3 [json_name = "disableHealthAccessLog"];
  if ((this_._impl_._has_bits_[0] & 0x00000100u) != 0) {
    if (this_._internal_disable_health_access_log() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          3, this_._internal_disable_health_access_log(), target);
    }
  }

  // string url = 4 [json_name = "url"];
  if ((this_._impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!this_._internal_url().empty()) {
      const ::std::string& _s = this_._internal_url();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.RustusConf.url");
      target = stream->WriteStringMaybeAliased(4, _s, target);
    }
  }

  // repeated string cors = 10 [json_name = "cors"];
  for (int i = 0, n = this_._internal_cors_size(); i < n; ++i) {
    const auto& s = this_._internal_cors().Get(i);
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
        s.data(), static_cast<int>(s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.RustusConf.cors");
    target = stream->WriteString(10, s, target);
  }

  // uint64 max_body_size = 11 [json_name = "maxBodySize"];
  if ((this_._impl_._has_bits_[0] & 0x00000800u) != 0) {
    if (this_._internal_max_body_size() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
          11, this_._internal_max_body_size(), target);
    }
  }

  // string log_level = 12 [json_name = "logLevel"];
  if ((this_._impl_._has_bits_[0] & 0x00000004u) != 0) {
    if (!this_._internal_log_level().empty()) {
      const ::std::string& _s = this_._internal_log_level();
      ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          _s.data(), static_cast<int>(_s.length()), ::google::protobuf::internal::WireFormatLite::SERIALIZE, "uploader.v1.RustusConf.log_level");
      target = stream->WriteStringMaybeAliased(12, _s, target);
    }
  }

  cached_has_bits = this_._impl_._has_bits_[0];
  // optional uint64 workers = 13 [json_name = "workers"];
  if ((cached_has_bits & 0x00001000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        13, this_._internal_workers(), target);
  }

  // repeated .uploader.v1.Extension tus_extensions = 14 [json_name = "tusExtensions"];
  {
    ::size_t byte_size = this_._impl_._tus_extensions_cached_byte_size_.Get();
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          14, this_._internal_tus_extensions(), byte_size, target);
    }
  }

  // bool allow_empty = 15 [json_name = "allowEmpty"];
  if ((cached_has_bits & 0x00000200u) != 0) {
    if (this_._internal_allow_empty() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          15, this_._internal_allow_empty(), target);
    }
  }

  // bool remove_parts = 16 [json_name = "removeParts"];
  if ((cached_has_bits & 0x00000400u) != 0) {
    if (this_._internal_remove_parts() != 0) {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(
          16, this_._internal_remove_parts(), target);
    }
  }

  // optional uint64 max_file_size = 17 [json_name = "maxFileSize"];
  if ((cached_has_bits & 0x00002000u) != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        17, this_._internal_max_file_size(), target);
  }

  // .uploader.v1.DataStorageOptions storage_opts = 20 [json_name = "storageOpts"];
  if ((cached_has_bits & 0x00000008u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        20, *this_._impl_.storage_opts_, this_._impl_.storage_opts_->GetCachedSize(), target,
        stream);
  }

  // .uploader.v1.InfoStoreOptions info_storage_opts = 21 [json_name = "infoStorageOpts"];
  if ((cached_has_bits & 0x00000010u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        21, *this_._impl_.info_storage_opts_, this_._impl_.info_storage_opts_->GetCachedSize(), target,
        stream);
  }

  // .uploader.v1.NotificationsOptions notification_opts = 22 [json_name = "notificationOpts"];
  if ((cached_has_bits & 0x00000020u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        22, *this_._impl_.notification_opts_, this_._impl_.notification_opts_->GetCachedSize(), target,
        stream);
  }

  // .uploader.v1.SentryOptions sentry_opts = 23 [json_name = "sentryOpts"];
  if ((cached_has_bits & 0x00000040u) != 0) {
    target = ::google::protobuf::internal::WireFormatLite::InternalWriteMessage(
        23, *this_._impl_.sentry_opts_, this_._impl_.sentry_opts_->GetCachedSize(), target,
        stream);
  }

  if (ABSL_PREDICT_FALSE(this_._internal_metadata_.have_unknown_fields())) {
    target =
        ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
            this_._internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:uploader.v1.RustusConf)
  return target;
}

#if defined(PROTOBUF_CUSTOM_VTABLE)
::size_t RustusConf::ByteSizeLong(const MessageLite& base) {
  const RustusConf& this_ = static_cast<const RustusConf&>(base);
#else   // PROTOBUF_CUSTOM_VTABLE
::size_t RustusConf::ByteSizeLong() const {
  const RustusConf& this_ = *this;
#endif  // PROTOBUF_CUSTOM_VTABLE
  // @@protoc_insertion_point(message_byte_size_start:uploader.v1.RustusConf)
  ::size_t total_size = 0;

  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void)cached_has_bits;

  ::_pbi::Prefetch5LinesFrom7Lines(&this_);
   {
    // repeated string cors = 10 [json_name = "cors"];
    {
      total_size +=
          1 * ::google::protobuf::internal::FromIntSize(this_._internal_cors().size());
      for (int i = 0, n = this_._internal_cors().size(); i < n; ++i) {
        total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
            this_._internal_cors().Get(i));
      }
    }
    // repeated .uploader.v1.Extension tus_extensions = 14 [json_name = "tusExtensions"];
    {
      total_size += ::_pbi::WireFormatLite::EnumSizeWithPackedTagSize(
          this_._internal_tus_extensions(), 1, this_._impl_._tus_extensions_cached_byte_size_);
    }
  }
  cached_has_bits = this_._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    // string host = 1 [json_name = "host"];
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!this_._internal_host().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_host());
      }
    }
    // string url = 4 [json_name = "url"];
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!this_._internal_url().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_url());
      }
    }
    // string log_level = 12 [json_name = "logLevel"];
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (!this_._internal_log_level().empty()) {
        total_size += 1 + ::google::protobuf::internal::WireFormatLite::StringSize(
                                        this_._internal_log_level());
      }
    }
    // .uploader.v1.DataStorageOptions storage_opts = 20 [json_name = "storageOpts"];
    if ((cached_has_bits & 0x00000008u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.storage_opts_);
    }
    // .uploader.v1.InfoStoreOptions info_storage_opts = 21 [json_name = "infoStorageOpts"];
    if ((cached_has_bits & 0x00000010u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.info_storage_opts_);
    }
    // .uploader.v1.NotificationsOptions notification_opts = 22 [json_name = "notificationOpts"];
    if ((cached_has_bits & 0x00000020u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.notification_opts_);
    }
    // .uploader.v1.SentryOptions sentry_opts = 23 [json_name = "sentryOpts"];
    if ((cached_has_bits & 0x00000040u) != 0) {
      total_size += 2 +
                    ::google::protobuf::internal::WireFormatLite::MessageSize(*this_._impl_.sentry_opts_);
    }
    // uint32 port = 2 [json_name = "port"];
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (this_._internal_port() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
            this_._internal_port());
      }
    }
  }
  if ((cached_has_bits & 0x00003f00u) != 0) {
    // bool disable_health_access_log = 3 [json_name = "disableHealthAccessLog"];
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (this_._internal_disable_health_access_log() != 0) {
        total_size += 2;
      }
    }
    // bool allow_empty = 15 [json_name = "allowEmpty"];
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (this_._internal_allow_empty() != 0) {
        total_size += 2;
      }
    }
    // bool remove_parts = 16 [json_name = "removeParts"];
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (this_._internal_remove_parts() != 0) {
        total_size += 3;
      }
    }
    // uint64 max_body_size = 11 [json_name = "maxBodySize"];
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (this_._internal_max_body_size() != 0) {
        total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
            this_._internal_max_body_size());
      }
    }
    // optional uint64 workers = 13 [json_name = "workers"];
    if ((cached_has_bits & 0x00001000u) != 0) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
          this_._internal_workers());
    }
    // optional uint64 max_file_size = 17 [json_name = "maxFileSize"];
    if ((cached_has_bits & 0x00002000u) != 0) {
      total_size += 2 + ::_pbi::WireFormatLite::UInt64Size(
                                      this_._internal_max_file_size());
    }
  }
  return this_.MaybeComputeUnknownFieldsSize(total_size,
                                             &this_._impl_._cached_size_);
}

void RustusConf::MergeImpl(::google::protobuf::MessageLite& to_msg, const ::google::protobuf::MessageLite& from_msg) {
  auto* const _this = static_cast<RustusConf*>(&to_msg);
  auto& from = static_cast<const RustusConf&>(from_msg);
  ::google::protobuf::Arena* arena = _this->GetArena();
  // @@protoc_insertion_point(class_specific_merge_from_start:uploader.v1.RustusConf)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_cors()->MergeFrom(from._internal_cors());
  _this->_internal_mutable_tus_extensions()->MergeFrom(from._internal_tus_extensions());
  cached_has_bits = from._impl_._has_bits_[0];
  if ((cached_has_bits & 0x000000ffu) != 0) {
    if ((cached_has_bits & 0x00000001u) != 0) {
      if (!from._internal_host().empty()) {
        _this->_internal_set_host(from._internal_host());
      } else {
        if (_this->_impl_.host_.IsDefault()) {
          _this->_internal_set_host("");
        }
      }
    }
    if ((cached_has_bits & 0x00000002u) != 0) {
      if (!from._internal_url().empty()) {
        _this->_internal_set_url(from._internal_url());
      } else {
        if (_this->_impl_.url_.IsDefault()) {
          _this->_internal_set_url("");
        }
      }
    }
    if ((cached_has_bits & 0x00000004u) != 0) {
      if (!from._internal_log_level().empty()) {
        _this->_internal_set_log_level(from._internal_log_level());
      } else {
        if (_this->_impl_.log_level_.IsDefault()) {
          _this->_internal_set_log_level("");
        }
      }
    }
    if ((cached_has_bits & 0x00000008u) != 0) {
      ABSL_DCHECK(from._impl_.storage_opts_ != nullptr);
      if (_this->_impl_.storage_opts_ == nullptr) {
        _this->_impl_.storage_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.storage_opts_);
      } else {
        _this->_impl_.storage_opts_->MergeFrom(*from._impl_.storage_opts_);
      }
    }
    if ((cached_has_bits & 0x00000010u) != 0) {
      ABSL_DCHECK(from._impl_.info_storage_opts_ != nullptr);
      if (_this->_impl_.info_storage_opts_ == nullptr) {
        _this->_impl_.info_storage_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.info_storage_opts_);
      } else {
        _this->_impl_.info_storage_opts_->MergeFrom(*from._impl_.info_storage_opts_);
      }
    }
    if ((cached_has_bits & 0x00000020u) != 0) {
      ABSL_DCHECK(from._impl_.notification_opts_ != nullptr);
      if (_this->_impl_.notification_opts_ == nullptr) {
        _this->_impl_.notification_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.notification_opts_);
      } else {
        _this->_impl_.notification_opts_->MergeFrom(*from._impl_.notification_opts_);
      }
    }
    if ((cached_has_bits & 0x00000040u) != 0) {
      ABSL_DCHECK(from._impl_.sentry_opts_ != nullptr);
      if (_this->_impl_.sentry_opts_ == nullptr) {
        _this->_impl_.sentry_opts_ = ::google::protobuf::Message::CopyConstruct(arena, *from._impl_.sentry_opts_);
      } else {
        _this->_impl_.sentry_opts_->MergeFrom(*from._impl_.sentry_opts_);
      }
    }
    if ((cached_has_bits & 0x00000080u) != 0) {
      if (from._internal_port() != 0) {
        _this->_impl_.port_ = from._impl_.port_;
      }
    }
  }
  if ((cached_has_bits & 0x00003f00u) != 0) {
    if ((cached_has_bits & 0x00000100u) != 0) {
      if (from._internal_disable_health_access_log() != 0) {
        _this->_impl_.disable_health_access_log_ = from._impl_.disable_health_access_log_;
      }
    }
    if ((cached_has_bits & 0x00000200u) != 0) {
      if (from._internal_allow_empty() != 0) {
        _this->_impl_.allow_empty_ = from._impl_.allow_empty_;
      }
    }
    if ((cached_has_bits & 0x00000400u) != 0) {
      if (from._internal_remove_parts() != 0) {
        _this->_impl_.remove_parts_ = from._impl_.remove_parts_;
      }
    }
    if ((cached_has_bits & 0x00000800u) != 0) {
      if (from._internal_max_body_size() != 0) {
        _this->_impl_.max_body_size_ = from._impl_.max_body_size_;
      }
    }
    if ((cached_has_bits & 0x00001000u) != 0) {
      _this->_impl_.workers_ = from._impl_.workers_;
    }
    if ((cached_has_bits & 0x00002000u) != 0) {
      _this->_impl_.max_file_size_ = from._impl_.max_file_size_;
    }
  }
  _this->_impl_._has_bits_[0] |= cached_has_bits;
  _this->_internal_metadata_.MergeFrom<::google::protobuf::UnknownFieldSet>(from._internal_metadata_);
}

void RustusConf::CopyFrom(const RustusConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:uploader.v1.RustusConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}


void RustusConf::InternalSwap(RustusConf* PROTOBUF_RESTRICT PROTOBUF_NONNULL other) {
  using ::std::swap;
  auto* arena = GetArena();
  ABSL_DCHECK_EQ(arena, other->GetArena());
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.cors_.InternalSwap(&other->_impl_.cors_);
  _impl_.tus_extensions_.InternalSwap(&other->_impl_.tus_extensions_);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.host_, &other->_impl_.host_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.url_, &other->_impl_.url_, arena);
  ::_pbi::ArenaStringPtr::InternalSwap(&_impl_.log_level_, &other->_impl_.log_level_, arena);
  ::google::protobuf::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.max_file_size_)
      + sizeof(RustusConf::_impl_.max_file_size_)
      - PROTOBUF_FIELD_OFFSET(RustusConf, _impl_.storage_opts_)>(
          reinterpret_cast<char*>(&_impl_.storage_opts_),
          reinterpret_cast<char*>(&other->_impl_.storage_opts_));
}

::google::protobuf::Metadata RustusConf::GetMetadata() const {
  return ::google::protobuf::Message::GetMetadataImpl(GetClassData()->full());
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace v1
}  // namespace uploader
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google
// @@protoc_insertion_point(global_scope)
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::std::false_type
    _static_init2_ [[maybe_unused]] =
        (::_pbi::AddDescriptors(&descriptor_table_uploader_2fv1_2fconfig_2eproto),
         ::std::false_type{});
#include "google/protobuf/port_undef.inc"
