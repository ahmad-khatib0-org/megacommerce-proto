// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/v1/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "common/v1/error.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2fv1_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fv1_2fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2fv1_2fconfig_2eproto;
namespace common {
namespace v1 {
class CacheConfig;
struct CacheConfigDefaultTypeInternal;
extern CacheConfigDefaultTypeInternal _CacheConfig_default_instance_;
class Config;
struct ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class ConfigBleve;
struct ConfigBleveDefaultTypeInternal;
extern ConfigBleveDefaultTypeInternal _ConfigBleve_default_instance_;
class ConfigDataRetention;
struct ConfigDataRetentionDefaultTypeInternal;
extern ConfigDataRetentionDefaultTypeInternal _ConfigDataRetention_default_instance_;
class ConfigEmail;
struct ConfigEmailDefaultTypeInternal;
extern ConfigEmailDefaultTypeInternal _ConfigEmail_default_instance_;
class ConfigFile;
struct ConfigFileDefaultTypeInternal;
extern ConfigFileDefaultTypeInternal _ConfigFile_default_instance_;
class ConfigGetRequest;
struct ConfigGetRequestDefaultTypeInternal;
extern ConfigGetRequestDefaultTypeInternal _ConfigGetRequest_default_instance_;
class ConfigGetResponse;
struct ConfigGetResponseDefaultTypeInternal;
extern ConfigGetResponseDefaultTypeInternal _ConfigGetResponse_default_instance_;
class ConfigImageProxy;
struct ConfigImageProxyDefaultTypeInternal;
extern ConfigImageProxyDefaultTypeInternal _ConfigImageProxy_default_instance_;
class ConfigLdap;
struct ConfigLdapDefaultTypeInternal;
extern ConfigLdapDefaultTypeInternal _ConfigLdap_default_instance_;
class ConfigListenerRequest;
struct ConfigListenerRequestDefaultTypeInternal;
extern ConfigListenerRequestDefaultTypeInternal _ConfigListenerRequest_default_instance_;
class ConfigListenerResponse;
struct ConfigListenerResponseDefaultTypeInternal;
extern ConfigListenerResponseDefaultTypeInternal _ConfigListenerResponse_default_instance_;
class ConfigLocalization;
struct ConfigLocalizationDefaultTypeInternal;
extern ConfigLocalizationDefaultTypeInternal _ConfigLocalization_default_instance_;
class ConfigMain;
struct ConfigMainDefaultTypeInternal;
extern ConfigMainDefaultTypeInternal _ConfigMain_default_instance_;
class ConfigMeilisearch;
struct ConfigMeilisearchDefaultTypeInternal;
extern ConfigMeilisearchDefaultTypeInternal _ConfigMeilisearch_default_instance_;
class ConfigMetrics;
struct ConfigMetricsDefaultTypeInternal;
extern ConfigMetricsDefaultTypeInternal _ConfigMetrics_default_instance_;
class ConfigNativeApp;
struct ConfigNativeAppDefaultTypeInternal;
extern ConfigNativeAppDefaultTypeInternal _ConfigNativeApp_default_instance_;
class ConfigPassword;
struct ConfigPasswordDefaultTypeInternal;
extern ConfigPasswordDefaultTypeInternal _ConfigPassword_default_instance_;
class ConfigPrivacy;
struct ConfigPrivacyDefaultTypeInternal;
extern ConfigPrivacyDefaultTypeInternal _ConfigPrivacy_default_instance_;
class ConfigRateLimit;
struct ConfigRateLimitDefaultTypeInternal;
extern ConfigRateLimitDefaultTypeInternal _ConfigRateLimit_default_instance_;
class ConfigSSO;
struct ConfigSSODefaultTypeInternal;
extern ConfigSSODefaultTypeInternal _ConfigSSO_default_instance_;
class ConfigSaml;
struct ConfigSamlDefaultTypeInternal;
extern ConfigSamlDefaultTypeInternal _ConfigSaml_default_instance_;
class ConfigSecurity;
struct ConfigSecurityDefaultTypeInternal;
extern ConfigSecurityDefaultTypeInternal _ConfigSecurity_default_instance_;
class ConfigSecurity_RestrictedUsernamesEntry_DoNotUse;
struct ConfigSecurity_RestrictedUsernamesEntry_DoNotUseDefaultTypeInternal;
extern ConfigSecurity_RestrictedUsernamesEntry_DoNotUseDefaultTypeInternal _ConfigSecurity_RestrictedUsernamesEntry_DoNotUse_default_instance_;
class ConfigServices;
struct ConfigServicesDefaultTypeInternal;
extern ConfigServicesDefaultTypeInternal _ConfigServices_default_instance_;
class ConfigSql;
struct ConfigSqlDefaultTypeInternal;
extern ConfigSqlDefaultTypeInternal _ConfigSql_default_instance_;
class ConfigSupport;
struct ConfigSupportDefaultTypeInternal;
extern ConfigSupportDefaultTypeInternal _ConfigSupport_default_instance_;
class ConfigUpdateRequest;
struct ConfigUpdateRequestDefaultTypeInternal;
extern ConfigUpdateRequestDefaultTypeInternal _ConfigUpdateRequest_default_instance_;
class ConfigUpdateResponse;
struct ConfigUpdateResponseDefaultTypeInternal;
extern ConfigUpdateResponseDefaultTypeInternal _ConfigUpdateResponse_default_instance_;
}  // namespace v1
}  // namespace common
PROTOBUF_NAMESPACE_OPEN
template<> ::common::v1::CacheConfig* Arena::CreateMaybeMessage<::common::v1::CacheConfig>(Arena*);
template<> ::common::v1::Config* Arena::CreateMaybeMessage<::common::v1::Config>(Arena*);
template<> ::common::v1::ConfigBleve* Arena::CreateMaybeMessage<::common::v1::ConfigBleve>(Arena*);
template<> ::common::v1::ConfigDataRetention* Arena::CreateMaybeMessage<::common::v1::ConfigDataRetention>(Arena*);
template<> ::common::v1::ConfigEmail* Arena::CreateMaybeMessage<::common::v1::ConfigEmail>(Arena*);
template<> ::common::v1::ConfigFile* Arena::CreateMaybeMessage<::common::v1::ConfigFile>(Arena*);
template<> ::common::v1::ConfigGetRequest* Arena::CreateMaybeMessage<::common::v1::ConfigGetRequest>(Arena*);
template<> ::common::v1::ConfigGetResponse* Arena::CreateMaybeMessage<::common::v1::ConfigGetResponse>(Arena*);
template<> ::common::v1::ConfigImageProxy* Arena::CreateMaybeMessage<::common::v1::ConfigImageProxy>(Arena*);
template<> ::common::v1::ConfigLdap* Arena::CreateMaybeMessage<::common::v1::ConfigLdap>(Arena*);
template<> ::common::v1::ConfigListenerRequest* Arena::CreateMaybeMessage<::common::v1::ConfigListenerRequest>(Arena*);
template<> ::common::v1::ConfigListenerResponse* Arena::CreateMaybeMessage<::common::v1::ConfigListenerResponse>(Arena*);
template<> ::common::v1::ConfigLocalization* Arena::CreateMaybeMessage<::common::v1::ConfigLocalization>(Arena*);
template<> ::common::v1::ConfigMain* Arena::CreateMaybeMessage<::common::v1::ConfigMain>(Arena*);
template<> ::common::v1::ConfigMeilisearch* Arena::CreateMaybeMessage<::common::v1::ConfigMeilisearch>(Arena*);
template<> ::common::v1::ConfigMetrics* Arena::CreateMaybeMessage<::common::v1::ConfigMetrics>(Arena*);
template<> ::common::v1::ConfigNativeApp* Arena::CreateMaybeMessage<::common::v1::ConfigNativeApp>(Arena*);
template<> ::common::v1::ConfigPassword* Arena::CreateMaybeMessage<::common::v1::ConfigPassword>(Arena*);
template<> ::common::v1::ConfigPrivacy* Arena::CreateMaybeMessage<::common::v1::ConfigPrivacy>(Arena*);
template<> ::common::v1::ConfigRateLimit* Arena::CreateMaybeMessage<::common::v1::ConfigRateLimit>(Arena*);
template<> ::common::v1::ConfigSSO* Arena::CreateMaybeMessage<::common::v1::ConfigSSO>(Arena*);
template<> ::common::v1::ConfigSaml* Arena::CreateMaybeMessage<::common::v1::ConfigSaml>(Arena*);
template<> ::common::v1::ConfigSecurity* Arena::CreateMaybeMessage<::common::v1::ConfigSecurity>(Arena*);
template<> ::common::v1::ConfigSecurity_RestrictedUsernamesEntry_DoNotUse* Arena::CreateMaybeMessage<::common::v1::ConfigSecurity_RestrictedUsernamesEntry_DoNotUse>(Arena*);
template<> ::common::v1::ConfigServices* Arena::CreateMaybeMessage<::common::v1::ConfigServices>(Arena*);
template<> ::common::v1::ConfigSql* Arena::CreateMaybeMessage<::common::v1::ConfigSql>(Arena*);
template<> ::common::v1::ConfigSupport* Arena::CreateMaybeMessage<::common::v1::ConfigSupport>(Arena*);
template<> ::common::v1::ConfigUpdateRequest* Arena::CreateMaybeMessage<::common::v1::ConfigUpdateRequest>(Arena*);
template<> ::common::v1::ConfigUpdateResponse* Arena::CreateMaybeMessage<::common::v1::ConfigUpdateResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace common {
namespace v1 {

// ===================================================================

class ConfigMain final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigMain) */ {
 public:
  inline ConfigMain() : ConfigMain(nullptr) {}
  ~ConfigMain() override;
  explicit constexpr ConfigMain(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigMain(const ConfigMain& from);
  ConfigMain(ConfigMain&& from) noexcept
    : ConfigMain() {
    *this = ::std::move(from);
  }

  inline ConfigMain& operator=(const ConfigMain& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigMain& operator=(ConfigMain&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigMain& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigMain* internal_default_instance() {
    return reinterpret_cast<const ConfigMain*>(
               &_ConfigMain_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConfigMain& a, ConfigMain& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigMain* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigMain* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigMain* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigMain>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigMain& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigMain& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigMain* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigMain";
  }
  protected:
  explicit ConfigMain(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvFieldNumber = 1,
    kRestrictLinkPreviewsFieldNumber = 6,
    kReadTimeoutFieldNumber = 2,
    kWriteTimeoutFieldNumber = 3,
    kIdleTimeoutFieldNumber = 4,
    kEnableLinkPreviewsFieldNumber = 5,
    kEnableClientPerformanceDebuggingFieldNumber = 7,
    kEnableGifPickerFieldNumber = 8,
    kEnableCustomEmojiFieldNumber = 9,
    kTimeBetweenUserTypingUpdatesMillisecondsFieldNumber = 11,
    kEnableEmojiPickerFieldNumber = 10,
    kEnableFileSearchFieldNumber = 12,
    kEnableUserTypingMessagesFieldNumber = 13,
    kEnableUserStatusesFieldNumber = 14,
    kEnableEmailInvitationsFieldNumber = 15,
    kEnableSvgsFieldNumber = 16,
    kAllowPersistentNotificationsFieldNumber = 17,
    kAllowSyncedDraftsFieldNumber = 22,
    kPersistentNotificationIntervalMinutesFieldNumber = 18,
    kPersistentNotificationMaxCountFieldNumber = 19,
    kPersistentNotificationMaxRecipientsFieldNumber = 20,
    kFeatureFlagSyncIntervalSecondsFieldNumber = 21,
  };
  // optional string env = 1 [json_name = "env"];
  bool has_env() const;
  private:
  bool _internal_has_env() const;
  public:
  void clear_env();
  const std::string& env() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_env(ArgT0&& arg0, ArgT... args);
  std::string* mutable_env();
  PROTOBUF_NODISCARD std::string* release_env();
  void set_allocated_env(std::string* env);
  private:
  const std::string& _internal_env() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_env(const std::string& value);
  std::string* _internal_mutable_env();
  public:

  // optional string restrict_link_previews = 6 [json_name = "restrictLinkPreviews"];
  bool has_restrict_link_previews() const;
  private:
  bool _internal_has_restrict_link_previews() const;
  public:
  void clear_restrict_link_previews();
  const std::string& restrict_link_previews() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_restrict_link_previews(ArgT0&& arg0, ArgT... args);
  std::string* mutable_restrict_link_previews();
  PROTOBUF_NODISCARD std::string* release_restrict_link_previews();
  void set_allocated_restrict_link_previews(std::string* restrict_link_previews);
  private:
  const std::string& _internal_restrict_link_previews() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_restrict_link_previews(const std::string& value);
  std::string* _internal_mutable_restrict_link_previews();
  public:

  // optional int32 read_timeout = 2 [json_name = "readTimeout"];
  bool has_read_timeout() const;
  private:
  bool _internal_has_read_timeout() const;
  public:
  void clear_read_timeout();
  int32_t read_timeout() const;
  void set_read_timeout(int32_t value);
  private:
  int32_t _internal_read_timeout() const;
  void _internal_set_read_timeout(int32_t value);
  public:

  // optional int32 write_timeout = 3 [json_name = "writeTimeout"];
  bool has_write_timeout() const;
  private:
  bool _internal_has_write_timeout() const;
  public:
  void clear_write_timeout();
  int32_t write_timeout() const;
  void set_write_timeout(int32_t value);
  private:
  int32_t _internal_write_timeout() const;
  void _internal_set_write_timeout(int32_t value);
  public:

  // optional int32 idle_timeout = 4 [json_name = "idleTimeout"];
  bool has_idle_timeout() const;
  private:
  bool _internal_has_idle_timeout() const;
  public:
  void clear_idle_timeout();
  int32_t idle_timeout() const;
  void set_idle_timeout(int32_t value);
  private:
  int32_t _internal_idle_timeout() const;
  void _internal_set_idle_timeout(int32_t value);
  public:

  // optional bool enable_link_previews = 5 [json_name = "enableLinkPreviews"];
  bool has_enable_link_previews() const;
  private:
  bool _internal_has_enable_link_previews() const;
  public:
  void clear_enable_link_previews();
  bool enable_link_previews() const;
  void set_enable_link_previews(bool value);
  private:
  bool _internal_enable_link_previews() const;
  void _internal_set_enable_link_previews(bool value);
  public:

  // optional bool enable_client_performance_debugging = 7 [json_name = "enableClientPerformanceDebugging"];
  bool has_enable_client_performance_debugging() const;
  private:
  bool _internal_has_enable_client_performance_debugging() const;
  public:
  void clear_enable_client_performance_debugging();
  bool enable_client_performance_debugging() const;
  void set_enable_client_performance_debugging(bool value);
  private:
  bool _internal_enable_client_performance_debugging() const;
  void _internal_set_enable_client_performance_debugging(bool value);
  public:

  // optional bool enable_gif_picker = 8 [json_name = "enableGifPicker"];
  bool has_enable_gif_picker() const;
  private:
  bool _internal_has_enable_gif_picker() const;
  public:
  void clear_enable_gif_picker();
  bool enable_gif_picker() const;
  void set_enable_gif_picker(bool value);
  private:
  bool _internal_enable_gif_picker() const;
  void _internal_set_enable_gif_picker(bool value);
  public:

  // optional bool enable_custom_emoji = 9 [json_name = "enableCustomEmoji"];
  bool has_enable_custom_emoji() const;
  private:
  bool _internal_has_enable_custom_emoji() const;
  public:
  void clear_enable_custom_emoji();
  bool enable_custom_emoji() const;
  void set_enable_custom_emoji(bool value);
  private:
  bool _internal_enable_custom_emoji() const;
  void _internal_set_enable_custom_emoji(bool value);
  public:

  // optional int64 time_between_user_typing_updates_milliseconds = 11 [json_name = "timeBetweenUserTypingUpdatesMilliseconds"];
  bool has_time_between_user_typing_updates_milliseconds() const;
  private:
  bool _internal_has_time_between_user_typing_updates_milliseconds() const;
  public:
  void clear_time_between_user_typing_updates_milliseconds();
  int64_t time_between_user_typing_updates_milliseconds() const;
  void set_time_between_user_typing_updates_milliseconds(int64_t value);
  private:
  int64_t _internal_time_between_user_typing_updates_milliseconds() const;
  void _internal_set_time_between_user_typing_updates_milliseconds(int64_t value);
  public:

  // optional bool enable_emoji_picker = 10 [json_name = "enableEmojiPicker"];
  bool has_enable_emoji_picker() const;
  private:
  bool _internal_has_enable_emoji_picker() const;
  public:
  void clear_enable_emoji_picker();
  bool enable_emoji_picker() const;
  void set_enable_emoji_picker(bool value);
  private:
  bool _internal_enable_emoji_picker() const;
  void _internal_set_enable_emoji_picker(bool value);
  public:

  // optional bool enable_file_search = 12 [json_name = "enableFileSearch"];
  bool has_enable_file_search() const;
  private:
  bool _internal_has_enable_file_search() const;
  public:
  void clear_enable_file_search();
  bool enable_file_search() const;
  void set_enable_file_search(bool value);
  private:
  bool _internal_enable_file_search() const;
  void _internal_set_enable_file_search(bool value);
  public:

  // optional bool enable_user_typing_messages = 13 [json_name = "enableUserTypingMessages"];
  bool has_enable_user_typing_messages() const;
  private:
  bool _internal_has_enable_user_typing_messages() const;
  public:
  void clear_enable_user_typing_messages();
  bool enable_user_typing_messages() const;
  void set_enable_user_typing_messages(bool value);
  private:
  bool _internal_enable_user_typing_messages() const;
  void _internal_set_enable_user_typing_messages(bool value);
  public:

  // optional bool enable_user_statuses = 14 [json_name = "enableUserStatuses"];
  bool has_enable_user_statuses() const;
  private:
  bool _internal_has_enable_user_statuses() const;
  public:
  void clear_enable_user_statuses();
  bool enable_user_statuses() const;
  void set_enable_user_statuses(bool value);
  private:
  bool _internal_enable_user_statuses() const;
  void _internal_set_enable_user_statuses(bool value);
  public:

  // optional bool enable_email_invitations = 15 [json_name = "enableEmailInvitations"];
  bool has_enable_email_invitations() const;
  private:
  bool _internal_has_enable_email_invitations() const;
  public:
  void clear_enable_email_invitations();
  bool enable_email_invitations() const;
  void set_enable_email_invitations(bool value);
  private:
  bool _internal_enable_email_invitations() const;
  void _internal_set_enable_email_invitations(bool value);
  public:

  // optional bool enable_svgs = 16 [json_name = "enableSvgs"];
  bool has_enable_svgs() const;
  private:
  bool _internal_has_enable_svgs() const;
  public:
  void clear_enable_svgs();
  bool enable_svgs() const;
  void set_enable_svgs(bool value);
  private:
  bool _internal_enable_svgs() const;
  void _internal_set_enable_svgs(bool value);
  public:

  // optional bool allow_persistent_notifications = 17 [json_name = "allowPersistentNotifications"];
  bool has_allow_persistent_notifications() const;
  private:
  bool _internal_has_allow_persistent_notifications() const;
  public:
  void clear_allow_persistent_notifications();
  bool allow_persistent_notifications() const;
  void set_allow_persistent_notifications(bool value);
  private:
  bool _internal_allow_persistent_notifications() const;
  void _internal_set_allow_persistent_notifications(bool value);
  public:

  // optional bool allow_synced_drafts = 22 [json_name = "allowSyncedDrafts"];
  bool has_allow_synced_drafts() const;
  private:
  bool _internal_has_allow_synced_drafts() const;
  public:
  void clear_allow_synced_drafts();
  bool allow_synced_drafts() const;
  void set_allow_synced_drafts(bool value);
  private:
  bool _internal_allow_synced_drafts() const;
  void _internal_set_allow_synced_drafts(bool value);
  public:

  // optional int32 persistent_notification_interval_minutes = 18 [json_name = "persistentNotificationIntervalMinutes"];
  bool has_persistent_notification_interval_minutes() const;
  private:
  bool _internal_has_persistent_notification_interval_minutes() const;
  public:
  void clear_persistent_notification_interval_minutes();
  int32_t persistent_notification_interval_minutes() const;
  void set_persistent_notification_interval_minutes(int32_t value);
  private:
  int32_t _internal_persistent_notification_interval_minutes() const;
  void _internal_set_persistent_notification_interval_minutes(int32_t value);
  public:

  // optional int32 persistent_notification_max_count = 19 [json_name = "persistentNotificationMaxCount"];
  bool has_persistent_notification_max_count() const;
  private:
  bool _internal_has_persistent_notification_max_count() const;
  public:
  void clear_persistent_notification_max_count();
  int32_t persistent_notification_max_count() const;
  void set_persistent_notification_max_count(int32_t value);
  private:
  int32_t _internal_persistent_notification_max_count() const;
  void _internal_set_persistent_notification_max_count(int32_t value);
  public:

  // optional int32 persistent_notification_max_recipients = 20 [json_name = "persistentNotificationMaxRecipients"];
  bool has_persistent_notification_max_recipients() const;
  private:
  bool _internal_has_persistent_notification_max_recipients() const;
  public:
  void clear_persistent_notification_max_recipients();
  int32_t persistent_notification_max_recipients() const;
  void set_persistent_notification_max_recipients(int32_t value);
  private:
  int32_t _internal_persistent_notification_max_recipients() const;
  void _internal_set_persistent_notification_max_recipients(int32_t value);
  public:

  // optional int32 feature_flag_sync_interval_seconds = 21 [json_name = "featureFlagSyncIntervalSeconds"];
  bool has_feature_flag_sync_interval_seconds() const;
  private:
  bool _internal_has_feature_flag_sync_interval_seconds() const;
  public:
  void clear_feature_flag_sync_interval_seconds();
  int32_t feature_flag_sync_interval_seconds() const;
  void set_feature_flag_sync_interval_seconds(int32_t value);
  private:
  int32_t _internal_feature_flag_sync_interval_seconds() const;
  void _internal_set_feature_flag_sync_interval_seconds(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigMain)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr env_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr restrict_link_previews_;
  int32_t read_timeout_;
  int32_t write_timeout_;
  int32_t idle_timeout_;
  bool enable_link_previews_;
  bool enable_client_performance_debugging_;
  bool enable_gif_picker_;
  bool enable_custom_emoji_;
  int64_t time_between_user_typing_updates_milliseconds_;
  bool enable_emoji_picker_;
  bool enable_file_search_;
  bool enable_user_typing_messages_;
  bool enable_user_statuses_;
  bool enable_email_invitations_;
  bool enable_svgs_;
  bool allow_persistent_notifications_;
  bool allow_synced_drafts_;
  int32_t persistent_notification_interval_minutes_;
  int32_t persistent_notification_max_count_;
  int32_t persistent_notification_max_recipients_;
  int32_t feature_flag_sync_interval_seconds_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigServices final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigServices) */ {
 public:
  inline ConfigServices() : ConfigServices(nullptr) {}
  ~ConfigServices() override;
  explicit constexpr ConfigServices(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigServices(const ConfigServices& from);
  ConfigServices(ConfigServices&& from) noexcept
    : ConfigServices() {
    *this = ::std::move(from);
  }

  inline ConfigServices& operator=(const ConfigServices& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigServices& operator=(ConfigServices&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigServices& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigServices* internal_default_instance() {
    return reinterpret_cast<const ConfigServices*>(
               &_ConfigServices_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConfigServices& a, ConfigServices& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigServices* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigServices* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigServices* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigServices>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigServices& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigServices& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigServices* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigServices";
  }
  protected:
  explicit ConfigServices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommonServiceGrpcUrlFieldNumber = 1,
    kUserServiceGrpcUrlFieldNumber = 2,
    kJaegerCollectorUrlFieldNumber = 3,
    kCommonServicePrometheusUrlFieldNumber = 4,
    kUserServicePrometheusUrlFieldNumber = 5,
  };
  // optional string common_service_grpc_url = 1 [json_name = "commonServiceGrpcUrl"];
  bool has_common_service_grpc_url() const;
  private:
  bool _internal_has_common_service_grpc_url() const;
  public:
  void clear_common_service_grpc_url();
  const std::string& common_service_grpc_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_common_service_grpc_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_common_service_grpc_url();
  PROTOBUF_NODISCARD std::string* release_common_service_grpc_url();
  void set_allocated_common_service_grpc_url(std::string* common_service_grpc_url);
  private:
  const std::string& _internal_common_service_grpc_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_common_service_grpc_url(const std::string& value);
  std::string* _internal_mutable_common_service_grpc_url();
  public:

  // optional string user_service_grpc_url = 2 [json_name = "userServiceGrpcUrl"];
  bool has_user_service_grpc_url() const;
  private:
  bool _internal_has_user_service_grpc_url() const;
  public:
  void clear_user_service_grpc_url();
  const std::string& user_service_grpc_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_service_grpc_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_service_grpc_url();
  PROTOBUF_NODISCARD std::string* release_user_service_grpc_url();
  void set_allocated_user_service_grpc_url(std::string* user_service_grpc_url);
  private:
  const std::string& _internal_user_service_grpc_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_service_grpc_url(const std::string& value);
  std::string* _internal_mutable_user_service_grpc_url();
  public:

  // optional string jaeger_collector_url = 3 [json_name = "jaegerCollectorUrl"];
  bool has_jaeger_collector_url() const;
  private:
  bool _internal_has_jaeger_collector_url() const;
  public:
  void clear_jaeger_collector_url();
  const std::string& jaeger_collector_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jaeger_collector_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jaeger_collector_url();
  PROTOBUF_NODISCARD std::string* release_jaeger_collector_url();
  void set_allocated_jaeger_collector_url(std::string* jaeger_collector_url);
  private:
  const std::string& _internal_jaeger_collector_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jaeger_collector_url(const std::string& value);
  std::string* _internal_mutable_jaeger_collector_url();
  public:

  // optional string common_service_prometheus_url = 4 [json_name = "commonServicePrometheusUrl"];
  bool has_common_service_prometheus_url() const;
  private:
  bool _internal_has_common_service_prometheus_url() const;
  public:
  void clear_common_service_prometheus_url();
  const std::string& common_service_prometheus_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_common_service_prometheus_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_common_service_prometheus_url();
  PROTOBUF_NODISCARD std::string* release_common_service_prometheus_url();
  void set_allocated_common_service_prometheus_url(std::string* common_service_prometheus_url);
  private:
  const std::string& _internal_common_service_prometheus_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_common_service_prometheus_url(const std::string& value);
  std::string* _internal_mutable_common_service_prometheus_url();
  public:

  // optional string user_service_prometheus_url = 5 [json_name = "userServicePrometheusUrl"];
  bool has_user_service_prometheus_url() const;
  private:
  bool _internal_has_user_service_prometheus_url() const;
  public:
  void clear_user_service_prometheus_url();
  const std::string& user_service_prometheus_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_service_prometheus_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_service_prometheus_url();
  PROTOBUF_NODISCARD std::string* release_user_service_prometheus_url();
  void set_allocated_user_service_prometheus_url(std::string* user_service_prometheus_url);
  private:
  const std::string& _internal_user_service_prometheus_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_service_prometheus_url(const std::string& value);
  std::string* _internal_mutable_user_service_prometheus_url();
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigServices)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr common_service_grpc_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_service_grpc_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jaeger_collector_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr common_service_prometheus_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_service_prometheus_url_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigSecurity_RestrictedUsernamesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConfigSecurity_RestrictedUsernamesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ConfigSecurity_RestrictedUsernamesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ConfigSecurity_RestrictedUsernamesEntry_DoNotUse();
  explicit constexpr ConfigSecurity_RestrictedUsernamesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ConfigSecurity_RestrictedUsernamesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ConfigSecurity_RestrictedUsernamesEntry_DoNotUse& other);
  static const ConfigSecurity_RestrictedUsernamesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ConfigSecurity_RestrictedUsernamesEntry_DoNotUse*>(&_ConfigSecurity_RestrictedUsernamesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "common.v1.ConfigSecurity.RestrictedUsernamesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "common.v1.ConfigSecurity.RestrictedUsernamesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ConfigSecurity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigSecurity) */ {
 public:
  inline ConfigSecurity() : ConfigSecurity(nullptr) {}
  ~ConfigSecurity() override;
  explicit constexpr ConfigSecurity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigSecurity(const ConfigSecurity& from);
  ConfigSecurity(ConfigSecurity&& from) noexcept
    : ConfigSecurity() {
    *this = ::std::move(from);
  }

  inline ConfigSecurity& operator=(const ConfigSecurity& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigSecurity& operator=(ConfigSecurity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigSecurity& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigSecurity* internal_default_instance() {
    return reinterpret_cast<const ConfigSecurity*>(
               &_ConfigSecurity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ConfigSecurity& a, ConfigSecurity& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigSecurity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigSecurity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigSecurity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigSecurity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigSecurity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigSecurity& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSecurity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigSecurity";
  }
  protected:
  explicit ConfigSecurity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kRestrictedUsernamesFieldNumber = 1,
    kAllowCorsFromFieldNumber = 12,
    kCorsExposedHeadersFieldNumber = 13,
    kMaximumLoginAttemptsFieldNumber = 2,
    kEnableInsecureOutgoingConnectionsFieldNumber = 3,
    kEnableMultifactorAuthenticationFieldNumber = 4,
    kEnforceMultifactorAuthenticationFieldNumber = 5,
    kEnableOauthServiceProviderFieldNumber = 6,
    kSessionLengthWebInHoursFieldNumber = 9,
    kSessionLengthMobileInHoursFieldNumber = 10,
    kSessionLengthSsoInHoursFieldNumber = 11,
    kEnableOutgoingOauthConnectionsFieldNumber = 7,
    kTerminateSessionsOnPasswordChangeFieldNumber = 8,
    kCorsAllowCredentialsFieldNumber = 14,
    kCorsDebugFieldNumber = 15,
    kAllowCookiesForSubdomainsFieldNumber = 16,
    kSessionCacheInMinutesFieldNumber = 17,
    kWebsocketSecurePortFieldNumber = 18,
    kWebsocketPortFieldNumber = 19,
  };
  // map<string, string> restricted_usernames = 1 [json_name = "restrictedUsernames"];
  int restricted_usernames_size() const;
  private:
  int _internal_restricted_usernames_size() const;
  public:
  void clear_restricted_usernames();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_restricted_usernames() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_restricted_usernames();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      restricted_usernames() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_restricted_usernames();

  // optional string allow_cors_from = 12 [json_name = "allowCorsFrom"];
  bool has_allow_cors_from() const;
  private:
  bool _internal_has_allow_cors_from() const;
  public:
  void clear_allow_cors_from();
  const std::string& allow_cors_from() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_allow_cors_from(ArgT0&& arg0, ArgT... args);
  std::string* mutable_allow_cors_from();
  PROTOBUF_NODISCARD std::string* release_allow_cors_from();
  void set_allocated_allow_cors_from(std::string* allow_cors_from);
  private:
  const std::string& _internal_allow_cors_from() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_allow_cors_from(const std::string& value);
  std::string* _internal_mutable_allow_cors_from();
  public:

  // optional string cors_exposed_headers = 13 [json_name = "corsExposedHeaders"];
  bool has_cors_exposed_headers() const;
  private:
  bool _internal_has_cors_exposed_headers() const;
  public:
  void clear_cors_exposed_headers();
  const std::string& cors_exposed_headers() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cors_exposed_headers(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cors_exposed_headers();
  PROTOBUF_NODISCARD std::string* release_cors_exposed_headers();
  void set_allocated_cors_exposed_headers(std::string* cors_exposed_headers);
  private:
  const std::string& _internal_cors_exposed_headers() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cors_exposed_headers(const std::string& value);
  std::string* _internal_mutable_cors_exposed_headers();
  public:

  // optional int32 maximum_login_attempts = 2 [json_name = "maximumLoginAttempts"];
  bool has_maximum_login_attempts() const;
  private:
  bool _internal_has_maximum_login_attempts() const;
  public:
  void clear_maximum_login_attempts();
  int32_t maximum_login_attempts() const;
  void set_maximum_login_attempts(int32_t value);
  private:
  int32_t _internal_maximum_login_attempts() const;
  void _internal_set_maximum_login_attempts(int32_t value);
  public:

  // optional bool enable_insecure_outgoing_connections = 3 [json_name = "enableInsecureOutgoingConnections"];
  bool has_enable_insecure_outgoing_connections() const;
  private:
  bool _internal_has_enable_insecure_outgoing_connections() const;
  public:
  void clear_enable_insecure_outgoing_connections();
  bool enable_insecure_outgoing_connections() const;
  void set_enable_insecure_outgoing_connections(bool value);
  private:
  bool _internal_enable_insecure_outgoing_connections() const;
  void _internal_set_enable_insecure_outgoing_connections(bool value);
  public:

  // optional bool enable_multifactor_authentication = 4 [json_name = "enableMultifactorAuthentication"];
  bool has_enable_multifactor_authentication() const;
  private:
  bool _internal_has_enable_multifactor_authentication() const;
  public:
  void clear_enable_multifactor_authentication();
  bool enable_multifactor_authentication() const;
  void set_enable_multifactor_authentication(bool value);
  private:
  bool _internal_enable_multifactor_authentication() const;
  void _internal_set_enable_multifactor_authentication(bool value);
  public:

  // optional bool enforce_multifactor_authentication = 5 [json_name = "enforceMultifactorAuthentication"];
  bool has_enforce_multifactor_authentication() const;
  private:
  bool _internal_has_enforce_multifactor_authentication() const;
  public:
  void clear_enforce_multifactor_authentication();
  bool enforce_multifactor_authentication() const;
  void set_enforce_multifactor_authentication(bool value);
  private:
  bool _internal_enforce_multifactor_authentication() const;
  void _internal_set_enforce_multifactor_authentication(bool value);
  public:

  // optional bool enable_oauth_service_provider = 6 [json_name = "enableOauthServiceProvider"];
  bool has_enable_oauth_service_provider() const;
  private:
  bool _internal_has_enable_oauth_service_provider() const;
  public:
  void clear_enable_oauth_service_provider();
  bool enable_oauth_service_provider() const;
  void set_enable_oauth_service_provider(bool value);
  private:
  bool _internal_enable_oauth_service_provider() const;
  void _internal_set_enable_oauth_service_provider(bool value);
  public:

  // optional int32 session_length_web_in_hours = 9 [json_name = "sessionLengthWebInHours"];
  bool has_session_length_web_in_hours() const;
  private:
  bool _internal_has_session_length_web_in_hours() const;
  public:
  void clear_session_length_web_in_hours();
  int32_t session_length_web_in_hours() const;
  void set_session_length_web_in_hours(int32_t value);
  private:
  int32_t _internal_session_length_web_in_hours() const;
  void _internal_set_session_length_web_in_hours(int32_t value);
  public:

  // optional int32 session_length_mobile_in_hours = 10 [json_name = "sessionLengthMobileInHours"];
  bool has_session_length_mobile_in_hours() const;
  private:
  bool _internal_has_session_length_mobile_in_hours() const;
  public:
  void clear_session_length_mobile_in_hours();
  int32_t session_length_mobile_in_hours() const;
  void set_session_length_mobile_in_hours(int32_t value);
  private:
  int32_t _internal_session_length_mobile_in_hours() const;
  void _internal_set_session_length_mobile_in_hours(int32_t value);
  public:

  // optional int32 session_length_sso_in_hours = 11 [json_name = "sessionLengthSsoInHours"];
  bool has_session_length_sso_in_hours() const;
  private:
  bool _internal_has_session_length_sso_in_hours() const;
  public:
  void clear_session_length_sso_in_hours();
  int32_t session_length_sso_in_hours() const;
  void set_session_length_sso_in_hours(int32_t value);
  private:
  int32_t _internal_session_length_sso_in_hours() const;
  void _internal_set_session_length_sso_in_hours(int32_t value);
  public:

  // optional bool enable_outgoing_oauth_connections = 7 [json_name = "enableOutgoingOauthConnections"];
  bool has_enable_outgoing_oauth_connections() const;
  private:
  bool _internal_has_enable_outgoing_oauth_connections() const;
  public:
  void clear_enable_outgoing_oauth_connections();
  bool enable_outgoing_oauth_connections() const;
  void set_enable_outgoing_oauth_connections(bool value);
  private:
  bool _internal_enable_outgoing_oauth_connections() const;
  void _internal_set_enable_outgoing_oauth_connections(bool value);
  public:

  // optional bool terminate_sessions_on_password_change = 8 [json_name = "terminateSessionsOnPasswordChange"];
  bool has_terminate_sessions_on_password_change() const;
  private:
  bool _internal_has_terminate_sessions_on_password_change() const;
  public:
  void clear_terminate_sessions_on_password_change();
  bool terminate_sessions_on_password_change() const;
  void set_terminate_sessions_on_password_change(bool value);
  private:
  bool _internal_terminate_sessions_on_password_change() const;
  void _internal_set_terminate_sessions_on_password_change(bool value);
  public:

  // optional bool cors_allow_credentials = 14 [json_name = "corsAllowCredentials"];
  bool has_cors_allow_credentials() const;
  private:
  bool _internal_has_cors_allow_credentials() const;
  public:
  void clear_cors_allow_credentials();
  bool cors_allow_credentials() const;
  void set_cors_allow_credentials(bool value);
  private:
  bool _internal_cors_allow_credentials() const;
  void _internal_set_cors_allow_credentials(bool value);
  public:

  // optional bool cors_debug = 15 [json_name = "corsDebug"];
  bool has_cors_debug() const;
  private:
  bool _internal_has_cors_debug() const;
  public:
  void clear_cors_debug();
  bool cors_debug() const;
  void set_cors_debug(bool value);
  private:
  bool _internal_cors_debug() const;
  void _internal_set_cors_debug(bool value);
  public:

  // optional bool allow_cookies_for_subdomains = 16 [json_name = "allowCookiesForSubdomains"];
  bool has_allow_cookies_for_subdomains() const;
  private:
  bool _internal_has_allow_cookies_for_subdomains() const;
  public:
  void clear_allow_cookies_for_subdomains();
  bool allow_cookies_for_subdomains() const;
  void set_allow_cookies_for_subdomains(bool value);
  private:
  bool _internal_allow_cookies_for_subdomains() const;
  void _internal_set_allow_cookies_for_subdomains(bool value);
  public:

  // optional int32 session_cache_in_minutes = 17 [json_name = "sessionCacheInMinutes"];
  bool has_session_cache_in_minutes() const;
  private:
  bool _internal_has_session_cache_in_minutes() const;
  public:
  void clear_session_cache_in_minutes();
  int32_t session_cache_in_minutes() const;
  void set_session_cache_in_minutes(int32_t value);
  private:
  int32_t _internal_session_cache_in_minutes() const;
  void _internal_set_session_cache_in_minutes(int32_t value);
  public:

  // optional int32 websocket_secure_port = 18 [json_name = "websocketSecurePort"];
  bool has_websocket_secure_port() const;
  private:
  bool _internal_has_websocket_secure_port() const;
  public:
  void clear_websocket_secure_port();
  int32_t websocket_secure_port() const;
  void set_websocket_secure_port(int32_t value);
  private:
  int32_t _internal_websocket_secure_port() const;
  void _internal_set_websocket_secure_port(int32_t value);
  public:

  // optional int32 websocket_port = 19 [json_name = "websocketPort"];
  bool has_websocket_port() const;
  private:
  bool _internal_has_websocket_port() const;
  public:
  void clear_websocket_port();
  int32_t websocket_port() const;
  void set_websocket_port(int32_t value);
  private:
  int32_t _internal_websocket_port() const;
  void _internal_set_websocket_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigSecurity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ConfigSecurity_RestrictedUsernamesEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> restricted_usernames_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr allow_cors_from_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cors_exposed_headers_;
  int32_t maximum_login_attempts_;
  bool enable_insecure_outgoing_connections_;
  bool enable_multifactor_authentication_;
  bool enforce_multifactor_authentication_;
  bool enable_oauth_service_provider_;
  int32_t session_length_web_in_hours_;
  int32_t session_length_mobile_in_hours_;
  int32_t session_length_sso_in_hours_;
  bool enable_outgoing_oauth_connections_;
  bool terminate_sessions_on_password_change_;
  bool cors_allow_credentials_;
  bool cors_debug_;
  bool allow_cookies_for_subdomains_;
  int32_t session_cache_in_minutes_;
  int32_t websocket_secure_port_;
  int32_t websocket_port_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class CacheConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.CacheConfig) */ {
 public:
  inline CacheConfig() : CacheConfig(nullptr) {}
  ~CacheConfig() override;
  explicit constexpr CacheConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CacheConfig(const CacheConfig& from);
  CacheConfig(CacheConfig&& from) noexcept
    : CacheConfig() {
    *this = ::std::move(from);
  }

  inline CacheConfig& operator=(const CacheConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CacheConfig& operator=(CacheConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CacheConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CacheConfig* internal_default_instance() {
    return reinterpret_cast<const CacheConfig*>(
               &_CacheConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CacheConfig& a, CacheConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CacheConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CacheConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CacheConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CacheConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CacheConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CacheConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CacheConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.CacheConfig";
  }
  protected:
  explicit CacheConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacheTypeFieldNumber = 1,
    kRedisAddressFieldNumber = 2,
    kRedisPasswordFieldNumber = 3,
    kRedisCachePrefixFieldNumber = 5,
    kRedisDbFieldNumber = 4,
    kDisableClientCacheFieldNumber = 6,
  };
  // optional string cache_type = 1 [json_name = "cacheType"];
  bool has_cache_type() const;
  private:
  bool _internal_has_cache_type() const;
  public:
  void clear_cache_type();
  const std::string& cache_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_type();
  PROTOBUF_NODISCARD std::string* release_cache_type();
  void set_allocated_cache_type(std::string* cache_type);
  private:
  const std::string& _internal_cache_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_type(const std::string& value);
  std::string* _internal_mutable_cache_type();
  public:

  // optional string redis_address = 2 [json_name = "redisAddress"];
  bool has_redis_address() const;
  private:
  bool _internal_has_redis_address() const;
  public:
  void clear_redis_address();
  const std::string& redis_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redis_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redis_address();
  PROTOBUF_NODISCARD std::string* release_redis_address();
  void set_allocated_redis_address(std::string* redis_address);
  private:
  const std::string& _internal_redis_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redis_address(const std::string& value);
  std::string* _internal_mutable_redis_address();
  public:

  // optional string redis_password = 3 [json_name = "redisPassword"];
  bool has_redis_password() const;
  private:
  bool _internal_has_redis_password() const;
  public:
  void clear_redis_password();
  const std::string& redis_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redis_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redis_password();
  PROTOBUF_NODISCARD std::string* release_redis_password();
  void set_allocated_redis_password(std::string* redis_password);
  private:
  const std::string& _internal_redis_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redis_password(const std::string& value);
  std::string* _internal_mutable_redis_password();
  public:

  // optional string redis_cache_prefix = 5 [json_name = "redisCachePrefix"];
  bool has_redis_cache_prefix() const;
  private:
  bool _internal_has_redis_cache_prefix() const;
  public:
  void clear_redis_cache_prefix();
  const std::string& redis_cache_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redis_cache_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redis_cache_prefix();
  PROTOBUF_NODISCARD std::string* release_redis_cache_prefix();
  void set_allocated_redis_cache_prefix(std::string* redis_cache_prefix);
  private:
  const std::string& _internal_redis_cache_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redis_cache_prefix(const std::string& value);
  std::string* _internal_mutable_redis_cache_prefix();
  public:

  // optional int32 redis_db = 4 [json_name = "redisDb"];
  bool has_redis_db() const;
  private:
  bool _internal_has_redis_db() const;
  public:
  void clear_redis_db();
  int32_t redis_db() const;
  void set_redis_db(int32_t value);
  private:
  int32_t _internal_redis_db() const;
  void _internal_set_redis_db(int32_t value);
  public:

  // optional bool disable_client_cache = 6 [json_name = "disableClientCache"];
  bool has_disable_client_cache() const;
  private:
  bool _internal_has_disable_client_cache() const;
  public:
  void clear_disable_client_cache();
  bool disable_client_cache() const;
  void set_disable_client_cache(bool value);
  private:
  bool _internal_disable_client_cache() const;
  void _internal_set_disable_client_cache(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.CacheConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redis_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redis_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redis_cache_prefix_;
  int32_t redis_db_;
  bool disable_client_cache_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigMetrics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigMetrics) */ {
 public:
  inline ConfigMetrics() : ConfigMetrics(nullptr) {}
  ~ConfigMetrics() override;
  explicit constexpr ConfigMetrics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigMetrics(const ConfigMetrics& from);
  ConfigMetrics(ConfigMetrics&& from) noexcept
    : ConfigMetrics() {
    *this = ::std::move(from);
  }

  inline ConfigMetrics& operator=(const ConfigMetrics& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigMetrics& operator=(ConfigMetrics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigMetrics& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigMetrics* internal_default_instance() {
    return reinterpret_cast<const ConfigMetrics*>(
               &_ConfigMetrics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ConfigMetrics& a, ConfigMetrics& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigMetrics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigMetrics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigMetrics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigMetrics>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigMetrics& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigMetrics& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigMetrics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigMetrics";
  }
  protected:
  explicit ConfigMetrics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientSideUserIdsFieldNumber = 6,
    kListenAddressFieldNumber = 3,
    kBlockProfileRateFieldNumber = 2,
    kEnableFieldNumber = 1,
    kEnableClientMetricsFieldNumber = 4,
    kEnableNotificationMetricsFieldNumber = 5,
  };
  // repeated string client_side_user_ids = 6 [json_name = "clientSideUserIds"];
  int client_side_user_ids_size() const;
  private:
  int _internal_client_side_user_ids_size() const;
  public:
  void clear_client_side_user_ids();
  const std::string& client_side_user_ids(int index) const;
  std::string* mutable_client_side_user_ids(int index);
  void set_client_side_user_ids(int index, const std::string& value);
  void set_client_side_user_ids(int index, std::string&& value);
  void set_client_side_user_ids(int index, const char* value);
  void set_client_side_user_ids(int index, const char* value, size_t size);
  std::string* add_client_side_user_ids();
  void add_client_side_user_ids(const std::string& value);
  void add_client_side_user_ids(std::string&& value);
  void add_client_side_user_ids(const char* value);
  void add_client_side_user_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& client_side_user_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_client_side_user_ids();
  private:
  const std::string& _internal_client_side_user_ids(int index) const;
  std::string* _internal_add_client_side_user_ids();
  public:

  // optional string listen_address = 3 [json_name = "listenAddress"];
  bool has_listen_address() const;
  private:
  bool _internal_has_listen_address() const;
  public:
  void clear_listen_address();
  const std::string& listen_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_listen_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_listen_address();
  PROTOBUF_NODISCARD std::string* release_listen_address();
  void set_allocated_listen_address(std::string* listen_address);
  private:
  const std::string& _internal_listen_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_listen_address(const std::string& value);
  std::string* _internal_mutable_listen_address();
  public:

  // optional int32 block_profile_rate = 2 [json_name = "blockProfileRate"];
  bool has_block_profile_rate() const;
  private:
  bool _internal_has_block_profile_rate() const;
  public:
  void clear_block_profile_rate();
  int32_t block_profile_rate() const;
  void set_block_profile_rate(int32_t value);
  private:
  int32_t _internal_block_profile_rate() const;
  void _internal_set_block_profile_rate(int32_t value);
  public:

  // optional bool enable = 1 [json_name = "enable"];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional bool enable_client_metrics = 4 [json_name = "enableClientMetrics"];
  bool has_enable_client_metrics() const;
  private:
  bool _internal_has_enable_client_metrics() const;
  public:
  void clear_enable_client_metrics();
  bool enable_client_metrics() const;
  void set_enable_client_metrics(bool value);
  private:
  bool _internal_enable_client_metrics() const;
  void _internal_set_enable_client_metrics(bool value);
  public:

  // optional bool enable_notification_metrics = 5 [json_name = "enableNotificationMetrics"];
  bool has_enable_notification_metrics() const;
  private:
  bool _internal_has_enable_notification_metrics() const;
  public:
  void clear_enable_notification_metrics();
  bool enable_notification_metrics() const;
  void set_enable_notification_metrics(bool value);
  private:
  bool _internal_enable_notification_metrics() const;
  void _internal_set_enable_notification_metrics(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigMetrics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> client_side_user_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr listen_address_;
  int32_t block_profile_rate_;
  bool enable_;
  bool enable_client_metrics_;
  bool enable_notification_metrics_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigSSO final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigSSO) */ {
 public:
  inline ConfigSSO() : ConfigSSO(nullptr) {}
  ~ConfigSSO() override;
  explicit constexpr ConfigSSO(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigSSO(const ConfigSSO& from);
  ConfigSSO(ConfigSSO&& from) noexcept
    : ConfigSSO() {
    *this = ::std::move(from);
  }

  inline ConfigSSO& operator=(const ConfigSSO& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigSSO& operator=(ConfigSSO&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigSSO& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigSSO* internal_default_instance() {
    return reinterpret_cast<const ConfigSSO*>(
               &_ConfigSSO_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ConfigSSO& a, ConfigSSO& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigSSO* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigSSO* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigSSO* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigSSO>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigSSO& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigSSO& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSSO* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigSSO";
  }
  protected:
  explicit ConfigSSO(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretFieldNumber = 2,
    kIdFieldNumber = 3,
    kScopeFieldNumber = 4,
    kAuthEndpointFieldNumber = 5,
    kTokenEndpointFieldNumber = 6,
    kUserApiEndpointFieldNumber = 7,
    kDiscoveryEndpointFieldNumber = 8,
    kButtonTextFieldNumber = 9,
    kButtonColorFieldNumber = 10,
    kEnableFieldNumber = 1,
  };
  // optional string secret = 2 [json_name = "secret"];
  bool has_secret() const;
  private:
  bool _internal_has_secret() const;
  public:
  void clear_secret();
  const std::string& secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* secret);
  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(const std::string& value);
  std::string* _internal_mutable_secret();
  public:

  // optional string id = 3 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string scope = 4 [json_name = "scope"];
  bool has_scope() const;
  private:
  bool _internal_has_scope() const;
  public:
  void clear_scope();
  const std::string& scope() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scope(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scope();
  PROTOBUF_NODISCARD std::string* release_scope();
  void set_allocated_scope(std::string* scope);
  private:
  const std::string& _internal_scope() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scope(const std::string& value);
  std::string* _internal_mutable_scope();
  public:

  // optional string auth_endpoint = 5 [json_name = "authEndpoint"];
  bool has_auth_endpoint() const;
  private:
  bool _internal_has_auth_endpoint() const;
  public:
  void clear_auth_endpoint();
  const std::string& auth_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_endpoint();
  PROTOBUF_NODISCARD std::string* release_auth_endpoint();
  void set_allocated_auth_endpoint(std::string* auth_endpoint);
  private:
  const std::string& _internal_auth_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_endpoint(const std::string& value);
  std::string* _internal_mutable_auth_endpoint();
  public:

  // optional string token_endpoint = 6 [json_name = "tokenEndpoint"];
  bool has_token_endpoint() const;
  private:
  bool _internal_has_token_endpoint() const;
  public:
  void clear_token_endpoint();
  const std::string& token_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_endpoint();
  PROTOBUF_NODISCARD std::string* release_token_endpoint();
  void set_allocated_token_endpoint(std::string* token_endpoint);
  private:
  const std::string& _internal_token_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_endpoint(const std::string& value);
  std::string* _internal_mutable_token_endpoint();
  public:

  // optional string user_api_endpoint = 7 [json_name = "userApiEndpoint"];
  bool has_user_api_endpoint() const;
  private:
  bool _internal_has_user_api_endpoint() const;
  public:
  void clear_user_api_endpoint();
  const std::string& user_api_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_api_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_api_endpoint();
  PROTOBUF_NODISCARD std::string* release_user_api_endpoint();
  void set_allocated_user_api_endpoint(std::string* user_api_endpoint);
  private:
  const std::string& _internal_user_api_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_api_endpoint(const std::string& value);
  std::string* _internal_mutable_user_api_endpoint();
  public:

  // optional string discovery_endpoint = 8 [json_name = "discoveryEndpoint"];
  bool has_discovery_endpoint() const;
  private:
  bool _internal_has_discovery_endpoint() const;
  public:
  void clear_discovery_endpoint();
  const std::string& discovery_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_discovery_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_discovery_endpoint();
  PROTOBUF_NODISCARD std::string* release_discovery_endpoint();
  void set_allocated_discovery_endpoint(std::string* discovery_endpoint);
  private:
  const std::string& _internal_discovery_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_discovery_endpoint(const std::string& value);
  std::string* _internal_mutable_discovery_endpoint();
  public:

  // optional string button_text = 9 [json_name = "buttonText"];
  bool has_button_text() const;
  private:
  bool _internal_has_button_text() const;
  public:
  void clear_button_text();
  const std::string& button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_button_text();
  PROTOBUF_NODISCARD std::string* release_button_text();
  void set_allocated_button_text(std::string* button_text);
  private:
  const std::string& _internal_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_button_text(const std::string& value);
  std::string* _internal_mutable_button_text();
  public:

  // optional string button_color = 10 [json_name = "buttonColor"];
  bool has_button_color() const;
  private:
  bool _internal_has_button_color() const;
  public:
  void clear_button_color();
  const std::string& button_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_button_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_button_color();
  PROTOBUF_NODISCARD std::string* release_button_color();
  void set_allocated_button_color(std::string* button_color);
  private:
  const std::string& _internal_button_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_button_color(const std::string& value);
  std::string* _internal_mutable_button_color();
  public:

  // optional bool enable = 1 [json_name = "enable"];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigSSO)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secret_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scope_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_api_endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr discovery_endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr button_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr button_color_;
  bool enable_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigSql final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigSql) */ {
 public:
  inline ConfigSql() : ConfigSql(nullptr) {}
  ~ConfigSql() override;
  explicit constexpr ConfigSql(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigSql(const ConfigSql& from);
  ConfigSql(ConfigSql&& from) noexcept
    : ConfigSql() {
    *this = ::std::move(from);
  }

  inline ConfigSql& operator=(const ConfigSql& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigSql& operator=(ConfigSql&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigSql& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigSql* internal_default_instance() {
    return reinterpret_cast<const ConfigSql*>(
               &_ConfigSql_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ConfigSql& a, ConfigSql& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigSql* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigSql* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigSql* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigSql>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigSql& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigSql& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSql* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigSql";
  }
  protected:
  explicit ConfigSql(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverNameFieldNumber = 1,
    kDataSourceFieldNumber = 2,
    kAtRestEncryptKeyFieldNumber = 8,
    kMaxIdleConnsFieldNumber = 3,
    kConnMaxLifetimeMillisecondsFieldNumber = 4,
    kConnMaxIdleTimeMillisecondsFieldNumber = 5,
    kMaxOpenConnsFieldNumber = 6,
    kTraceFieldNumber = 7,
    kDisableDatabaseSearchFieldNumber = 10,
    kQueryTimeoutFieldNumber = 9,
  };
  // optional string driver_name = 1 [json_name = "driverName"];
  bool has_driver_name() const;
  private:
  bool _internal_has_driver_name() const;
  public:
  void clear_driver_name();
  const std::string& driver_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_name();
  PROTOBUF_NODISCARD std::string* release_driver_name();
  void set_allocated_driver_name(std::string* driver_name);
  private:
  const std::string& _internal_driver_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_name(const std::string& value);
  std::string* _internal_mutable_driver_name();
  public:

  // optional string data_source = 2 [json_name = "dataSource"];
  bool has_data_source() const;
  private:
  bool _internal_has_data_source() const;
  public:
  void clear_data_source();
  const std::string& data_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_source(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_source();
  PROTOBUF_NODISCARD std::string* release_data_source();
  void set_allocated_data_source(std::string* data_source);
  private:
  const std::string& _internal_data_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_source(const std::string& value);
  std::string* _internal_mutable_data_source();
  public:

  // optional string at_rest_encrypt_key = 8 [json_name = "atRestEncryptKey"];
  bool has_at_rest_encrypt_key() const;
  private:
  bool _internal_has_at_rest_encrypt_key() const;
  public:
  void clear_at_rest_encrypt_key();
  const std::string& at_rest_encrypt_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_at_rest_encrypt_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_at_rest_encrypt_key();
  PROTOBUF_NODISCARD std::string* release_at_rest_encrypt_key();
  void set_allocated_at_rest_encrypt_key(std::string* at_rest_encrypt_key);
  private:
  const std::string& _internal_at_rest_encrypt_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_at_rest_encrypt_key(const std::string& value);
  std::string* _internal_mutable_at_rest_encrypt_key();
  public:

  // optional int32 max_idle_conns = 3 [json_name = "maxIdleConns"];
  bool has_max_idle_conns() const;
  private:
  bool _internal_has_max_idle_conns() const;
  public:
  void clear_max_idle_conns();
  int32_t max_idle_conns() const;
  void set_max_idle_conns(int32_t value);
  private:
  int32_t _internal_max_idle_conns() const;
  void _internal_set_max_idle_conns(int32_t value);
  public:

  // optional int32 conn_max_lifetime_milliseconds = 4 [json_name = "connMaxLifetimeMilliseconds"];
  bool has_conn_max_lifetime_milliseconds() const;
  private:
  bool _internal_has_conn_max_lifetime_milliseconds() const;
  public:
  void clear_conn_max_lifetime_milliseconds();
  int32_t conn_max_lifetime_milliseconds() const;
  void set_conn_max_lifetime_milliseconds(int32_t value);
  private:
  int32_t _internal_conn_max_lifetime_milliseconds() const;
  void _internal_set_conn_max_lifetime_milliseconds(int32_t value);
  public:

  // optional int32 conn_max_idle_time_milliseconds = 5 [json_name = "connMaxIdleTimeMilliseconds"];
  bool has_conn_max_idle_time_milliseconds() const;
  private:
  bool _internal_has_conn_max_idle_time_milliseconds() const;
  public:
  void clear_conn_max_idle_time_milliseconds();
  int32_t conn_max_idle_time_milliseconds() const;
  void set_conn_max_idle_time_milliseconds(int32_t value);
  private:
  int32_t _internal_conn_max_idle_time_milliseconds() const;
  void _internal_set_conn_max_idle_time_milliseconds(int32_t value);
  public:

  // optional int32 max_open_conns = 6 [json_name = "maxOpenConns"];
  bool has_max_open_conns() const;
  private:
  bool _internal_has_max_open_conns() const;
  public:
  void clear_max_open_conns();
  int32_t max_open_conns() const;
  void set_max_open_conns(int32_t value);
  private:
  int32_t _internal_max_open_conns() const;
  void _internal_set_max_open_conns(int32_t value);
  public:

  // optional bool trace = 7 [json_name = "trace"];
  bool has_trace() const;
  private:
  bool _internal_has_trace() const;
  public:
  void clear_trace();
  bool trace() const;
  void set_trace(bool value);
  private:
  bool _internal_trace() const;
  void _internal_set_trace(bool value);
  public:

  // optional bool disable_database_search = 10 [json_name = "disableDatabaseSearch"];
  bool has_disable_database_search() const;
  private:
  bool _internal_has_disable_database_search() const;
  public:
  void clear_disable_database_search();
  bool disable_database_search() const;
  void set_disable_database_search(bool value);
  private:
  bool _internal_disable_database_search() const;
  void _internal_set_disable_database_search(bool value);
  public:

  // optional int32 query_timeout = 9 [json_name = "queryTimeout"];
  bool has_query_timeout() const;
  private:
  bool _internal_has_query_timeout() const;
  public:
  void clear_query_timeout();
  int32_t query_timeout() const;
  void set_query_timeout(int32_t value);
  private:
  int32_t _internal_query_timeout() const;
  void _internal_set_query_timeout(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigSql)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr at_rest_encrypt_key_;
  int32_t max_idle_conns_;
  int32_t conn_max_lifetime_milliseconds_;
  int32_t conn_max_idle_time_milliseconds_;
  int32_t max_open_conns_;
  bool trace_;
  bool disable_database_search_;
  int32_t query_timeout_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigPassword final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigPassword) */ {
 public:
  inline ConfigPassword() : ConfigPassword(nullptr) {}
  ~ConfigPassword() override;
  explicit constexpr ConfigPassword(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigPassword(const ConfigPassword& from);
  ConfigPassword(ConfigPassword&& from) noexcept
    : ConfigPassword() {
    *this = ::std::move(from);
  }

  inline ConfigPassword& operator=(const ConfigPassword& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigPassword& operator=(ConfigPassword&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigPassword& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigPassword* internal_default_instance() {
    return reinterpret_cast<const ConfigPassword*>(
               &_ConfigPassword_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ConfigPassword& a, ConfigPassword& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigPassword* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigPassword* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigPassword* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigPassword>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigPassword& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigPassword& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigPassword* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigPassword";
  }
  protected:
  explicit ConfigPassword(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinimumLengthFieldNumber = 1,
    kMaximumLenghtFieldNumber = 2,
    kLowercaseFieldNumber = 3,
    kNumberFieldNumber = 4,
    kUppercaseFieldNumber = 5,
    kSymbolFieldNumber = 6,
    kEnableForgotLinkFieldNumber = 7,
  };
  // optional int32 minimum_length = 1 [json_name = "minimumLength"];
  bool has_minimum_length() const;
  private:
  bool _internal_has_minimum_length() const;
  public:
  void clear_minimum_length();
  int32_t minimum_length() const;
  void set_minimum_length(int32_t value);
  private:
  int32_t _internal_minimum_length() const;
  void _internal_set_minimum_length(int32_t value);
  public:

  // optional int32 maximum_lenght = 2 [json_name = "maximumLenght"];
  bool has_maximum_lenght() const;
  private:
  bool _internal_has_maximum_lenght() const;
  public:
  void clear_maximum_lenght();
  int32_t maximum_lenght() const;
  void set_maximum_lenght(int32_t value);
  private:
  int32_t _internal_maximum_lenght() const;
  void _internal_set_maximum_lenght(int32_t value);
  public:

  // optional bool lowercase = 3 [json_name = "lowercase"];
  bool has_lowercase() const;
  private:
  bool _internal_has_lowercase() const;
  public:
  void clear_lowercase();
  bool lowercase() const;
  void set_lowercase(bool value);
  private:
  bool _internal_lowercase() const;
  void _internal_set_lowercase(bool value);
  public:

  // optional bool number = 4 [json_name = "number"];
  bool has_number() const;
  private:
  bool _internal_has_number() const;
  public:
  void clear_number();
  bool number() const;
  void set_number(bool value);
  private:
  bool _internal_number() const;
  void _internal_set_number(bool value);
  public:

  // optional bool uppercase = 5 [json_name = "uppercase"];
  bool has_uppercase() const;
  private:
  bool _internal_has_uppercase() const;
  public:
  void clear_uppercase();
  bool uppercase() const;
  void set_uppercase(bool value);
  private:
  bool _internal_uppercase() const;
  void _internal_set_uppercase(bool value);
  public:

  // optional bool symbol = 6 [json_name = "symbol"];
  bool has_symbol() const;
  private:
  bool _internal_has_symbol() const;
  public:
  void clear_symbol();
  bool symbol() const;
  void set_symbol(bool value);
  private:
  bool _internal_symbol() const;
  void _internal_set_symbol(bool value);
  public:

  // optional bool enable_forgot_link = 7 [json_name = "enableForgotLink"];
  bool has_enable_forgot_link() const;
  private:
  bool _internal_has_enable_forgot_link() const;
  public:
  void clear_enable_forgot_link();
  bool enable_forgot_link() const;
  void set_enable_forgot_link(bool value);
  private:
  bool _internal_enable_forgot_link() const;
  void _internal_set_enable_forgot_link(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigPassword)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t minimum_length_;
  int32_t maximum_lenght_;
  bool lowercase_;
  bool number_;
  bool uppercase_;
  bool symbol_;
  bool enable_forgot_link_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigFile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigFile) */ {
 public:
  inline ConfigFile() : ConfigFile(nullptr) {}
  ~ConfigFile() override;
  explicit constexpr ConfigFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigFile(const ConfigFile& from);
  ConfigFile(ConfigFile&& from) noexcept
    : ConfigFile() {
    *this = ::std::move(from);
  }

  inline ConfigFile& operator=(const ConfigFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigFile& operator=(ConfigFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigFile* internal_default_instance() {
    return reinterpret_cast<const ConfigFile*>(
               &_ConfigFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConfigFile& a, ConfigFile& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigFile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigFile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigFile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigFile";
  }
  protected:
  explicit ConfigFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDriverNameFieldNumber = 7,
    kDirectoryFieldNumber = 8,
    kPublicLinkSaltFieldNumber = 12,
    kInitialFontFieldNumber = 13,
    kAmazonS3AccessKeyIdFieldNumber = 14,
    kAmazonS3SecretAccessKeyFieldNumber = 15,
    kAmazonS3BucketFieldNumber = 16,
    kAmazonS3PathPrefixFieldNumber = 17,
    kAmazonS3RegionFieldNumber = 18,
    kAmazonS3EndpointFieldNumber = 19,
    kAmazonS3StorageClassFieldNumber = 26,
    kMaxFileSizeFieldNumber = 4,
    kMaxImageResolutionFieldNumber = 5,
    kMaxImageDecoderConcurrencyFieldNumber = 6,
    kEnableFileAttachmentsFieldNumber = 1,
    kEnableMobileUploadFieldNumber = 2,
    kEnableMobileDownloadFieldNumber = 3,
    kEnablePublicLinkFieldNumber = 9,
    kExtractContentFieldNumber = 10,
    kArchiveRecursionFieldNumber = 11,
    kAmazonS3SslFieldNumber = 20,
    kAmazonS3SignV2FieldNumber = 21,
    kAmazonS3RequestTimeoutMillisecondsFieldNumber = 24,
    kAmazonS3UploadPartSizeBytesFieldNumber = 25,
    kAmazonS3SseFieldNumber = 22,
    kAmazonS3TraceFieldNumber = 23,
  };
  // optional string driver_name = 7 [json_name = "driverName"];
  bool has_driver_name() const;
  private:
  bool _internal_has_driver_name() const;
  public:
  void clear_driver_name();
  const std::string& driver_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_driver_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_driver_name();
  PROTOBUF_NODISCARD std::string* release_driver_name();
  void set_allocated_driver_name(std::string* driver_name);
  private:
  const std::string& _internal_driver_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver_name(const std::string& value);
  std::string* _internal_mutable_driver_name();
  public:

  // optional string directory = 8 [json_name = "directory"];
  bool has_directory() const;
  private:
  bool _internal_has_directory() const;
  public:
  void clear_directory();
  const std::string& directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory();
  PROTOBUF_NODISCARD std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  private:
  const std::string& _internal_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // optional string public_link_salt = 12 [json_name = "publicLinkSalt"];
  bool has_public_link_salt() const;
  private:
  bool _internal_has_public_link_salt() const;
  public:
  void clear_public_link_salt();
  const std::string& public_link_salt() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_link_salt(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_link_salt();
  PROTOBUF_NODISCARD std::string* release_public_link_salt();
  void set_allocated_public_link_salt(std::string* public_link_salt);
  private:
  const std::string& _internal_public_link_salt() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_link_salt(const std::string& value);
  std::string* _internal_mutable_public_link_salt();
  public:

  // optional string initial_font = 13 [json_name = "initialFont"];
  bool has_initial_font() const;
  private:
  bool _internal_has_initial_font() const;
  public:
  void clear_initial_font();
  const std::string& initial_font() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_initial_font(ArgT0&& arg0, ArgT... args);
  std::string* mutable_initial_font();
  PROTOBUF_NODISCARD std::string* release_initial_font();
  void set_allocated_initial_font(std::string* initial_font);
  private:
  const std::string& _internal_initial_font() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_initial_font(const std::string& value);
  std::string* _internal_mutable_initial_font();
  public:

  // optional string amazon_s3_access_key_id = 14 [json_name = "amazonS3AccessKeyId"];
  bool has_amazon_s3_access_key_id() const;
  private:
  bool _internal_has_amazon_s3_access_key_id() const;
  public:
  void clear_amazon_s3_access_key_id();
  const std::string& amazon_s3_access_key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_access_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_access_key_id();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_access_key_id();
  void set_allocated_amazon_s3_access_key_id(std::string* amazon_s3_access_key_id);
  private:
  const std::string& _internal_amazon_s3_access_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_access_key_id(const std::string& value);
  std::string* _internal_mutable_amazon_s3_access_key_id();
  public:

  // optional string amazon_s3_secret_access_key = 15 [json_name = "amazonS3SecretAccessKey"];
  bool has_amazon_s3_secret_access_key() const;
  private:
  bool _internal_has_amazon_s3_secret_access_key() const;
  public:
  void clear_amazon_s3_secret_access_key();
  const std::string& amazon_s3_secret_access_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_secret_access_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_secret_access_key();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_secret_access_key();
  void set_allocated_amazon_s3_secret_access_key(std::string* amazon_s3_secret_access_key);
  private:
  const std::string& _internal_amazon_s3_secret_access_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_secret_access_key(const std::string& value);
  std::string* _internal_mutable_amazon_s3_secret_access_key();
  public:

  // optional string amazon_s3_bucket = 16 [json_name = "amazonS3Bucket"];
  bool has_amazon_s3_bucket() const;
  private:
  bool _internal_has_amazon_s3_bucket() const;
  public:
  void clear_amazon_s3_bucket();
  const std::string& amazon_s3_bucket() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_bucket(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_bucket();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_bucket();
  void set_allocated_amazon_s3_bucket(std::string* amazon_s3_bucket);
  private:
  const std::string& _internal_amazon_s3_bucket() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_bucket(const std::string& value);
  std::string* _internal_mutable_amazon_s3_bucket();
  public:

  // optional string amazon_s3_path_prefix = 17 [json_name = "amazonS3PathPrefix"];
  bool has_amazon_s3_path_prefix() const;
  private:
  bool _internal_has_amazon_s3_path_prefix() const;
  public:
  void clear_amazon_s3_path_prefix();
  const std::string& amazon_s3_path_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_path_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_path_prefix();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_path_prefix();
  void set_allocated_amazon_s3_path_prefix(std::string* amazon_s3_path_prefix);
  private:
  const std::string& _internal_amazon_s3_path_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_path_prefix(const std::string& value);
  std::string* _internal_mutable_amazon_s3_path_prefix();
  public:

  // optional string amazon_s3_region = 18 [json_name = "amazonS3Region"];
  bool has_amazon_s3_region() const;
  private:
  bool _internal_has_amazon_s3_region() const;
  public:
  void clear_amazon_s3_region();
  const std::string& amazon_s3_region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_region();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_region();
  void set_allocated_amazon_s3_region(std::string* amazon_s3_region);
  private:
  const std::string& _internal_amazon_s3_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_region(const std::string& value);
  std::string* _internal_mutable_amazon_s3_region();
  public:

  // optional string amazon_s3_endpoint = 19 [json_name = "amazonS3Endpoint"];
  bool has_amazon_s3_endpoint() const;
  private:
  bool _internal_has_amazon_s3_endpoint() const;
  public:
  void clear_amazon_s3_endpoint();
  const std::string& amazon_s3_endpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_endpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_endpoint();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_endpoint();
  void set_allocated_amazon_s3_endpoint(std::string* amazon_s3_endpoint);
  private:
  const std::string& _internal_amazon_s3_endpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_endpoint(const std::string& value);
  std::string* _internal_mutable_amazon_s3_endpoint();
  public:

  // optional string amazon_s3_storage_class = 26 [json_name = "amazonS3StorageClass"];
  bool has_amazon_s3_storage_class() const;
  private:
  bool _internal_has_amazon_s3_storage_class() const;
  public:
  void clear_amazon_s3_storage_class();
  const std::string& amazon_s3_storage_class() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_amazon_s3_storage_class(ArgT0&& arg0, ArgT... args);
  std::string* mutable_amazon_s3_storage_class();
  PROTOBUF_NODISCARD std::string* release_amazon_s3_storage_class();
  void set_allocated_amazon_s3_storage_class(std::string* amazon_s3_storage_class);
  private:
  const std::string& _internal_amazon_s3_storage_class() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_amazon_s3_storage_class(const std::string& value);
  std::string* _internal_mutable_amazon_s3_storage_class();
  public:

  // optional int64 max_file_size = 4 [json_name = "maxFileSize"];
  bool has_max_file_size() const;
  private:
  bool _internal_has_max_file_size() const;
  public:
  void clear_max_file_size();
  int64_t max_file_size() const;
  void set_max_file_size(int64_t value);
  private:
  int64_t _internal_max_file_size() const;
  void _internal_set_max_file_size(int64_t value);
  public:

  // optional int64 max_image_resolution = 5 [json_name = "maxImageResolution"];
  bool has_max_image_resolution() const;
  private:
  bool _internal_has_max_image_resolution() const;
  public:
  void clear_max_image_resolution();
  int64_t max_image_resolution() const;
  void set_max_image_resolution(int64_t value);
  private:
  int64_t _internal_max_image_resolution() const;
  void _internal_set_max_image_resolution(int64_t value);
  public:

  // optional int64 max_image_decoder_concurrency = 6 [json_name = "maxImageDecoderConcurrency"];
  bool has_max_image_decoder_concurrency() const;
  private:
  bool _internal_has_max_image_decoder_concurrency() const;
  public:
  void clear_max_image_decoder_concurrency();
  int64_t max_image_decoder_concurrency() const;
  void set_max_image_decoder_concurrency(int64_t value);
  private:
  int64_t _internal_max_image_decoder_concurrency() const;
  void _internal_set_max_image_decoder_concurrency(int64_t value);
  public:

  // optional bool enable_file_attachments = 1 [json_name = "enableFileAttachments"];
  bool has_enable_file_attachments() const;
  private:
  bool _internal_has_enable_file_attachments() const;
  public:
  void clear_enable_file_attachments();
  bool enable_file_attachments() const;
  void set_enable_file_attachments(bool value);
  private:
  bool _internal_enable_file_attachments() const;
  void _internal_set_enable_file_attachments(bool value);
  public:

  // optional bool enable_mobile_upload = 2 [json_name = "enableMobileUpload"];
  bool has_enable_mobile_upload() const;
  private:
  bool _internal_has_enable_mobile_upload() const;
  public:
  void clear_enable_mobile_upload();
  bool enable_mobile_upload() const;
  void set_enable_mobile_upload(bool value);
  private:
  bool _internal_enable_mobile_upload() const;
  void _internal_set_enable_mobile_upload(bool value);
  public:

  // optional bool enable_mobile_download = 3 [json_name = "enableMobileDownload"];
  bool has_enable_mobile_download() const;
  private:
  bool _internal_has_enable_mobile_download() const;
  public:
  void clear_enable_mobile_download();
  bool enable_mobile_download() const;
  void set_enable_mobile_download(bool value);
  private:
  bool _internal_enable_mobile_download() const;
  void _internal_set_enable_mobile_download(bool value);
  public:

  // optional bool enable_public_link = 9 [json_name = "enablePublicLink"];
  bool has_enable_public_link() const;
  private:
  bool _internal_has_enable_public_link() const;
  public:
  void clear_enable_public_link();
  bool enable_public_link() const;
  void set_enable_public_link(bool value);
  private:
  bool _internal_enable_public_link() const;
  void _internal_set_enable_public_link(bool value);
  public:

  // optional bool extract_content = 10 [json_name = "extractContent"];
  bool has_extract_content() const;
  private:
  bool _internal_has_extract_content() const;
  public:
  void clear_extract_content();
  bool extract_content() const;
  void set_extract_content(bool value);
  private:
  bool _internal_extract_content() const;
  void _internal_set_extract_content(bool value);
  public:

  // optional bool archive_recursion = 11 [json_name = "archiveRecursion"];
  bool has_archive_recursion() const;
  private:
  bool _internal_has_archive_recursion() const;
  public:
  void clear_archive_recursion();
  bool archive_recursion() const;
  void set_archive_recursion(bool value);
  private:
  bool _internal_archive_recursion() const;
  void _internal_set_archive_recursion(bool value);
  public:

  // optional bool amazon_s3_ssl = 20 [json_name = "amazonS3Ssl"];
  bool has_amazon_s3_ssl() const;
  private:
  bool _internal_has_amazon_s3_ssl() const;
  public:
  void clear_amazon_s3_ssl();
  bool amazon_s3_ssl() const;
  void set_amazon_s3_ssl(bool value);
  private:
  bool _internal_amazon_s3_ssl() const;
  void _internal_set_amazon_s3_ssl(bool value);
  public:

  // optional bool amazon_s3_sign_v2 = 21 [json_name = "amazonS3SignV2"];
  bool has_amazon_s3_sign_v2() const;
  private:
  bool _internal_has_amazon_s3_sign_v2() const;
  public:
  void clear_amazon_s3_sign_v2();
  bool amazon_s3_sign_v2() const;
  void set_amazon_s3_sign_v2(bool value);
  private:
  bool _internal_amazon_s3_sign_v2() const;
  void _internal_set_amazon_s3_sign_v2(bool value);
  public:

  // optional int64 amazon_s3_request_timeout_milliseconds = 24 [json_name = "amazonS3RequestTimeoutMilliseconds"];
  bool has_amazon_s3_request_timeout_milliseconds() const;
  private:
  bool _internal_has_amazon_s3_request_timeout_milliseconds() const;
  public:
  void clear_amazon_s3_request_timeout_milliseconds();
  int64_t amazon_s3_request_timeout_milliseconds() const;
  void set_amazon_s3_request_timeout_milliseconds(int64_t value);
  private:
  int64_t _internal_amazon_s3_request_timeout_milliseconds() const;
  void _internal_set_amazon_s3_request_timeout_milliseconds(int64_t value);
  public:

  // optional int64 amazon_s3_upload_part_size_bytes = 25 [json_name = "amazonS3UploadPartSizeBytes"];
  bool has_amazon_s3_upload_part_size_bytes() const;
  private:
  bool _internal_has_amazon_s3_upload_part_size_bytes() const;
  public:
  void clear_amazon_s3_upload_part_size_bytes();
  int64_t amazon_s3_upload_part_size_bytes() const;
  void set_amazon_s3_upload_part_size_bytes(int64_t value);
  private:
  int64_t _internal_amazon_s3_upload_part_size_bytes() const;
  void _internal_set_amazon_s3_upload_part_size_bytes(int64_t value);
  public:

  // optional bool amazon_s3_sse = 22 [json_name = "amazonS3Sse"];
  bool has_amazon_s3_sse() const;
  private:
  bool _internal_has_amazon_s3_sse() const;
  public:
  void clear_amazon_s3_sse();
  bool amazon_s3_sse() const;
  void set_amazon_s3_sse(bool value);
  private:
  bool _internal_amazon_s3_sse() const;
  void _internal_set_amazon_s3_sse(bool value);
  public:

  // optional bool amazon_s3_trace = 23 [json_name = "amazonS3Trace"];
  bool has_amazon_s3_trace() const;
  private:
  bool _internal_has_amazon_s3_trace() const;
  public:
  void clear_amazon_s3_trace();
  bool amazon_s3_trace() const;
  void set_amazon_s3_trace(bool value);
  private:
  bool _internal_amazon_s3_trace() const;
  void _internal_set_amazon_s3_trace(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr driver_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_link_salt_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr initial_font_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_access_key_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_secret_access_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_bucket_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_path_prefix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_endpoint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr amazon_s3_storage_class_;
  int64_t max_file_size_;
  int64_t max_image_resolution_;
  int64_t max_image_decoder_concurrency_;
  bool enable_file_attachments_;
  bool enable_mobile_upload_;
  bool enable_mobile_download_;
  bool enable_public_link_;
  bool extract_content_;
  bool archive_recursion_;
  bool amazon_s3_ssl_;
  bool amazon_s3_sign_v2_;
  int64_t amazon_s3_request_timeout_milliseconds_;
  int64_t amazon_s3_upload_part_size_bytes_;
  bool amazon_s3_sse_;
  bool amazon_s3_trace_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigEmail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigEmail) */ {
 public:
  inline ConfigEmail() : ConfigEmail(nullptr) {}
  ~ConfigEmail() override;
  explicit constexpr ConfigEmail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigEmail(const ConfigEmail& from);
  ConfigEmail(ConfigEmail&& from) noexcept
    : ConfigEmail() {
    *this = ::std::move(from);
  }

  inline ConfigEmail& operator=(const ConfigEmail& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigEmail& operator=(ConfigEmail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigEmail& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigEmail* internal_default_instance() {
    return reinterpret_cast<const ConfigEmail*>(
               &_ConfigEmail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ConfigEmail& a, ConfigEmail& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigEmail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigEmail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigEmail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigEmail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigEmail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigEmail& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigEmail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigEmail";
  }
  protected:
  explicit ConfigEmail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedbackEmailFieldNumber = 3,
    kReplyToAddressFieldNumber = 4,
    kSmtpUsernameFieldNumber = 6,
    kSmtpPasswordFieldNumber = 7,
    kSmtpServerFieldNumber = 8,
    kSmtpPortFieldNumber = 9,
    kConnectionSecurityFieldNumber = 11,
    kPushNotificationServerFieldNumber = 13,
    kPushNotificationContentsFieldNumber = 14,
    kEmailNotificationContentsTypeFieldNumber = 20,
    kLoginButtonColorFieldNumber = 21,
    kLoginButtonBorderColorFieldNumber = 22,
    kLoginButtonTextColorFieldNumber = 23,
    kSendEmailNotificationsFieldNumber = 1,
    kRequireEmailVerificationFieldNumber = 2,
    kEnableSmtpAuthFieldNumber = 5,
    kSendPushNotificationsFieldNumber = 12,
    kSmtpServerTimeoutFieldNumber = 10,
    kPushNotificationBufferFieldNumber = 15,
    kEmailBatchingBufferSizeFieldNumber = 17,
    kEnableEmailBatchingFieldNumber = 16,
    kSkipServerCertificateVerificationFieldNumber = 19,
    kEmailBatchingIntervalFieldNumber = 18,
  };
  // optional string feedback_email = 3 [json_name = "feedbackEmail"];
  bool has_feedback_email() const;
  private:
  bool _internal_has_feedback_email() const;
  public:
  void clear_feedback_email();
  const std::string& feedback_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feedback_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feedback_email();
  PROTOBUF_NODISCARD std::string* release_feedback_email();
  void set_allocated_feedback_email(std::string* feedback_email);
  private:
  const std::string& _internal_feedback_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feedback_email(const std::string& value);
  std::string* _internal_mutable_feedback_email();
  public:

  // optional string reply_to_address = 4 [json_name = "replyToAddress"];
  bool has_reply_to_address() const;
  private:
  bool _internal_has_reply_to_address() const;
  public:
  void clear_reply_to_address();
  const std::string& reply_to_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reply_to_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reply_to_address();
  PROTOBUF_NODISCARD std::string* release_reply_to_address();
  void set_allocated_reply_to_address(std::string* reply_to_address);
  private:
  const std::string& _internal_reply_to_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reply_to_address(const std::string& value);
  std::string* _internal_mutable_reply_to_address();
  public:

  // optional string smtp_username = 6 [json_name = "smtpUsername"];
  bool has_smtp_username() const;
  private:
  bool _internal_has_smtp_username() const;
  public:
  void clear_smtp_username();
  const std::string& smtp_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smtp_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smtp_username();
  PROTOBUF_NODISCARD std::string* release_smtp_username();
  void set_allocated_smtp_username(std::string* smtp_username);
  private:
  const std::string& _internal_smtp_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smtp_username(const std::string& value);
  std::string* _internal_mutable_smtp_username();
  public:

  // optional string smtp_password = 7 [json_name = "smtpPassword"];
  bool has_smtp_password() const;
  private:
  bool _internal_has_smtp_password() const;
  public:
  void clear_smtp_password();
  const std::string& smtp_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smtp_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smtp_password();
  PROTOBUF_NODISCARD std::string* release_smtp_password();
  void set_allocated_smtp_password(std::string* smtp_password);
  private:
  const std::string& _internal_smtp_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smtp_password(const std::string& value);
  std::string* _internal_mutable_smtp_password();
  public:

  // optional string smtp_server = 8 [json_name = "smtpServer"];
  bool has_smtp_server() const;
  private:
  bool _internal_has_smtp_server() const;
  public:
  void clear_smtp_server();
  const std::string& smtp_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smtp_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smtp_server();
  PROTOBUF_NODISCARD std::string* release_smtp_server();
  void set_allocated_smtp_server(std::string* smtp_server);
  private:
  const std::string& _internal_smtp_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smtp_server(const std::string& value);
  std::string* _internal_mutable_smtp_server();
  public:

  // optional string smtp_port = 9 [json_name = "smtpPort"];
  bool has_smtp_port() const;
  private:
  bool _internal_has_smtp_port() const;
  public:
  void clear_smtp_port();
  const std::string& smtp_port() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_smtp_port(ArgT0&& arg0, ArgT... args);
  std::string* mutable_smtp_port();
  PROTOBUF_NODISCARD std::string* release_smtp_port();
  void set_allocated_smtp_port(std::string* smtp_port);
  private:
  const std::string& _internal_smtp_port() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_smtp_port(const std::string& value);
  std::string* _internal_mutable_smtp_port();
  public:

  // optional string connection_security = 11 [json_name = "connectionSecurity"];
  bool has_connection_security() const;
  private:
  bool _internal_has_connection_security() const;
  public:
  void clear_connection_security();
  const std::string& connection_security() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_security(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_security();
  PROTOBUF_NODISCARD std::string* release_connection_security();
  void set_allocated_connection_security(std::string* connection_security);
  private:
  const std::string& _internal_connection_security() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_security(const std::string& value);
  std::string* _internal_mutable_connection_security();
  public:

  // optional string push_notification_server = 13 [json_name = "pushNotificationServer"];
  bool has_push_notification_server() const;
  private:
  bool _internal_has_push_notification_server() const;
  public:
  void clear_push_notification_server();
  const std::string& push_notification_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_push_notification_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_push_notification_server();
  PROTOBUF_NODISCARD std::string* release_push_notification_server();
  void set_allocated_push_notification_server(std::string* push_notification_server);
  private:
  const std::string& _internal_push_notification_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_push_notification_server(const std::string& value);
  std::string* _internal_mutable_push_notification_server();
  public:

  // optional string push_notification_contents = 14 [json_name = "pushNotificationContents"];
  bool has_push_notification_contents() const;
  private:
  bool _internal_has_push_notification_contents() const;
  public:
  void clear_push_notification_contents();
  const std::string& push_notification_contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_push_notification_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_push_notification_contents();
  PROTOBUF_NODISCARD std::string* release_push_notification_contents();
  void set_allocated_push_notification_contents(std::string* push_notification_contents);
  private:
  const std::string& _internal_push_notification_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_push_notification_contents(const std::string& value);
  std::string* _internal_mutable_push_notification_contents();
  public:

  // optional string email_notification_contents_type = 20 [json_name = "emailNotificationContentsType"];
  bool has_email_notification_contents_type() const;
  private:
  bool _internal_has_email_notification_contents_type() const;
  public:
  void clear_email_notification_contents_type();
  const std::string& email_notification_contents_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_notification_contents_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_notification_contents_type();
  PROTOBUF_NODISCARD std::string* release_email_notification_contents_type();
  void set_allocated_email_notification_contents_type(std::string* email_notification_contents_type);
  private:
  const std::string& _internal_email_notification_contents_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_notification_contents_type(const std::string& value);
  std::string* _internal_mutable_email_notification_contents_type();
  public:

  // optional string login_button_color = 21 [json_name = "loginButtonColor"];
  bool has_login_button_color() const;
  private:
  bool _internal_has_login_button_color() const;
  public:
  void clear_login_button_color();
  const std::string& login_button_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_color();
  PROTOBUF_NODISCARD std::string* release_login_button_color();
  void set_allocated_login_button_color(std::string* login_button_color);
  private:
  const std::string& _internal_login_button_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_color(const std::string& value);
  std::string* _internal_mutable_login_button_color();
  public:

  // optional string login_button_border_color = 22 [json_name = "loginButtonBorderColor"];
  bool has_login_button_border_color() const;
  private:
  bool _internal_has_login_button_border_color() const;
  public:
  void clear_login_button_border_color();
  const std::string& login_button_border_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_border_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_border_color();
  PROTOBUF_NODISCARD std::string* release_login_button_border_color();
  void set_allocated_login_button_border_color(std::string* login_button_border_color);
  private:
  const std::string& _internal_login_button_border_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_border_color(const std::string& value);
  std::string* _internal_mutable_login_button_border_color();
  public:

  // optional string login_button_text_color = 23 [json_name = "loginButtonTextColor"];
  bool has_login_button_text_color() const;
  private:
  bool _internal_has_login_button_text_color() const;
  public:
  void clear_login_button_text_color();
  const std::string& login_button_text_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_text_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_text_color();
  PROTOBUF_NODISCARD std::string* release_login_button_text_color();
  void set_allocated_login_button_text_color(std::string* login_button_text_color);
  private:
  const std::string& _internal_login_button_text_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_text_color(const std::string& value);
  std::string* _internal_mutable_login_button_text_color();
  public:

  // optional bool send_email_notifications = 1 [json_name = "sendEmailNotifications"];
  bool has_send_email_notifications() const;
  private:
  bool _internal_has_send_email_notifications() const;
  public:
  void clear_send_email_notifications();
  bool send_email_notifications() const;
  void set_send_email_notifications(bool value);
  private:
  bool _internal_send_email_notifications() const;
  void _internal_set_send_email_notifications(bool value);
  public:

  // optional bool require_email_verification = 2 [json_name = "requireEmailVerification"];
  bool has_require_email_verification() const;
  private:
  bool _internal_has_require_email_verification() const;
  public:
  void clear_require_email_verification();
  bool require_email_verification() const;
  void set_require_email_verification(bool value);
  private:
  bool _internal_require_email_verification() const;
  void _internal_set_require_email_verification(bool value);
  public:

  // optional bool enable_smtp_auth = 5 [json_name = "enableSmtpAuth"];
  bool has_enable_smtp_auth() const;
  private:
  bool _internal_has_enable_smtp_auth() const;
  public:
  void clear_enable_smtp_auth();
  bool enable_smtp_auth() const;
  void set_enable_smtp_auth(bool value);
  private:
  bool _internal_enable_smtp_auth() const;
  void _internal_set_enable_smtp_auth(bool value);
  public:

  // optional bool send_push_notifications = 12 [json_name = "sendPushNotifications"];
  bool has_send_push_notifications() const;
  private:
  bool _internal_has_send_push_notifications() const;
  public:
  void clear_send_push_notifications();
  bool send_push_notifications() const;
  void set_send_push_notifications(bool value);
  private:
  bool _internal_send_push_notifications() const;
  void _internal_set_send_push_notifications(bool value);
  public:

  // optional int32 smtp_server_timeout = 10 [json_name = "smtpServerTimeout"];
  bool has_smtp_server_timeout() const;
  private:
  bool _internal_has_smtp_server_timeout() const;
  public:
  void clear_smtp_server_timeout();
  int32_t smtp_server_timeout() const;
  void set_smtp_server_timeout(int32_t value);
  private:
  int32_t _internal_smtp_server_timeout() const;
  void _internal_set_smtp_server_timeout(int32_t value);
  public:

  // optional int32 push_notification_buffer = 15 [json_name = "pushNotificationBuffer"];
  bool has_push_notification_buffer() const;
  private:
  bool _internal_has_push_notification_buffer() const;
  public:
  void clear_push_notification_buffer();
  int32_t push_notification_buffer() const;
  void set_push_notification_buffer(int32_t value);
  private:
  int32_t _internal_push_notification_buffer() const;
  void _internal_set_push_notification_buffer(int32_t value);
  public:

  // optional int32 email_batching_buffer_size = 17 [json_name = "emailBatchingBufferSize"];
  bool has_email_batching_buffer_size() const;
  private:
  bool _internal_has_email_batching_buffer_size() const;
  public:
  void clear_email_batching_buffer_size();
  int32_t email_batching_buffer_size() const;
  void set_email_batching_buffer_size(int32_t value);
  private:
  int32_t _internal_email_batching_buffer_size() const;
  void _internal_set_email_batching_buffer_size(int32_t value);
  public:

  // optional bool enable_email_batching = 16 [json_name = "enableEmailBatching"];
  bool has_enable_email_batching() const;
  private:
  bool _internal_has_enable_email_batching() const;
  public:
  void clear_enable_email_batching();
  bool enable_email_batching() const;
  void set_enable_email_batching(bool value);
  private:
  bool _internal_enable_email_batching() const;
  void _internal_set_enable_email_batching(bool value);
  public:

  // optional bool skip_server_certificate_verification = 19 [json_name = "skipServerCertificateVerification"];
  bool has_skip_server_certificate_verification() const;
  private:
  bool _internal_has_skip_server_certificate_verification() const;
  public:
  void clear_skip_server_certificate_verification();
  bool skip_server_certificate_verification() const;
  void set_skip_server_certificate_verification(bool value);
  private:
  bool _internal_skip_server_certificate_verification() const;
  void _internal_set_skip_server_certificate_verification(bool value);
  public:

  // optional int32 email_batching_interval = 18 [json_name = "emailBatchingInterval"];
  bool has_email_batching_interval() const;
  private:
  bool _internal_has_email_batching_interval() const;
  public:
  void clear_email_batching_interval();
  int32_t email_batching_interval() const;
  void set_email_batching_interval(int32_t value);
  private:
  int32_t _internal_email_batching_interval() const;
  void _internal_set_email_batching_interval(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigEmail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feedback_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reply_to_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smtp_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smtp_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smtp_server_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr smtp_port_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_security_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr push_notification_server_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr push_notification_contents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_notification_contents_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_border_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_text_color_;
  bool send_email_notifications_;
  bool require_email_verification_;
  bool enable_smtp_auth_;
  bool send_push_notifications_;
  int32_t smtp_server_timeout_;
  int32_t push_notification_buffer_;
  int32_t email_batching_buffer_size_;
  bool enable_email_batching_;
  bool skip_server_certificate_verification_;
  int32_t email_batching_interval_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigRateLimit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigRateLimit) */ {
 public:
  inline ConfigRateLimit() : ConfigRateLimit(nullptr) {}
  ~ConfigRateLimit() override;
  explicit constexpr ConfigRateLimit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigRateLimit(const ConfigRateLimit& from);
  ConfigRateLimit(ConfigRateLimit&& from) noexcept
    : ConfigRateLimit() {
    *this = ::std::move(from);
  }

  inline ConfigRateLimit& operator=(const ConfigRateLimit& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigRateLimit& operator=(ConfigRateLimit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigRateLimit& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigRateLimit* internal_default_instance() {
    return reinterpret_cast<const ConfigRateLimit*>(
               &_ConfigRateLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConfigRateLimit& a, ConfigRateLimit& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigRateLimit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigRateLimit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigRateLimit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigRateLimit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigRateLimit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigRateLimit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigRateLimit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigRateLimit";
  }
  protected:
  explicit ConfigRateLimit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVaryByHeaderFieldNumber = 7,
    kPerSecFieldNumber = 2,
    kMaxBurstFieldNumber = 3,
    kMemoryStoreSizeFieldNumber = 4,
    kEnableFieldNumber = 1,
    kVaryByRemoteAddrFieldNumber = 5,
    kVaryByUserFieldNumber = 6,
  };
  // string vary_by_header = 7 [json_name = "varyByHeader"];
  void clear_vary_by_header();
  const std::string& vary_by_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vary_by_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vary_by_header();
  PROTOBUF_NODISCARD std::string* release_vary_by_header();
  void set_allocated_vary_by_header(std::string* vary_by_header);
  private:
  const std::string& _internal_vary_by_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vary_by_header(const std::string& value);
  std::string* _internal_mutable_vary_by_header();
  public:

  // optional int32 per_sec = 2 [json_name = "perSec"];
  bool has_per_sec() const;
  private:
  bool _internal_has_per_sec() const;
  public:
  void clear_per_sec();
  int32_t per_sec() const;
  void set_per_sec(int32_t value);
  private:
  int32_t _internal_per_sec() const;
  void _internal_set_per_sec(int32_t value);
  public:

  // optional int32 max_burst = 3 [json_name = "maxBurst"];
  bool has_max_burst() const;
  private:
  bool _internal_has_max_burst() const;
  public:
  void clear_max_burst();
  int32_t max_burst() const;
  void set_max_burst(int32_t value);
  private:
  int32_t _internal_max_burst() const;
  void _internal_set_max_burst(int32_t value);
  public:

  // optional int32 memory_store_size = 4 [json_name = "memoryStoreSize"];
  bool has_memory_store_size() const;
  private:
  bool _internal_has_memory_store_size() const;
  public:
  void clear_memory_store_size();
  int32_t memory_store_size() const;
  void set_memory_store_size(int32_t value);
  private:
  int32_t _internal_memory_store_size() const;
  void _internal_set_memory_store_size(int32_t value);
  public:

  // optional bool enable = 1 [json_name = "enable"];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional bool vary_by_remote_addr = 5 [json_name = "varyByRemoteAddr"];
  bool has_vary_by_remote_addr() const;
  private:
  bool _internal_has_vary_by_remote_addr() const;
  public:
  void clear_vary_by_remote_addr();
  bool vary_by_remote_addr() const;
  void set_vary_by_remote_addr(bool value);
  private:
  bool _internal_vary_by_remote_addr() const;
  void _internal_set_vary_by_remote_addr(bool value);
  public:

  // optional bool vary_by_user = 6 [json_name = "varyByUser"];
  bool has_vary_by_user() const;
  private:
  bool _internal_has_vary_by_user() const;
  public:
  void clear_vary_by_user();
  bool vary_by_user() const;
  void set_vary_by_user(bool value);
  private:
  bool _internal_vary_by_user() const;
  void _internal_set_vary_by_user(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigRateLimit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vary_by_header_;
  int32_t per_sec_;
  int32_t max_burst_;
  int32_t memory_store_size_;
  bool enable_;
  bool vary_by_remote_addr_;
  bool vary_by_user_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigPrivacy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigPrivacy) */ {
 public:
  inline ConfigPrivacy() : ConfigPrivacy(nullptr) {}
  ~ConfigPrivacy() override;
  explicit constexpr ConfigPrivacy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigPrivacy(const ConfigPrivacy& from);
  ConfigPrivacy(ConfigPrivacy&& from) noexcept
    : ConfigPrivacy() {
    *this = ::std::move(from);
  }

  inline ConfigPrivacy& operator=(const ConfigPrivacy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigPrivacy& operator=(ConfigPrivacy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigPrivacy& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigPrivacy* internal_default_instance() {
    return reinterpret_cast<const ConfigPrivacy*>(
               &_ConfigPrivacy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ConfigPrivacy& a, ConfigPrivacy& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigPrivacy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigPrivacy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigPrivacy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigPrivacy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigPrivacy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigPrivacy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigPrivacy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigPrivacy";
  }
  protected:
  explicit ConfigPrivacy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShowEmailAddressFieldNumber = 1,
    kShowFullNameFieldNumber = 2,
  };
  // optional bool show_email_address = 1 [json_name = "showEmailAddress"];
  bool has_show_email_address() const;
  private:
  bool _internal_has_show_email_address() const;
  public:
  void clear_show_email_address();
  bool show_email_address() const;
  void set_show_email_address(bool value);
  private:
  bool _internal_show_email_address() const;
  void _internal_set_show_email_address(bool value);
  public:

  // optional bool show_full_name = 2 [json_name = "showFullName"];
  bool has_show_full_name() const;
  private:
  bool _internal_has_show_full_name() const;
  public:
  void clear_show_full_name();
  bool show_full_name() const;
  void set_show_full_name(bool value);
  private:
  bool _internal_show_full_name() const;
  void _internal_set_show_full_name(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigPrivacy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool show_email_address_;
  bool show_full_name_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigSupport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigSupport) */ {
 public:
  inline ConfigSupport() : ConfigSupport(nullptr) {}
  ~ConfigSupport() override;
  explicit constexpr ConfigSupport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigSupport(const ConfigSupport& from);
  ConfigSupport(ConfigSupport&& from) noexcept
    : ConfigSupport() {
    *this = ::std::move(from);
  }

  inline ConfigSupport& operator=(const ConfigSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigSupport& operator=(ConfigSupport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigSupport& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigSupport* internal_default_instance() {
    return reinterpret_cast<const ConfigSupport*>(
               &_ConfigSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ConfigSupport& a, ConfigSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigSupport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigSupport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigSupport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigSupport& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSupport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigSupport";
  }
  protected:
  explicit ConfigSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermsOfServiceLinkFieldNumber = 1,
    kPrivacyPolicyLinkFieldNumber = 2,
    kAboutLinkFieldNumber = 3,
    kHelpLinkFieldNumber = 4,
    kReportAProblemLinkFieldNumber = 5,
    kForgotPasswordLinkFieldNumber = 6,
    kSupportEmailFieldNumber = 7,
  };
  // optional string terms_of_service_link = 1 [json_name = "termsOfServiceLink"];
  bool has_terms_of_service_link() const;
  private:
  bool _internal_has_terms_of_service_link() const;
  public:
  void clear_terms_of_service_link();
  const std::string& terms_of_service_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_terms_of_service_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_terms_of_service_link();
  PROTOBUF_NODISCARD std::string* release_terms_of_service_link();
  void set_allocated_terms_of_service_link(std::string* terms_of_service_link);
  private:
  const std::string& _internal_terms_of_service_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_terms_of_service_link(const std::string& value);
  std::string* _internal_mutable_terms_of_service_link();
  public:

  // optional string privacy_policy_link = 2 [json_name = "privacyPolicyLink"];
  bool has_privacy_policy_link() const;
  private:
  bool _internal_has_privacy_policy_link() const;
  public:
  void clear_privacy_policy_link();
  const std::string& privacy_policy_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_privacy_policy_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_privacy_policy_link();
  PROTOBUF_NODISCARD std::string* release_privacy_policy_link();
  void set_allocated_privacy_policy_link(std::string* privacy_policy_link);
  private:
  const std::string& _internal_privacy_policy_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_privacy_policy_link(const std::string& value);
  std::string* _internal_mutable_privacy_policy_link();
  public:

  // optional string about_link = 3 [json_name = "aboutLink"];
  bool has_about_link() const;
  private:
  bool _internal_has_about_link() const;
  public:
  void clear_about_link();
  const std::string& about_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_about_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_about_link();
  PROTOBUF_NODISCARD std::string* release_about_link();
  void set_allocated_about_link(std::string* about_link);
  private:
  const std::string& _internal_about_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_about_link(const std::string& value);
  std::string* _internal_mutable_about_link();
  public:

  // optional string help_link = 4 [json_name = "helpLink"];
  bool has_help_link() const;
  private:
  bool _internal_has_help_link() const;
  public:
  void clear_help_link();
  const std::string& help_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_help_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_help_link();
  PROTOBUF_NODISCARD std::string* release_help_link();
  void set_allocated_help_link(std::string* help_link);
  private:
  const std::string& _internal_help_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_help_link(const std::string& value);
  std::string* _internal_mutable_help_link();
  public:

  // optional string report_a_problem_link = 5 [json_name = "reportAProblemLink"];
  bool has_report_a_problem_link() const;
  private:
  bool _internal_has_report_a_problem_link() const;
  public:
  void clear_report_a_problem_link();
  const std::string& report_a_problem_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_report_a_problem_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_report_a_problem_link();
  PROTOBUF_NODISCARD std::string* release_report_a_problem_link();
  void set_allocated_report_a_problem_link(std::string* report_a_problem_link);
  private:
  const std::string& _internal_report_a_problem_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_report_a_problem_link(const std::string& value);
  std::string* _internal_mutable_report_a_problem_link();
  public:

  // optional string forgot_password_link = 6 [json_name = "forgotPasswordLink"];
  bool has_forgot_password_link() const;
  private:
  bool _internal_has_forgot_password_link() const;
  public:
  void clear_forgot_password_link();
  const std::string& forgot_password_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_forgot_password_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_forgot_password_link();
  PROTOBUF_NODISCARD std::string* release_forgot_password_link();
  void set_allocated_forgot_password_link(std::string* forgot_password_link);
  private:
  const std::string& _internal_forgot_password_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_forgot_password_link(const std::string& value);
  std::string* _internal_mutable_forgot_password_link();
  public:

  // optional string support_email = 7 [json_name = "supportEmail"];
  bool has_support_email() const;
  private:
  bool _internal_has_support_email() const;
  public:
  void clear_support_email();
  const std::string& support_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_support_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_support_email();
  PROTOBUF_NODISCARD std::string* release_support_email();
  void set_allocated_support_email(std::string* support_email);
  private:
  const std::string& _internal_support_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_support_email(const std::string& value);
  std::string* _internal_mutable_support_email();
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigSupport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr terms_of_service_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr privacy_policy_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr about_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr help_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_a_problem_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr forgot_password_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr support_email_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigLocalization final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigLocalization) */ {
 public:
  inline ConfigLocalization() : ConfigLocalization(nullptr) {}
  ~ConfigLocalization() override;
  explicit constexpr ConfigLocalization(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigLocalization(const ConfigLocalization& from);
  ConfigLocalization(ConfigLocalization&& from) noexcept
    : ConfigLocalization() {
    *this = ::std::move(from);
  }

  inline ConfigLocalization& operator=(const ConfigLocalization& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigLocalization& operator=(ConfigLocalization&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigLocalization& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigLocalization* internal_default_instance() {
    return reinterpret_cast<const ConfigLocalization*>(
               &_ConfigLocalization_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ConfigLocalization& a, ConfigLocalization& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigLocalization* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigLocalization* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigLocalization* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigLocalization>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigLocalization& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigLocalization& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigLocalization* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigLocalization";
  }
  protected:
  explicit ConfigLocalization(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultServerLocaleFieldNumber = 1,
    kDefaultClientLocaleFieldNumber = 2,
    kAvailableLocalesFieldNumber = 3,
  };
  // optional string default_server_locale = 1 [json_name = "defaultServerLocale"];
  bool has_default_server_locale() const;
  private:
  bool _internal_has_default_server_locale() const;
  public:
  void clear_default_server_locale();
  const std::string& default_server_locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_server_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_server_locale();
  PROTOBUF_NODISCARD std::string* release_default_server_locale();
  void set_allocated_default_server_locale(std::string* default_server_locale);
  private:
  const std::string& _internal_default_server_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_server_locale(const std::string& value);
  std::string* _internal_mutable_default_server_locale();
  public:

  // optional string default_client_locale = 2 [json_name = "defaultClientLocale"];
  bool has_default_client_locale() const;
  private:
  bool _internal_has_default_client_locale() const;
  public:
  void clear_default_client_locale();
  const std::string& default_client_locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_client_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_client_locale();
  PROTOBUF_NODISCARD std::string* release_default_client_locale();
  void set_allocated_default_client_locale(std::string* default_client_locale);
  private:
  const std::string& _internal_default_client_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_client_locale(const std::string& value);
  std::string* _internal_mutable_default_client_locale();
  public:

  // optional string available_locales = 3 [json_name = "availableLocales"];
  bool has_available_locales() const;
  private:
  bool _internal_has_available_locales() const;
  public:
  void clear_available_locales();
  const std::string& available_locales() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_available_locales(ArgT0&& arg0, ArgT... args);
  std::string* mutable_available_locales();
  PROTOBUF_NODISCARD std::string* release_available_locales();
  void set_allocated_available_locales(std::string* available_locales);
  private:
  const std::string& _internal_available_locales() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_available_locales(const std::string& value);
  std::string* _internal_mutable_available_locales();
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigLocalization)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_server_locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_client_locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr available_locales_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigLdap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigLdap) */ {
 public:
  inline ConfigLdap() : ConfigLdap(nullptr) {}
  ~ConfigLdap() override;
  explicit constexpr ConfigLdap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigLdap(const ConfigLdap& from);
  ConfigLdap(ConfigLdap&& from) noexcept
    : ConfigLdap() {
    *this = ::std::move(from);
  }

  inline ConfigLdap& operator=(const ConfigLdap& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigLdap& operator=(ConfigLdap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigLdap& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigLdap* internal_default_instance() {
    return reinterpret_cast<const ConfigLdap*>(
               &_ConfigLdap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ConfigLdap& a, ConfigLdap& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigLdap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigLdap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigLdap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigLdap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigLdap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigLdap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigLdap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigLdap";
  }
  protected:
  explicit ConfigLdap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLdapServerFieldNumber = 3,
    kConnectionSecurityFieldNumber = 5,
    kBaseDnFieldNumber = 6,
    kBindUsernameFieldNumber = 7,
    kBindPasswordFieldNumber = 8,
    kUserFilterFieldNumber = 10,
    kGroupFilterFieldNumber = 11,
    kAdminFilterFieldNumber = 13,
    kGroupDisplayNameAttributeFieldNumber = 14,
    kGroupIdAttributeFieldNumber = 15,
    kFirstNameAttributeFieldNumber = 16,
    kLastNameAttributeFieldNumber = 17,
    kEmailAttributeFieldNumber = 18,
    kUsernameAttributeFieldNumber = 19,
    kNicknameAttributeFieldNumber = 20,
    kIdAttributeFieldNumber = 21,
    kPositionAttributeFieldNumber = 22,
    kLoginIdAttributeFieldNumber = 23,
    kPictureAttributeFieldNumber = 24,
    kLoginFieldNameFieldNumber = 28,
    kLoginButtonColorFieldNumber = 29,
    kLoginButtonBorderColorFieldNumber = 30,
    kLoginButtonTextColorFieldNumber = 31,
    kLdapPortFieldNumber = 4,
    kEnableFieldNumber = 1,
    kEnableSyncFieldNumber = 2,
    kEnableAdminFilterFieldNumber = 12,
    kMaximumLoginAttemptsFieldNumber = 9,
    kSyncIntervalMinutesFieldNumber = 25,
    kQueryTimeoutFieldNumber = 26,
    kMaxPageSizeFieldNumber = 27,
  };
  // optional string ldap_server = 3 [json_name = "ldapServer"];
  bool has_ldap_server() const;
  private:
  bool _internal_has_ldap_server() const;
  public:
  void clear_ldap_server();
  const std::string& ldap_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ldap_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ldap_server();
  PROTOBUF_NODISCARD std::string* release_ldap_server();
  void set_allocated_ldap_server(std::string* ldap_server);
  private:
  const std::string& _internal_ldap_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ldap_server(const std::string& value);
  std::string* _internal_mutable_ldap_server();
  public:

  // optional string connection_security = 5 [json_name = "connectionSecurity"];
  bool has_connection_security() const;
  private:
  bool _internal_has_connection_security() const;
  public:
  void clear_connection_security();
  const std::string& connection_security() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_connection_security(ArgT0&& arg0, ArgT... args);
  std::string* mutable_connection_security();
  PROTOBUF_NODISCARD std::string* release_connection_security();
  void set_allocated_connection_security(std::string* connection_security);
  private:
  const std::string& _internal_connection_security() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_connection_security(const std::string& value);
  std::string* _internal_mutable_connection_security();
  public:

  // optional string base_dn = 6 [json_name = "baseDn"];
  bool has_base_dn() const;
  private:
  bool _internal_has_base_dn() const;
  public:
  void clear_base_dn();
  const std::string& base_dn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_dn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_dn();
  PROTOBUF_NODISCARD std::string* release_base_dn();
  void set_allocated_base_dn(std::string* base_dn);
  private:
  const std::string& _internal_base_dn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_dn(const std::string& value);
  std::string* _internal_mutable_base_dn();
  public:

  // optional string bind_username = 7 [json_name = "bindUsername"];
  bool has_bind_username() const;
  private:
  bool _internal_has_bind_username() const;
  public:
  void clear_bind_username();
  const std::string& bind_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bind_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bind_username();
  PROTOBUF_NODISCARD std::string* release_bind_username();
  void set_allocated_bind_username(std::string* bind_username);
  private:
  const std::string& _internal_bind_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bind_username(const std::string& value);
  std::string* _internal_mutable_bind_username();
  public:

  // optional string bind_password = 8 [json_name = "bindPassword"];
  bool has_bind_password() const;
  private:
  bool _internal_has_bind_password() const;
  public:
  void clear_bind_password();
  const std::string& bind_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bind_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bind_password();
  PROTOBUF_NODISCARD std::string* release_bind_password();
  void set_allocated_bind_password(std::string* bind_password);
  private:
  const std::string& _internal_bind_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bind_password(const std::string& value);
  std::string* _internal_mutable_bind_password();
  public:

  // optional string user_filter = 10 [json_name = "userFilter"];
  bool has_user_filter() const;
  private:
  bool _internal_has_user_filter() const;
  public:
  void clear_user_filter();
  const std::string& user_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_filter();
  PROTOBUF_NODISCARD std::string* release_user_filter();
  void set_allocated_user_filter(std::string* user_filter);
  private:
  const std::string& _internal_user_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_filter(const std::string& value);
  std::string* _internal_mutable_user_filter();
  public:

  // optional string group_filter = 11 [json_name = "groupFilter"];
  bool has_group_filter() const;
  private:
  bool _internal_has_group_filter() const;
  public:
  void clear_group_filter();
  const std::string& group_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_filter();
  PROTOBUF_NODISCARD std::string* release_group_filter();
  void set_allocated_group_filter(std::string* group_filter);
  private:
  const std::string& _internal_group_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_filter(const std::string& value);
  std::string* _internal_mutable_group_filter();
  public:

  // optional string admin_filter = 13 [json_name = "adminFilter"];
  bool has_admin_filter() const;
  private:
  bool _internal_has_admin_filter() const;
  public:
  void clear_admin_filter();
  const std::string& admin_filter() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_admin_filter(ArgT0&& arg0, ArgT... args);
  std::string* mutable_admin_filter();
  PROTOBUF_NODISCARD std::string* release_admin_filter();
  void set_allocated_admin_filter(std::string* admin_filter);
  private:
  const std::string& _internal_admin_filter() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_filter(const std::string& value);
  std::string* _internal_mutable_admin_filter();
  public:

  // optional string group_display_name_attribute = 14 [json_name = "groupDisplayNameAttribute"];
  bool has_group_display_name_attribute() const;
  private:
  bool _internal_has_group_display_name_attribute() const;
  public:
  void clear_group_display_name_attribute();
  const std::string& group_display_name_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_display_name_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_display_name_attribute();
  PROTOBUF_NODISCARD std::string* release_group_display_name_attribute();
  void set_allocated_group_display_name_attribute(std::string* group_display_name_attribute);
  private:
  const std::string& _internal_group_display_name_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_display_name_attribute(const std::string& value);
  std::string* _internal_mutable_group_display_name_attribute();
  public:

  // optional string group_id_attribute = 15 [json_name = "groupIdAttribute"];
  bool has_group_id_attribute() const;
  private:
  bool _internal_has_group_id_attribute() const;
  public:
  void clear_group_id_attribute();
  const std::string& group_id_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_id_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_id_attribute();
  PROTOBUF_NODISCARD std::string* release_group_id_attribute();
  void set_allocated_group_id_attribute(std::string* group_id_attribute);
  private:
  const std::string& _internal_group_id_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_id_attribute(const std::string& value);
  std::string* _internal_mutable_group_id_attribute();
  public:

  // optional string first_name_attribute = 16 [json_name = "firstNameAttribute"];
  bool has_first_name_attribute() const;
  private:
  bool _internal_has_first_name_attribute() const;
  public:
  void clear_first_name_attribute();
  const std::string& first_name_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name_attribute();
  PROTOBUF_NODISCARD std::string* release_first_name_attribute();
  void set_allocated_first_name_attribute(std::string* first_name_attribute);
  private:
  const std::string& _internal_first_name_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name_attribute(const std::string& value);
  std::string* _internal_mutable_first_name_attribute();
  public:

  // optional string last_name_attribute = 17 [json_name = "lastNameAttribute"];
  bool has_last_name_attribute() const;
  private:
  bool _internal_has_last_name_attribute() const;
  public:
  void clear_last_name_attribute();
  const std::string& last_name_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name_attribute();
  PROTOBUF_NODISCARD std::string* release_last_name_attribute();
  void set_allocated_last_name_attribute(std::string* last_name_attribute);
  private:
  const std::string& _internal_last_name_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name_attribute(const std::string& value);
  std::string* _internal_mutable_last_name_attribute();
  public:

  // optional string email_attribute = 18 [json_name = "emailAttribute"];
  bool has_email_attribute() const;
  private:
  bool _internal_has_email_attribute() const;
  public:
  void clear_email_attribute();
  const std::string& email_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_attribute();
  PROTOBUF_NODISCARD std::string* release_email_attribute();
  void set_allocated_email_attribute(std::string* email_attribute);
  private:
  const std::string& _internal_email_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_attribute(const std::string& value);
  std::string* _internal_mutable_email_attribute();
  public:

  // optional string username_attribute = 19 [json_name = "usernameAttribute"];
  bool has_username_attribute() const;
  private:
  bool _internal_has_username_attribute() const;
  public:
  void clear_username_attribute();
  const std::string& username_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username_attribute();
  PROTOBUF_NODISCARD std::string* release_username_attribute();
  void set_allocated_username_attribute(std::string* username_attribute);
  private:
  const std::string& _internal_username_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username_attribute(const std::string& value);
  std::string* _internal_mutable_username_attribute();
  public:

  // optional string nickname_attribute = 20 [json_name = "nicknameAttribute"];
  bool has_nickname_attribute() const;
  private:
  bool _internal_has_nickname_attribute() const;
  public:
  void clear_nickname_attribute();
  const std::string& nickname_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname_attribute();
  PROTOBUF_NODISCARD std::string* release_nickname_attribute();
  void set_allocated_nickname_attribute(std::string* nickname_attribute);
  private:
  const std::string& _internal_nickname_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname_attribute(const std::string& value);
  std::string* _internal_mutable_nickname_attribute();
  public:

  // optional string id_attribute = 21 [json_name = "idAttribute"];
  bool has_id_attribute() const;
  private:
  bool _internal_has_id_attribute() const;
  public:
  void clear_id_attribute();
  const std::string& id_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_attribute();
  PROTOBUF_NODISCARD std::string* release_id_attribute();
  void set_allocated_id_attribute(std::string* id_attribute);
  private:
  const std::string& _internal_id_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_attribute(const std::string& value);
  std::string* _internal_mutable_id_attribute();
  public:

  // optional string position_attribute = 22 [json_name = "positionAttribute"];
  bool has_position_attribute() const;
  private:
  bool _internal_has_position_attribute() const;
  public:
  void clear_position_attribute();
  const std::string& position_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_position_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_position_attribute();
  PROTOBUF_NODISCARD std::string* release_position_attribute();
  void set_allocated_position_attribute(std::string* position_attribute);
  private:
  const std::string& _internal_position_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_position_attribute(const std::string& value);
  std::string* _internal_mutable_position_attribute();
  public:

  // optional string login_id_attribute = 23 [json_name = "loginIdAttribute"];
  bool has_login_id_attribute() const;
  private:
  bool _internal_has_login_id_attribute() const;
  public:
  void clear_login_id_attribute();
  const std::string& login_id_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_id_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_id_attribute();
  PROTOBUF_NODISCARD std::string* release_login_id_attribute();
  void set_allocated_login_id_attribute(std::string* login_id_attribute);
  private:
  const std::string& _internal_login_id_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_id_attribute(const std::string& value);
  std::string* _internal_mutable_login_id_attribute();
  public:

  // optional string picture_attribute = 24 [json_name = "pictureAttribute"];
  bool has_picture_attribute() const;
  private:
  bool _internal_has_picture_attribute() const;
  public:
  void clear_picture_attribute();
  const std::string& picture_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_picture_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_picture_attribute();
  PROTOBUF_NODISCARD std::string* release_picture_attribute();
  void set_allocated_picture_attribute(std::string* picture_attribute);
  private:
  const std::string& _internal_picture_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_picture_attribute(const std::string& value);
  std::string* _internal_mutable_picture_attribute();
  public:

  // optional string login_field_name = 28 [json_name = "loginFieldName"];
  bool has_login_field_name() const;
  private:
  bool _internal_has_login_field_name() const;
  public:
  void clear_login_field_name();
  const std::string& login_field_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_field_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_field_name();
  PROTOBUF_NODISCARD std::string* release_login_field_name();
  void set_allocated_login_field_name(std::string* login_field_name);
  private:
  const std::string& _internal_login_field_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_field_name(const std::string& value);
  std::string* _internal_mutable_login_field_name();
  public:

  // optional string login_button_color = 29 [json_name = "loginButtonColor"];
  bool has_login_button_color() const;
  private:
  bool _internal_has_login_button_color() const;
  public:
  void clear_login_button_color();
  const std::string& login_button_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_color();
  PROTOBUF_NODISCARD std::string* release_login_button_color();
  void set_allocated_login_button_color(std::string* login_button_color);
  private:
  const std::string& _internal_login_button_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_color(const std::string& value);
  std::string* _internal_mutable_login_button_color();
  public:

  // optional string login_button_border_color = 30 [json_name = "loginButtonBorderColor"];
  bool has_login_button_border_color() const;
  private:
  bool _internal_has_login_button_border_color() const;
  public:
  void clear_login_button_border_color();
  const std::string& login_button_border_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_border_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_border_color();
  PROTOBUF_NODISCARD std::string* release_login_button_border_color();
  void set_allocated_login_button_border_color(std::string* login_button_border_color);
  private:
  const std::string& _internal_login_button_border_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_border_color(const std::string& value);
  std::string* _internal_mutable_login_button_border_color();
  public:

  // optional string login_button_text_color = 31 [json_name = "loginButtonTextColor"];
  bool has_login_button_text_color() const;
  private:
  bool _internal_has_login_button_text_color() const;
  public:
  void clear_login_button_text_color();
  const std::string& login_button_text_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_text_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_text_color();
  PROTOBUF_NODISCARD std::string* release_login_button_text_color();
  void set_allocated_login_button_text_color(std::string* login_button_text_color);
  private:
  const std::string& _internal_login_button_text_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_text_color(const std::string& value);
  std::string* _internal_mutable_login_button_text_color();
  public:

  // optional int32 ldap_port = 4 [json_name = "ldapPort"];
  bool has_ldap_port() const;
  private:
  bool _internal_has_ldap_port() const;
  public:
  void clear_ldap_port();
  int32_t ldap_port() const;
  void set_ldap_port(int32_t value);
  private:
  int32_t _internal_ldap_port() const;
  void _internal_set_ldap_port(int32_t value);
  public:

  // optional bool enable = 1 [json_name = "enable"];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional bool enable_sync = 2 [json_name = "enableSync"];
  bool has_enable_sync() const;
  private:
  bool _internal_has_enable_sync() const;
  public:
  void clear_enable_sync();
  bool enable_sync() const;
  void set_enable_sync(bool value);
  private:
  bool _internal_enable_sync() const;
  void _internal_set_enable_sync(bool value);
  public:

  // optional bool enable_admin_filter = 12 [json_name = "enableAdminFilter"];
  bool has_enable_admin_filter() const;
  private:
  bool _internal_has_enable_admin_filter() const;
  public:
  void clear_enable_admin_filter();
  bool enable_admin_filter() const;
  void set_enable_admin_filter(bool value);
  private:
  bool _internal_enable_admin_filter() const;
  void _internal_set_enable_admin_filter(bool value);
  public:

  // optional int32 maximum_login_attempts = 9 [json_name = "maximumLoginAttempts"];
  bool has_maximum_login_attempts() const;
  private:
  bool _internal_has_maximum_login_attempts() const;
  public:
  void clear_maximum_login_attempts();
  int32_t maximum_login_attempts() const;
  void set_maximum_login_attempts(int32_t value);
  private:
  int32_t _internal_maximum_login_attempts() const;
  void _internal_set_maximum_login_attempts(int32_t value);
  public:

  // optional int32 sync_interval_minutes = 25 [json_name = "syncIntervalMinutes"];
  bool has_sync_interval_minutes() const;
  private:
  bool _internal_has_sync_interval_minutes() const;
  public:
  void clear_sync_interval_minutes();
  int32_t sync_interval_minutes() const;
  void set_sync_interval_minutes(int32_t value);
  private:
  int32_t _internal_sync_interval_minutes() const;
  void _internal_set_sync_interval_minutes(int32_t value);
  public:

  // optional int32 query_timeout = 26 [json_name = "queryTimeout"];
  bool has_query_timeout() const;
  private:
  bool _internal_has_query_timeout() const;
  public:
  void clear_query_timeout();
  int32_t query_timeout() const;
  void set_query_timeout(int32_t value);
  private:
  int32_t _internal_query_timeout() const;
  void _internal_set_query_timeout(int32_t value);
  public:

  // optional int32 max_page_size = 27 [json_name = "maxPageSize"];
  bool has_max_page_size() const;
  private:
  bool _internal_has_max_page_size() const;
  public:
  void clear_max_page_size();
  int32_t max_page_size() const;
  void set_max_page_size(int32_t value);
  private:
  int32_t _internal_max_page_size() const;
  void _internal_set_max_page_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigLdap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ldap_server_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr connection_security_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_dn_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bind_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bind_password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_filter_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_display_name_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_id_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr position_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_id_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr picture_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_field_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_border_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_text_color_;
  int32_t ldap_port_;
  bool enable_;
  bool enable_sync_;
  bool enable_admin_filter_;
  int32_t maximum_login_attempts_;
  int32_t sync_interval_minutes_;
  int32_t query_timeout_;
  int32_t max_page_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigSaml final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigSaml) */ {
 public:
  inline ConfigSaml() : ConfigSaml(nullptr) {}
  ~ConfigSaml() override;
  explicit constexpr ConfigSaml(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigSaml(const ConfigSaml& from);
  ConfigSaml(ConfigSaml&& from) noexcept
    : ConfigSaml() {
    *this = ::std::move(from);
  }

  inline ConfigSaml& operator=(const ConfigSaml& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigSaml& operator=(ConfigSaml&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigSaml& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigSaml* internal_default_instance() {
    return reinterpret_cast<const ConfigSaml*>(
               &_ConfigSaml_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ConfigSaml& a, ConfigSaml& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigSaml* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigSaml* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigSaml* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigSaml>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigSaml& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigSaml& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigSaml* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigSaml";
  }
  protected:
  explicit ConfigSaml(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdpUrlFieldNumber = 8,
    kIdpDescriptorUrlFieldNumber = 9,
    kIdpMetadataUrlFieldNumber = 10,
    kServiceProviderIdentifierFieldNumber = 11,
    kAssertionConsumerServiceUrlFieldNumber = 12,
    kSignatureAlgorithmFieldNumber = 13,
    kCanonicalAlgorithmFieldNumber = 14,
    kScopingIdpProviderIdFieldNumber = 15,
    kScopingIdpNameFieldNumber = 16,
    kIdpCertificateFileFieldNumber = 17,
    kPublicCertificateFileFieldNumber = 18,
    kPrivateKeyFileFieldNumber = 19,
    kIdAttributeFieldNumber = 20,
    kAdminAttributeFieldNumber = 22,
    kFirstNameAttributeFieldNumber = 23,
    kLastNameAttributeFieldNumber = 24,
    kEmailAttributeFieldNumber = 25,
    kUsernameAttributeFieldNumber = 26,
    kNicknameAttributeFieldNumber = 27,
    kLocaleAttributeFieldNumber = 28,
    kPositionAttributeFieldNumber = 29,
    kLoginButtonTextFieldNumber = 30,
    kLoginButtonColorFieldNumber = 31,
    kLoginButtonBorderColorFieldNumber = 32,
    kLoginButtonTextColorFieldNumber = 33,
    kEnableFieldNumber = 1,
    kEnableSyncWithLdapFieldNumber = 2,
    kEnableSyncWithLdapIncludeAuthFieldNumber = 3,
    kIgnoreGuestsLdapSyncFieldNumber = 4,
    kVerifyFieldNumber = 5,
    kEncryptFieldNumber = 6,
    kSignRequestFieldNumber = 7,
    kEnableAdminAttributeFieldNumber = 21,
  };
  // optional string idp_url = 8 [json_name = "idpUrl"];
  bool has_idp_url() const;
  private:
  bool _internal_has_idp_url() const;
  public:
  void clear_idp_url();
  const std::string& idp_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idp_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idp_url();
  PROTOBUF_NODISCARD std::string* release_idp_url();
  void set_allocated_idp_url(std::string* idp_url);
  private:
  const std::string& _internal_idp_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idp_url(const std::string& value);
  std::string* _internal_mutable_idp_url();
  public:

  // optional string idp_descriptor_url = 9 [json_name = "idpDescriptorUrl"];
  bool has_idp_descriptor_url() const;
  private:
  bool _internal_has_idp_descriptor_url() const;
  public:
  void clear_idp_descriptor_url();
  const std::string& idp_descriptor_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idp_descriptor_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idp_descriptor_url();
  PROTOBUF_NODISCARD std::string* release_idp_descriptor_url();
  void set_allocated_idp_descriptor_url(std::string* idp_descriptor_url);
  private:
  const std::string& _internal_idp_descriptor_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idp_descriptor_url(const std::string& value);
  std::string* _internal_mutable_idp_descriptor_url();
  public:

  // optional string idp_metadata_url = 10 [json_name = "idpMetadataUrl"];
  bool has_idp_metadata_url() const;
  private:
  bool _internal_has_idp_metadata_url() const;
  public:
  void clear_idp_metadata_url();
  const std::string& idp_metadata_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idp_metadata_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idp_metadata_url();
  PROTOBUF_NODISCARD std::string* release_idp_metadata_url();
  void set_allocated_idp_metadata_url(std::string* idp_metadata_url);
  private:
  const std::string& _internal_idp_metadata_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idp_metadata_url(const std::string& value);
  std::string* _internal_mutable_idp_metadata_url();
  public:

  // optional string service_provider_identifier = 11 [json_name = "serviceProviderIdentifier"];
  bool has_service_provider_identifier() const;
  private:
  bool _internal_has_service_provider_identifier() const;
  public:
  void clear_service_provider_identifier();
  const std::string& service_provider_identifier() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_service_provider_identifier(ArgT0&& arg0, ArgT... args);
  std::string* mutable_service_provider_identifier();
  PROTOBUF_NODISCARD std::string* release_service_provider_identifier();
  void set_allocated_service_provider_identifier(std::string* service_provider_identifier);
  private:
  const std::string& _internal_service_provider_identifier() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_service_provider_identifier(const std::string& value);
  std::string* _internal_mutable_service_provider_identifier();
  public:

  // optional string assertion_consumer_service_url = 12 [json_name = "assertionConsumerServiceUrl"];
  bool has_assertion_consumer_service_url() const;
  private:
  bool _internal_has_assertion_consumer_service_url() const;
  public:
  void clear_assertion_consumer_service_url();
  const std::string& assertion_consumer_service_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_assertion_consumer_service_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_assertion_consumer_service_url();
  PROTOBUF_NODISCARD std::string* release_assertion_consumer_service_url();
  void set_allocated_assertion_consumer_service_url(std::string* assertion_consumer_service_url);
  private:
  const std::string& _internal_assertion_consumer_service_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_assertion_consumer_service_url(const std::string& value);
  std::string* _internal_mutable_assertion_consumer_service_url();
  public:

  // optional string signature_algorithm = 13 [json_name = "signatureAlgorithm"];
  bool has_signature_algorithm() const;
  private:
  bool _internal_has_signature_algorithm() const;
  public:
  void clear_signature_algorithm();
  const std::string& signature_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature_algorithm();
  PROTOBUF_NODISCARD std::string* release_signature_algorithm();
  void set_allocated_signature_algorithm(std::string* signature_algorithm);
  private:
  const std::string& _internal_signature_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature_algorithm(const std::string& value);
  std::string* _internal_mutable_signature_algorithm();
  public:

  // optional string canonical_algorithm = 14 [json_name = "canonicalAlgorithm"];
  bool has_canonical_algorithm() const;
  private:
  bool _internal_has_canonical_algorithm() const;
  public:
  void clear_canonical_algorithm();
  const std::string& canonical_algorithm() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canonical_algorithm(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canonical_algorithm();
  PROTOBUF_NODISCARD std::string* release_canonical_algorithm();
  void set_allocated_canonical_algorithm(std::string* canonical_algorithm);
  private:
  const std::string& _internal_canonical_algorithm() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canonical_algorithm(const std::string& value);
  std::string* _internal_mutable_canonical_algorithm();
  public:

  // optional string scoping_idp_provider_id = 15 [json_name = "scopingIdpProviderId"];
  bool has_scoping_idp_provider_id() const;
  private:
  bool _internal_has_scoping_idp_provider_id() const;
  public:
  void clear_scoping_idp_provider_id();
  const std::string& scoping_idp_provider_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scoping_idp_provider_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scoping_idp_provider_id();
  PROTOBUF_NODISCARD std::string* release_scoping_idp_provider_id();
  void set_allocated_scoping_idp_provider_id(std::string* scoping_idp_provider_id);
  private:
  const std::string& _internal_scoping_idp_provider_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scoping_idp_provider_id(const std::string& value);
  std::string* _internal_mutable_scoping_idp_provider_id();
  public:

  // optional string scoping_idp_name = 16 [json_name = "scopingIdpName"];
  bool has_scoping_idp_name() const;
  private:
  bool _internal_has_scoping_idp_name() const;
  public:
  void clear_scoping_idp_name();
  const std::string& scoping_idp_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_scoping_idp_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_scoping_idp_name();
  PROTOBUF_NODISCARD std::string* release_scoping_idp_name();
  void set_allocated_scoping_idp_name(std::string* scoping_idp_name);
  private:
  const std::string& _internal_scoping_idp_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_scoping_idp_name(const std::string& value);
  std::string* _internal_mutable_scoping_idp_name();
  public:

  // optional string idp_certificate_file = 17 [json_name = "idpCertificateFile"];
  bool has_idp_certificate_file() const;
  private:
  bool _internal_has_idp_certificate_file() const;
  public:
  void clear_idp_certificate_file();
  const std::string& idp_certificate_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idp_certificate_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idp_certificate_file();
  PROTOBUF_NODISCARD std::string* release_idp_certificate_file();
  void set_allocated_idp_certificate_file(std::string* idp_certificate_file);
  private:
  const std::string& _internal_idp_certificate_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idp_certificate_file(const std::string& value);
  std::string* _internal_mutable_idp_certificate_file();
  public:

  // optional string public_certificate_file = 18 [json_name = "publicCertificateFile"];
  bool has_public_certificate_file() const;
  private:
  bool _internal_has_public_certificate_file() const;
  public:
  void clear_public_certificate_file();
  const std::string& public_certificate_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_certificate_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_certificate_file();
  PROTOBUF_NODISCARD std::string* release_public_certificate_file();
  void set_allocated_public_certificate_file(std::string* public_certificate_file);
  private:
  const std::string& _internal_public_certificate_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_certificate_file(const std::string& value);
  std::string* _internal_mutable_public_certificate_file();
  public:

  // optional string private_key_file = 19 [json_name = "privateKeyFile"];
  bool has_private_key_file() const;
  private:
  bool _internal_has_private_key_file() const;
  public:
  void clear_private_key_file();
  const std::string& private_key_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key_file();
  PROTOBUF_NODISCARD std::string* release_private_key_file();
  void set_allocated_private_key_file(std::string* private_key_file);
  private:
  const std::string& _internal_private_key_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key_file(const std::string& value);
  std::string* _internal_mutable_private_key_file();
  public:

  // optional string id_attribute = 20 [json_name = "idAttribute"];
  bool has_id_attribute() const;
  private:
  bool _internal_has_id_attribute() const;
  public:
  void clear_id_attribute();
  const std::string& id_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_attribute();
  PROTOBUF_NODISCARD std::string* release_id_attribute();
  void set_allocated_id_attribute(std::string* id_attribute);
  private:
  const std::string& _internal_id_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_attribute(const std::string& value);
  std::string* _internal_mutable_id_attribute();
  public:

  // optional string admin_attribute = 22 [json_name = "adminAttribute"];
  bool has_admin_attribute() const;
  private:
  bool _internal_has_admin_attribute() const;
  public:
  void clear_admin_attribute();
  const std::string& admin_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_admin_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_admin_attribute();
  PROTOBUF_NODISCARD std::string* release_admin_attribute();
  void set_allocated_admin_attribute(std::string* admin_attribute);
  private:
  const std::string& _internal_admin_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_attribute(const std::string& value);
  std::string* _internal_mutable_admin_attribute();
  public:

  // optional string first_name_attribute = 23 [json_name = "firstNameAttribute"];
  bool has_first_name_attribute() const;
  private:
  bool _internal_has_first_name_attribute() const;
  public:
  void clear_first_name_attribute();
  const std::string& first_name_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name_attribute();
  PROTOBUF_NODISCARD std::string* release_first_name_attribute();
  void set_allocated_first_name_attribute(std::string* first_name_attribute);
  private:
  const std::string& _internal_first_name_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name_attribute(const std::string& value);
  std::string* _internal_mutable_first_name_attribute();
  public:

  // optional string last_name_attribute = 24 [json_name = "lastNameAttribute"];
  bool has_last_name_attribute() const;
  private:
  bool _internal_has_last_name_attribute() const;
  public:
  void clear_last_name_attribute();
  const std::string& last_name_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name_attribute();
  PROTOBUF_NODISCARD std::string* release_last_name_attribute();
  void set_allocated_last_name_attribute(std::string* last_name_attribute);
  private:
  const std::string& _internal_last_name_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name_attribute(const std::string& value);
  std::string* _internal_mutable_last_name_attribute();
  public:

  // optional string email_attribute = 25 [json_name = "emailAttribute"];
  bool has_email_attribute() const;
  private:
  bool _internal_has_email_attribute() const;
  public:
  void clear_email_attribute();
  const std::string& email_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email_attribute();
  PROTOBUF_NODISCARD std::string* release_email_attribute();
  void set_allocated_email_attribute(std::string* email_attribute);
  private:
  const std::string& _internal_email_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email_attribute(const std::string& value);
  std::string* _internal_mutable_email_attribute();
  public:

  // optional string username_attribute = 26 [json_name = "usernameAttribute"];
  bool has_username_attribute() const;
  private:
  bool _internal_has_username_attribute() const;
  public:
  void clear_username_attribute();
  const std::string& username_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username_attribute();
  PROTOBUF_NODISCARD std::string* release_username_attribute();
  void set_allocated_username_attribute(std::string* username_attribute);
  private:
  const std::string& _internal_username_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username_attribute(const std::string& value);
  std::string* _internal_mutable_username_attribute();
  public:

  // optional string nickname_attribute = 27 [json_name = "nicknameAttribute"];
  bool has_nickname_attribute() const;
  private:
  bool _internal_has_nickname_attribute() const;
  public:
  void clear_nickname_attribute();
  const std::string& nickname_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname_attribute();
  PROTOBUF_NODISCARD std::string* release_nickname_attribute();
  void set_allocated_nickname_attribute(std::string* nickname_attribute);
  private:
  const std::string& _internal_nickname_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname_attribute(const std::string& value);
  std::string* _internal_mutable_nickname_attribute();
  public:

  // optional string locale_attribute = 28 [json_name = "localeAttribute"];
  bool has_locale_attribute() const;
  private:
  bool _internal_has_locale_attribute() const;
  public:
  void clear_locale_attribute();
  const std::string& locale_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale_attribute();
  PROTOBUF_NODISCARD std::string* release_locale_attribute();
  void set_allocated_locale_attribute(std::string* locale_attribute);
  private:
  const std::string& _internal_locale_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale_attribute(const std::string& value);
  std::string* _internal_mutable_locale_attribute();
  public:

  // optional string position_attribute = 29 [json_name = "positionAttribute"];
  bool has_position_attribute() const;
  private:
  bool _internal_has_position_attribute() const;
  public:
  void clear_position_attribute();
  const std::string& position_attribute() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_position_attribute(ArgT0&& arg0, ArgT... args);
  std::string* mutable_position_attribute();
  PROTOBUF_NODISCARD std::string* release_position_attribute();
  void set_allocated_position_attribute(std::string* position_attribute);
  private:
  const std::string& _internal_position_attribute() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_position_attribute(const std::string& value);
  std::string* _internal_mutable_position_attribute();
  public:

  // optional string login_button_text = 30 [json_name = "loginButtonText"];
  bool has_login_button_text() const;
  private:
  bool _internal_has_login_button_text() const;
  public:
  void clear_login_button_text();
  const std::string& login_button_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_text();
  PROTOBUF_NODISCARD std::string* release_login_button_text();
  void set_allocated_login_button_text(std::string* login_button_text);
  private:
  const std::string& _internal_login_button_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_text(const std::string& value);
  std::string* _internal_mutable_login_button_text();
  public:

  // optional string login_button_color = 31 [json_name = "loginButtonColor"];
  bool has_login_button_color() const;
  private:
  bool _internal_has_login_button_color() const;
  public:
  void clear_login_button_color();
  const std::string& login_button_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_color();
  PROTOBUF_NODISCARD std::string* release_login_button_color();
  void set_allocated_login_button_color(std::string* login_button_color);
  private:
  const std::string& _internal_login_button_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_color(const std::string& value);
  std::string* _internal_mutable_login_button_color();
  public:

  // optional string login_button_border_color = 32 [json_name = "loginButtonBorderColor"];
  bool has_login_button_border_color() const;
  private:
  bool _internal_has_login_button_border_color() const;
  public:
  void clear_login_button_border_color();
  const std::string& login_button_border_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_border_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_border_color();
  PROTOBUF_NODISCARD std::string* release_login_button_border_color();
  void set_allocated_login_button_border_color(std::string* login_button_border_color);
  private:
  const std::string& _internal_login_button_border_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_border_color(const std::string& value);
  std::string* _internal_mutable_login_button_border_color();
  public:

  // optional string login_button_text_color = 33 [json_name = "loginButtonTextColor"];
  bool has_login_button_text_color() const;
  private:
  bool _internal_has_login_button_text_color() const;
  public:
  void clear_login_button_text_color();
  const std::string& login_button_text_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login_button_text_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login_button_text_color();
  PROTOBUF_NODISCARD std::string* release_login_button_text_color();
  void set_allocated_login_button_text_color(std::string* login_button_text_color);
  private:
  const std::string& _internal_login_button_text_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login_button_text_color(const std::string& value);
  std::string* _internal_mutable_login_button_text_color();
  public:

  // optional bool enable = 1 [json_name = "enable"];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional bool enable_sync_with_ldap = 2 [json_name = "enableSyncWithLdap"];
  bool has_enable_sync_with_ldap() const;
  private:
  bool _internal_has_enable_sync_with_ldap() const;
  public:
  void clear_enable_sync_with_ldap();
  bool enable_sync_with_ldap() const;
  void set_enable_sync_with_ldap(bool value);
  private:
  bool _internal_enable_sync_with_ldap() const;
  void _internal_set_enable_sync_with_ldap(bool value);
  public:

  // optional bool enable_sync_with_ldap_include_auth = 3 [json_name = "enableSyncWithLdapIncludeAuth"];
  bool has_enable_sync_with_ldap_include_auth() const;
  private:
  bool _internal_has_enable_sync_with_ldap_include_auth() const;
  public:
  void clear_enable_sync_with_ldap_include_auth();
  bool enable_sync_with_ldap_include_auth() const;
  void set_enable_sync_with_ldap_include_auth(bool value);
  private:
  bool _internal_enable_sync_with_ldap_include_auth() const;
  void _internal_set_enable_sync_with_ldap_include_auth(bool value);
  public:

  // optional bool ignore_guests_ldap_sync = 4 [json_name = "ignoreGuestsLdapSync"];
  bool has_ignore_guests_ldap_sync() const;
  private:
  bool _internal_has_ignore_guests_ldap_sync() const;
  public:
  void clear_ignore_guests_ldap_sync();
  bool ignore_guests_ldap_sync() const;
  void set_ignore_guests_ldap_sync(bool value);
  private:
  bool _internal_ignore_guests_ldap_sync() const;
  void _internal_set_ignore_guests_ldap_sync(bool value);
  public:

  // optional bool verify = 5 [json_name = "verify"];
  bool has_verify() const;
  private:
  bool _internal_has_verify() const;
  public:
  void clear_verify();
  bool verify() const;
  void set_verify(bool value);
  private:
  bool _internal_verify() const;
  void _internal_set_verify(bool value);
  public:

  // optional bool encrypt = 6 [json_name = "encrypt"];
  bool has_encrypt() const;
  private:
  bool _internal_has_encrypt() const;
  public:
  void clear_encrypt();
  bool encrypt() const;
  void set_encrypt(bool value);
  private:
  bool _internal_encrypt() const;
  void _internal_set_encrypt(bool value);
  public:

  // optional bool sign_request = 7 [json_name = "signRequest"];
  bool has_sign_request() const;
  private:
  bool _internal_has_sign_request() const;
  public:
  void clear_sign_request();
  bool sign_request() const;
  void set_sign_request(bool value);
  private:
  bool _internal_sign_request() const;
  void _internal_set_sign_request(bool value);
  public:

  // optional bool enable_admin_attribute = 21 [json_name = "enableAdminAttribute"];
  bool has_enable_admin_attribute() const;
  private:
  bool _internal_has_enable_admin_attribute() const;
  public:
  void clear_enable_admin_attribute();
  bool enable_admin_attribute() const;
  void set_enable_admin_attribute(bool value);
  private:
  bool _internal_enable_admin_attribute() const;
  void _internal_set_enable_admin_attribute(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigSaml)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<2> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idp_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idp_descriptor_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idp_metadata_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_provider_identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr assertion_consumer_service_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canonical_algorithm_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scoping_idp_provider_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr scoping_idp_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idp_certificate_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_certificate_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr admin_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr position_attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_border_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_button_text_color_;
  bool enable_;
  bool enable_sync_with_ldap_;
  bool enable_sync_with_ldap_include_auth_;
  bool ignore_guests_ldap_sync_;
  bool verify_;
  bool encrypt_;
  bool sign_request_;
  bool enable_admin_attribute_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigNativeApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigNativeApp) */ {
 public:
  inline ConfigNativeApp() : ConfigNativeApp(nullptr) {}
  ~ConfigNativeApp() override;
  explicit constexpr ConfigNativeApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigNativeApp(const ConfigNativeApp& from);
  ConfigNativeApp(ConfigNativeApp&& from) noexcept
    : ConfigNativeApp() {
    *this = ::std::move(from);
  }

  inline ConfigNativeApp& operator=(const ConfigNativeApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigNativeApp& operator=(ConfigNativeApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigNativeApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigNativeApp* internal_default_instance() {
    return reinterpret_cast<const ConfigNativeApp*>(
               &_ConfigNativeApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ConfigNativeApp& a, ConfigNativeApp& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigNativeApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigNativeApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigNativeApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigNativeApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigNativeApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigNativeApp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigNativeApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigNativeApp";
  }
  protected:
  explicit ConfigNativeApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppCustomUrlSchemesFieldNumber = 1,
    kAppDownloadLinkFieldNumber = 2,
    kAndroidAppDownloadLinkFieldNumber = 3,
    kIosAppDownloadLinkFieldNumber = 4,
    kMobileExternalBrowserFieldNumber = 5,
    kMobileEnableBiometricsFieldNumber = 6,
    kMobilePreventScreenCaptureFieldNumber = 7,
    kMobileJailbreakProtectionFieldNumber = 8,
  };
  // repeated string app_custom_url_schemes = 1 [json_name = "appCustomUrlSchemes"];
  int app_custom_url_schemes_size() const;
  private:
  int _internal_app_custom_url_schemes_size() const;
  public:
  void clear_app_custom_url_schemes();
  const std::string& app_custom_url_schemes(int index) const;
  std::string* mutable_app_custom_url_schemes(int index);
  void set_app_custom_url_schemes(int index, const std::string& value);
  void set_app_custom_url_schemes(int index, std::string&& value);
  void set_app_custom_url_schemes(int index, const char* value);
  void set_app_custom_url_schemes(int index, const char* value, size_t size);
  std::string* add_app_custom_url_schemes();
  void add_app_custom_url_schemes(const std::string& value);
  void add_app_custom_url_schemes(std::string&& value);
  void add_app_custom_url_schemes(const char* value);
  void add_app_custom_url_schemes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& app_custom_url_schemes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_app_custom_url_schemes();
  private:
  const std::string& _internal_app_custom_url_schemes(int index) const;
  std::string* _internal_add_app_custom_url_schemes();
  public:

  // optional string app_download_link = 2 [json_name = "appDownloadLink"];
  bool has_app_download_link() const;
  private:
  bool _internal_has_app_download_link() const;
  public:
  void clear_app_download_link();
  const std::string& app_download_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app_download_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app_download_link();
  PROTOBUF_NODISCARD std::string* release_app_download_link();
  void set_allocated_app_download_link(std::string* app_download_link);
  private:
  const std::string& _internal_app_download_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_download_link(const std::string& value);
  std::string* _internal_mutable_app_download_link();
  public:

  // optional string android_app_download_link = 3 [json_name = "androidAppDownloadLink"];
  bool has_android_app_download_link() const;
  private:
  bool _internal_has_android_app_download_link() const;
  public:
  void clear_android_app_download_link();
  const std::string& android_app_download_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_android_app_download_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_android_app_download_link();
  PROTOBUF_NODISCARD std::string* release_android_app_download_link();
  void set_allocated_android_app_download_link(std::string* android_app_download_link);
  private:
  const std::string& _internal_android_app_download_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_android_app_download_link(const std::string& value);
  std::string* _internal_mutable_android_app_download_link();
  public:

  // optional string ios_app_download_link = 4 [json_name = "iosAppDownloadLink"];
  bool has_ios_app_download_link() const;
  private:
  bool _internal_has_ios_app_download_link() const;
  public:
  void clear_ios_app_download_link();
  const std::string& ios_app_download_link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ios_app_download_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ios_app_download_link();
  PROTOBUF_NODISCARD std::string* release_ios_app_download_link();
  void set_allocated_ios_app_download_link(std::string* ios_app_download_link);
  private:
  const std::string& _internal_ios_app_download_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ios_app_download_link(const std::string& value);
  std::string* _internal_mutable_ios_app_download_link();
  public:

  // optional bool mobile_external_browser = 5 [json_name = "mobileExternalBrowser"];
  bool has_mobile_external_browser() const;
  private:
  bool _internal_has_mobile_external_browser() const;
  public:
  void clear_mobile_external_browser();
  bool mobile_external_browser() const;
  void set_mobile_external_browser(bool value);
  private:
  bool _internal_mobile_external_browser() const;
  void _internal_set_mobile_external_browser(bool value);
  public:

  // optional bool mobile_enable_biometrics = 6 [json_name = "mobileEnableBiometrics"];
  bool has_mobile_enable_biometrics() const;
  private:
  bool _internal_has_mobile_enable_biometrics() const;
  public:
  void clear_mobile_enable_biometrics();
  bool mobile_enable_biometrics() const;
  void set_mobile_enable_biometrics(bool value);
  private:
  bool _internal_mobile_enable_biometrics() const;
  void _internal_set_mobile_enable_biometrics(bool value);
  public:

  // optional bool mobile_prevent_screen_capture = 7 [json_name = "mobilePreventScreenCapture"];
  bool has_mobile_prevent_screen_capture() const;
  private:
  bool _internal_has_mobile_prevent_screen_capture() const;
  public:
  void clear_mobile_prevent_screen_capture();
  bool mobile_prevent_screen_capture() const;
  void set_mobile_prevent_screen_capture(bool value);
  private:
  bool _internal_mobile_prevent_screen_capture() const;
  void _internal_set_mobile_prevent_screen_capture(bool value);
  public:

  // optional bool mobile_jailbreak_protection = 8 [json_name = "mobileJailbreakProtection"];
  bool has_mobile_jailbreak_protection() const;
  private:
  bool _internal_has_mobile_jailbreak_protection() const;
  public:
  void clear_mobile_jailbreak_protection();
  bool mobile_jailbreak_protection() const;
  void set_mobile_jailbreak_protection(bool value);
  private:
  bool _internal_mobile_jailbreak_protection() const;
  void _internal_set_mobile_jailbreak_protection(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigNativeApp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> app_custom_url_schemes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_download_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr android_app_download_link_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ios_app_download_link_;
  bool mobile_external_browser_;
  bool mobile_enable_biometrics_;
  bool mobile_prevent_screen_capture_;
  bool mobile_jailbreak_protection_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigMeilisearch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigMeilisearch) */ {
 public:
  inline ConfigMeilisearch() : ConfigMeilisearch(nullptr) {}
  ~ConfigMeilisearch() override;
  explicit constexpr ConfigMeilisearch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigMeilisearch(const ConfigMeilisearch& from);
  ConfigMeilisearch(ConfigMeilisearch&& from) noexcept
    : ConfigMeilisearch() {
    *this = ::std::move(from);
  }

  inline ConfigMeilisearch& operator=(const ConfigMeilisearch& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigMeilisearch& operator=(ConfigMeilisearch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigMeilisearch& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigMeilisearch* internal_default_instance() {
    return reinterpret_cast<const ConfigMeilisearch*>(
               &_ConfigMeilisearch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ConfigMeilisearch& a, ConfigMeilisearch& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigMeilisearch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigMeilisearch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigMeilisearch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigMeilisearch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigMeilisearch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigMeilisearch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigMeilisearch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigMeilisearch";
  }
  protected:
  explicit ConfigMeilisearch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerUrlFieldNumber = 1,
    kMasterKeyFieldNumber = 2,
    kIndexPrefixFieldNumber = 8,
    kEnableIndexingFieldNumber = 3,
    kEnableSearchingFieldNumber = 4,
    kEnableAutocompleteFieldNumber = 5,
    kEnableTypoToleranceFieldNumber = 10,
    kBatchSizeFieldNumber = 6,
    kRequestTimeoutSecondsFieldNumber = 7,
    kSearchCutoffMsFieldNumber = 9,
  };
  // optional string server_url = 1 [json_name = "server_url"];
  bool has_server_url() const;
  private:
  bool _internal_has_server_url() const;
  public:
  void clear_server_url();
  const std::string& server_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_url();
  PROTOBUF_NODISCARD std::string* release_server_url();
  void set_allocated_server_url(std::string* server_url);
  private:
  const std::string& _internal_server_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_url(const std::string& value);
  std::string* _internal_mutable_server_url();
  public:

  // optional string master_key = 2 [json_name = "masterKey"];
  bool has_master_key() const;
  private:
  bool _internal_has_master_key() const;
  public:
  void clear_master_key();
  const std::string& master_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_master_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_master_key();
  PROTOBUF_NODISCARD std::string* release_master_key();
  void set_allocated_master_key(std::string* master_key);
  private:
  const std::string& _internal_master_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master_key(const std::string& value);
  std::string* _internal_mutable_master_key();
  public:

  // optional string index_prefix = 8 [json_name = "indexPrefix"];
  bool has_index_prefix() const;
  private:
  bool _internal_has_index_prefix() const;
  public:
  void clear_index_prefix();
  const std::string& index_prefix() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_prefix(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_prefix();
  PROTOBUF_NODISCARD std::string* release_index_prefix();
  void set_allocated_index_prefix(std::string* index_prefix);
  private:
  const std::string& _internal_index_prefix() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_prefix(const std::string& value);
  std::string* _internal_mutable_index_prefix();
  public:

  // optional bool enable_indexing = 3 [json_name = "enableIndexing"];
  bool has_enable_indexing() const;
  private:
  bool _internal_has_enable_indexing() const;
  public:
  void clear_enable_indexing();
  bool enable_indexing() const;
  void set_enable_indexing(bool value);
  private:
  bool _internal_enable_indexing() const;
  void _internal_set_enable_indexing(bool value);
  public:

  // optional bool enable_searching = 4 [json_name = "enableSearching"];
  bool has_enable_searching() const;
  private:
  bool _internal_has_enable_searching() const;
  public:
  void clear_enable_searching();
  bool enable_searching() const;
  void set_enable_searching(bool value);
  private:
  bool _internal_enable_searching() const;
  void _internal_set_enable_searching(bool value);
  public:

  // optional bool enable_autocomplete = 5 [json_name = "enableAutocomplete"];
  bool has_enable_autocomplete() const;
  private:
  bool _internal_has_enable_autocomplete() const;
  public:
  void clear_enable_autocomplete();
  bool enable_autocomplete() const;
  void set_enable_autocomplete(bool value);
  private:
  bool _internal_enable_autocomplete() const;
  void _internal_set_enable_autocomplete(bool value);
  public:

  // optional bool enable_typo_tolerance = 10 [json_name = "enableTypoTolerance"];
  bool has_enable_typo_tolerance() const;
  private:
  bool _internal_has_enable_typo_tolerance() const;
  public:
  void clear_enable_typo_tolerance();
  bool enable_typo_tolerance() const;
  void set_enable_typo_tolerance(bool value);
  private:
  bool _internal_enable_typo_tolerance() const;
  void _internal_set_enable_typo_tolerance(bool value);
  public:

  // optional int32 batch_size = 6 [json_name = "batchSize"];
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // optional int32 request_timeout_seconds = 7 [json_name = "requestTimeoutSeconds"];
  bool has_request_timeout_seconds() const;
  private:
  bool _internal_has_request_timeout_seconds() const;
  public:
  void clear_request_timeout_seconds();
  int32_t request_timeout_seconds() const;
  void set_request_timeout_seconds(int32_t value);
  private:
  int32_t _internal_request_timeout_seconds() const;
  void _internal_set_request_timeout_seconds(int32_t value);
  public:

  // optional int32 search_cutoff_ms = 9 [json_name = "searchCutoffMs"];
  bool has_search_cutoff_ms() const;
  private:
  bool _internal_has_search_cutoff_ms() const;
  public:
  void clear_search_cutoff_ms();
  int32_t search_cutoff_ms() const;
  void set_search_cutoff_ms(int32_t value);
  private:
  int32_t _internal_search_cutoff_ms() const;
  void _internal_set_search_cutoff_ms(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigMeilisearch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr master_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_prefix_;
  bool enable_indexing_;
  bool enable_searching_;
  bool enable_autocomplete_;
  bool enable_typo_tolerance_;
  int32_t batch_size_;
  int32_t request_timeout_seconds_;
  int32_t search_cutoff_ms_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigBleve final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigBleve) */ {
 public:
  inline ConfigBleve() : ConfigBleve(nullptr) {}
  ~ConfigBleve() override;
  explicit constexpr ConfigBleve(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigBleve(const ConfigBleve& from);
  ConfigBleve(ConfigBleve&& from) noexcept
    : ConfigBleve() {
    *this = ::std::move(from);
  }

  inline ConfigBleve& operator=(const ConfigBleve& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigBleve& operator=(ConfigBleve&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigBleve& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigBleve* internal_default_instance() {
    return reinterpret_cast<const ConfigBleve*>(
               &_ConfigBleve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ConfigBleve& a, ConfigBleve& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigBleve* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigBleve* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigBleve* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigBleve>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigBleve& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigBleve& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigBleve* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigBleve";
  }
  protected:
  explicit ConfigBleve(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexDirFieldNumber = 1,
    kEnableIndexingFieldNumber = 2,
    kEnableSearchingFieldNumber = 3,
    kEnableAutocompleteFieldNumber = 4,
    kBulkIndexingTimeWindowSecondsFieldNumber = 5,
    kBatchSizeFieldNumber = 6,
  };
  // optional string index_dir = 1 [json_name = "indexDir"];
  bool has_index_dir() const;
  private:
  bool _internal_has_index_dir() const;
  public:
  void clear_index_dir();
  const std::string& index_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_dir();
  PROTOBUF_NODISCARD std::string* release_index_dir();
  void set_allocated_index_dir(std::string* index_dir);
  private:
  const std::string& _internal_index_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_dir(const std::string& value);
  std::string* _internal_mutable_index_dir();
  public:

  // optional bool enable_indexing = 2 [json_name = "enableIndexing"];
  bool has_enable_indexing() const;
  private:
  bool _internal_has_enable_indexing() const;
  public:
  void clear_enable_indexing();
  bool enable_indexing() const;
  void set_enable_indexing(bool value);
  private:
  bool _internal_enable_indexing() const;
  void _internal_set_enable_indexing(bool value);
  public:

  // optional bool enable_searching = 3 [json_name = "enableSearching"];
  bool has_enable_searching() const;
  private:
  bool _internal_has_enable_searching() const;
  public:
  void clear_enable_searching();
  bool enable_searching() const;
  void set_enable_searching(bool value);
  private:
  bool _internal_enable_searching() const;
  void _internal_set_enable_searching(bool value);
  public:

  // optional bool enable_autocomplete = 4 [json_name = "enableAutocomplete"];
  bool has_enable_autocomplete() const;
  private:
  bool _internal_has_enable_autocomplete() const;
  public:
  void clear_enable_autocomplete();
  bool enable_autocomplete() const;
  void set_enable_autocomplete(bool value);
  private:
  bool _internal_enable_autocomplete() const;
  void _internal_set_enable_autocomplete(bool value);
  public:

  // optional int32 bulk_indexing_time_window_seconds = 5 [json_name = "bulkIndexingTimeWindowSeconds"];
  bool has_bulk_indexing_time_window_seconds() const;
  private:
  bool _internal_has_bulk_indexing_time_window_seconds() const;
  public:
  void clear_bulk_indexing_time_window_seconds();
  int32_t bulk_indexing_time_window_seconds() const;
  void set_bulk_indexing_time_window_seconds(int32_t value);
  private:
  int32_t _internal_bulk_indexing_time_window_seconds() const;
  void _internal_set_bulk_indexing_time_window_seconds(int32_t value);
  public:

  // optional int32 batch_size = 6 [json_name = "batchSize"];
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigBleve)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_dir_;
  bool enable_indexing_;
  bool enable_searching_;
  bool enable_autocomplete_;
  int32_t bulk_indexing_time_window_seconds_;
  int32_t batch_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigDataRetention final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigDataRetention) */ {
 public:
  inline ConfigDataRetention() : ConfigDataRetention(nullptr) {}
  ~ConfigDataRetention() override;
  explicit constexpr ConfigDataRetention(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigDataRetention(const ConfigDataRetention& from);
  ConfigDataRetention(ConfigDataRetention&& from) noexcept
    : ConfigDataRetention() {
    *this = ::std::move(from);
  }

  inline ConfigDataRetention& operator=(const ConfigDataRetention& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigDataRetention& operator=(ConfigDataRetention&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigDataRetention& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigDataRetention* internal_default_instance() {
    return reinterpret_cast<const ConfigDataRetention*>(
               &_ConfigDataRetention_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ConfigDataRetention& a, ConfigDataRetention& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigDataRetention* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigDataRetention* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigDataRetention* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigDataRetention>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigDataRetention& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigDataRetention& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigDataRetention* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigDataRetention";
  }
  protected:
  explicit ConfigDataRetention(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeletionJobStartTimeFieldNumber = 7,
    kEnableMessageDeletionFieldNumber = 1,
    kEnableFileDeletionFieldNumber = 2,
    kEnableBoardsDeletionFieldNumber = 3,
    kMessageRetentionHoursFieldNumber = 4,
    kFileRetentionHoursFieldNumber = 5,
    kBoardsRetentionDaysFieldNumber = 6,
    kBatchSizeFieldNumber = 8,
    kTimeBetweenBatchesMillisecondsFieldNumber = 9,
    kRetentionIdsBatchSizeFieldNumber = 10,
  };
  // optional string deletion_job_start_time = 7 [json_name = "deletionJobStartTime"];
  bool has_deletion_job_start_time() const;
  private:
  bool _internal_has_deletion_job_start_time() const;
  public:
  void clear_deletion_job_start_time();
  const std::string& deletion_job_start_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deletion_job_start_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deletion_job_start_time();
  PROTOBUF_NODISCARD std::string* release_deletion_job_start_time();
  void set_allocated_deletion_job_start_time(std::string* deletion_job_start_time);
  private:
  const std::string& _internal_deletion_job_start_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deletion_job_start_time(const std::string& value);
  std::string* _internal_mutable_deletion_job_start_time();
  public:

  // optional bool enable_message_deletion = 1 [json_name = "enableMessageDeletion"];
  bool has_enable_message_deletion() const;
  private:
  bool _internal_has_enable_message_deletion() const;
  public:
  void clear_enable_message_deletion();
  bool enable_message_deletion() const;
  void set_enable_message_deletion(bool value);
  private:
  bool _internal_enable_message_deletion() const;
  void _internal_set_enable_message_deletion(bool value);
  public:

  // optional bool enable_file_deletion = 2 [json_name = "enableFileDeletion"];
  bool has_enable_file_deletion() const;
  private:
  bool _internal_has_enable_file_deletion() const;
  public:
  void clear_enable_file_deletion();
  bool enable_file_deletion() const;
  void set_enable_file_deletion(bool value);
  private:
  bool _internal_enable_file_deletion() const;
  void _internal_set_enable_file_deletion(bool value);
  public:

  // optional bool enable_boards_deletion = 3 [json_name = "enableBoardsDeletion"];
  bool has_enable_boards_deletion() const;
  private:
  bool _internal_has_enable_boards_deletion() const;
  public:
  void clear_enable_boards_deletion();
  bool enable_boards_deletion() const;
  void set_enable_boards_deletion(bool value);
  private:
  bool _internal_enable_boards_deletion() const;
  void _internal_set_enable_boards_deletion(bool value);
  public:

  // optional int32 message_retention_hours = 4 [json_name = "messageRetentionHours"];
  bool has_message_retention_hours() const;
  private:
  bool _internal_has_message_retention_hours() const;
  public:
  void clear_message_retention_hours();
  int32_t message_retention_hours() const;
  void set_message_retention_hours(int32_t value);
  private:
  int32_t _internal_message_retention_hours() const;
  void _internal_set_message_retention_hours(int32_t value);
  public:

  // optional int32 file_retention_hours = 5 [json_name = "fileRetentionHours"];
  bool has_file_retention_hours() const;
  private:
  bool _internal_has_file_retention_hours() const;
  public:
  void clear_file_retention_hours();
  int32_t file_retention_hours() const;
  void set_file_retention_hours(int32_t value);
  private:
  int32_t _internal_file_retention_hours() const;
  void _internal_set_file_retention_hours(int32_t value);
  public:

  // optional int32 boards_retention_days = 6 [json_name = "boardsRetentionDays"];
  bool has_boards_retention_days() const;
  private:
  bool _internal_has_boards_retention_days() const;
  public:
  void clear_boards_retention_days();
  int32_t boards_retention_days() const;
  void set_boards_retention_days(int32_t value);
  private:
  int32_t _internal_boards_retention_days() const;
  void _internal_set_boards_retention_days(int32_t value);
  public:

  // optional int32 batch_size = 8 [json_name = "batchSize"];
  bool has_batch_size() const;
  private:
  bool _internal_has_batch_size() const;
  public:
  void clear_batch_size();
  int32_t batch_size() const;
  void set_batch_size(int32_t value);
  private:
  int32_t _internal_batch_size() const;
  void _internal_set_batch_size(int32_t value);
  public:

  // optional int32 time_between_batches_milliseconds = 9 [json_name = "timeBetweenBatchesMilliseconds"];
  bool has_time_between_batches_milliseconds() const;
  private:
  bool _internal_has_time_between_batches_milliseconds() const;
  public:
  void clear_time_between_batches_milliseconds();
  int32_t time_between_batches_milliseconds() const;
  void set_time_between_batches_milliseconds(int32_t value);
  private:
  int32_t _internal_time_between_batches_milliseconds() const;
  void _internal_set_time_between_batches_milliseconds(int32_t value);
  public:

  // optional int32 retention_ids_batch_size = 10 [json_name = "retentionIdsBatchSize"];
  bool has_retention_ids_batch_size() const;
  private:
  bool _internal_has_retention_ids_batch_size() const;
  public:
  void clear_retention_ids_batch_size();
  int32_t retention_ids_batch_size() const;
  void set_retention_ids_batch_size(int32_t value);
  private:
  int32_t _internal_retention_ids_batch_size() const;
  void _internal_set_retention_ids_batch_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigDataRetention)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deletion_job_start_time_;
  bool enable_message_deletion_;
  bool enable_file_deletion_;
  bool enable_boards_deletion_;
  int32_t message_retention_hours_;
  int32_t file_retention_hours_;
  int32_t boards_retention_days_;
  int32_t batch_size_;
  int32_t time_between_batches_milliseconds_;
  int32_t retention_ids_batch_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigImageProxy final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigImageProxy) */ {
 public:
  inline ConfigImageProxy() : ConfigImageProxy(nullptr) {}
  ~ConfigImageProxy() override;
  explicit constexpr ConfigImageProxy(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigImageProxy(const ConfigImageProxy& from);
  ConfigImageProxy(ConfigImageProxy&& from) noexcept
    : ConfigImageProxy() {
    *this = ::std::move(from);
  }

  inline ConfigImageProxy& operator=(const ConfigImageProxy& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigImageProxy& operator=(ConfigImageProxy&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigImageProxy& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigImageProxy* internal_default_instance() {
    return reinterpret_cast<const ConfigImageProxy*>(
               &_ConfigImageProxy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConfigImageProxy& a, ConfigImageProxy& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigImageProxy* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigImageProxy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigImageProxy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigImageProxy>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigImageProxy& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigImageProxy& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigImageProxy* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigImageProxy";
  }
  protected:
  explicit ConfigImageProxy(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageProxyTypeFieldNumber = 2,
    kRemoteImageProxyUrlFieldNumber = 3,
    kRemoteImageProxyOptionsFieldNumber = 4,
    kEnableFieldNumber = 1,
  };
  // optional string image_proxy_type = 2 [json_name = "imageProxyType"];
  bool has_image_proxy_type() const;
  private:
  bool _internal_has_image_proxy_type() const;
  public:
  void clear_image_proxy_type();
  const std::string& image_proxy_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_proxy_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_proxy_type();
  PROTOBUF_NODISCARD std::string* release_image_proxy_type();
  void set_allocated_image_proxy_type(std::string* image_proxy_type);
  private:
  const std::string& _internal_image_proxy_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_proxy_type(const std::string& value);
  std::string* _internal_mutable_image_proxy_type();
  public:

  // optional string remote_image_proxy_url = 3 [json_name = "remoteImageProxyUrl"];
  bool has_remote_image_proxy_url() const;
  private:
  bool _internal_has_remote_image_proxy_url() const;
  public:
  void clear_remote_image_proxy_url();
  const std::string& remote_image_proxy_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_image_proxy_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_image_proxy_url();
  PROTOBUF_NODISCARD std::string* release_remote_image_proxy_url();
  void set_allocated_remote_image_proxy_url(std::string* remote_image_proxy_url);
  private:
  const std::string& _internal_remote_image_proxy_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_image_proxy_url(const std::string& value);
  std::string* _internal_mutable_remote_image_proxy_url();
  public:

  // optional string remote_image_proxy_options = 4 [json_name = "remoteImageProxyOptions"];
  bool has_remote_image_proxy_options() const;
  private:
  bool _internal_has_remote_image_proxy_options() const;
  public:
  void clear_remote_image_proxy_options();
  const std::string& remote_image_proxy_options() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_image_proxy_options(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_image_proxy_options();
  PROTOBUF_NODISCARD std::string* release_remote_image_proxy_options();
  void set_allocated_remote_image_proxy_options(std::string* remote_image_proxy_options);
  private:
  const std::string& _internal_remote_image_proxy_options() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_image_proxy_options(const std::string& value);
  std::string* _internal_mutable_remote_image_proxy_options();
  public:

  // optional bool enable = 1 [json_name = "enable"];
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigImageProxy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_proxy_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_image_proxy_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_image_proxy_options_;
  bool enable_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Config final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.Config) */ {
 public:
  inline Config() : Config(nullptr) {}
  ~Config() override;
  explicit constexpr Config(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Config(const Config& from);
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  inline Config& operator=(Config&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Config& default_instance() {
    return *internal_default_instance();
  }
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }
  inline void Swap(Config* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Config* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Config* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Config>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Config& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Config& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Config* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.Config";
  }
  protected:
  explicit Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMainFieldNumber = 1,
    kServicesFieldNumber = 2,
    kSecurityFieldNumber = 3,
    kCacheFieldNumber = 4,
    kMetricsFieldNumber = 5,
    kSsoFieldNumber = 6,
    kSqlFieldNumber = 7,
    kPasswordFieldNumber = 8,
    kFileFieldNumber = 9,
    kEmailFieldNumber = 10,
    kRateLimitFieldNumber = 11,
    kPrivacyFieldNumber = 12,
    kSupportFieldNumber = 13,
    kLocalizationFieldNumber = 14,
    kLdapFieldNumber = 15,
    kSamlFieldNumber = 16,
    kNativeAppFieldNumber = 17,
    kMeilisearchFieldNumber = 18,
    kBleveFieldNumber = 19,
    kDataRetentionFieldNumber = 20,
    kImageProxyFieldNumber = 21,
  };
  // .common.v1.ConfigMain main = 1 [json_name = "main"];
  bool has_main() const;
  private:
  bool _internal_has_main() const;
  public:
  void clear_main();
  const ::common::v1::ConfigMain& main() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigMain* release_main();
  ::common::v1::ConfigMain* mutable_main();
  void set_allocated_main(::common::v1::ConfigMain* main);
  private:
  const ::common::v1::ConfigMain& _internal_main() const;
  ::common::v1::ConfigMain* _internal_mutable_main();
  public:
  void unsafe_arena_set_allocated_main(
      ::common::v1::ConfigMain* main);
  ::common::v1::ConfigMain* unsafe_arena_release_main();

  // .common.v1.ConfigServices services = 2 [json_name = "services"];
  bool has_services() const;
  private:
  bool _internal_has_services() const;
  public:
  void clear_services();
  const ::common::v1::ConfigServices& services() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigServices* release_services();
  ::common::v1::ConfigServices* mutable_services();
  void set_allocated_services(::common::v1::ConfigServices* services);
  private:
  const ::common::v1::ConfigServices& _internal_services() const;
  ::common::v1::ConfigServices* _internal_mutable_services();
  public:
  void unsafe_arena_set_allocated_services(
      ::common::v1::ConfigServices* services);
  ::common::v1::ConfigServices* unsafe_arena_release_services();

  // .common.v1.ConfigSecurity security = 3 [json_name = "security"];
  bool has_security() const;
  private:
  bool _internal_has_security() const;
  public:
  void clear_security();
  const ::common::v1::ConfigSecurity& security() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigSecurity* release_security();
  ::common::v1::ConfigSecurity* mutable_security();
  void set_allocated_security(::common::v1::ConfigSecurity* security);
  private:
  const ::common::v1::ConfigSecurity& _internal_security() const;
  ::common::v1::ConfigSecurity* _internal_mutable_security();
  public:
  void unsafe_arena_set_allocated_security(
      ::common::v1::ConfigSecurity* security);
  ::common::v1::ConfigSecurity* unsafe_arena_release_security();

  // .common.v1.CacheConfig cache = 4 [json_name = "cache"];
  bool has_cache() const;
  private:
  bool _internal_has_cache() const;
  public:
  void clear_cache();
  const ::common::v1::CacheConfig& cache() const;
  PROTOBUF_NODISCARD ::common::v1::CacheConfig* release_cache();
  ::common::v1::CacheConfig* mutable_cache();
  void set_allocated_cache(::common::v1::CacheConfig* cache);
  private:
  const ::common::v1::CacheConfig& _internal_cache() const;
  ::common::v1::CacheConfig* _internal_mutable_cache();
  public:
  void unsafe_arena_set_allocated_cache(
      ::common::v1::CacheConfig* cache);
  ::common::v1::CacheConfig* unsafe_arena_release_cache();

  // .common.v1.ConfigMetrics metrics = 5 [json_name = "metrics"];
  bool has_metrics() const;
  private:
  bool _internal_has_metrics() const;
  public:
  void clear_metrics();
  const ::common::v1::ConfigMetrics& metrics() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigMetrics* release_metrics();
  ::common::v1::ConfigMetrics* mutable_metrics();
  void set_allocated_metrics(::common::v1::ConfigMetrics* metrics);
  private:
  const ::common::v1::ConfigMetrics& _internal_metrics() const;
  ::common::v1::ConfigMetrics* _internal_mutable_metrics();
  public:
  void unsafe_arena_set_allocated_metrics(
      ::common::v1::ConfigMetrics* metrics);
  ::common::v1::ConfigMetrics* unsafe_arena_release_metrics();

  // .common.v1.ConfigSSO sso = 6 [json_name = "sso"];
  bool has_sso() const;
  private:
  bool _internal_has_sso() const;
  public:
  void clear_sso();
  const ::common::v1::ConfigSSO& sso() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigSSO* release_sso();
  ::common::v1::ConfigSSO* mutable_sso();
  void set_allocated_sso(::common::v1::ConfigSSO* sso);
  private:
  const ::common::v1::ConfigSSO& _internal_sso() const;
  ::common::v1::ConfigSSO* _internal_mutable_sso();
  public:
  void unsafe_arena_set_allocated_sso(
      ::common::v1::ConfigSSO* sso);
  ::common::v1::ConfigSSO* unsafe_arena_release_sso();

  // .common.v1.ConfigSql sql = 7 [json_name = "sql"];
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const ::common::v1::ConfigSql& sql() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigSql* release_sql();
  ::common::v1::ConfigSql* mutable_sql();
  void set_allocated_sql(::common::v1::ConfigSql* sql);
  private:
  const ::common::v1::ConfigSql& _internal_sql() const;
  ::common::v1::ConfigSql* _internal_mutable_sql();
  public:
  void unsafe_arena_set_allocated_sql(
      ::common::v1::ConfigSql* sql);
  ::common::v1::ConfigSql* unsafe_arena_release_sql();

  // .common.v1.ConfigPassword password = 8 [json_name = "password"];
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const ::common::v1::ConfigPassword& password() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigPassword* release_password();
  ::common::v1::ConfigPassword* mutable_password();
  void set_allocated_password(::common::v1::ConfigPassword* password);
  private:
  const ::common::v1::ConfigPassword& _internal_password() const;
  ::common::v1::ConfigPassword* _internal_mutable_password();
  public:
  void unsafe_arena_set_allocated_password(
      ::common::v1::ConfigPassword* password);
  ::common::v1::ConfigPassword* unsafe_arena_release_password();

  // .common.v1.ConfigFile file = 9 [json_name = "file"];
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::common::v1::ConfigFile& file() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigFile* release_file();
  ::common::v1::ConfigFile* mutable_file();
  void set_allocated_file(::common::v1::ConfigFile* file);
  private:
  const ::common::v1::ConfigFile& _internal_file() const;
  ::common::v1::ConfigFile* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::common::v1::ConfigFile* file);
  ::common::v1::ConfigFile* unsafe_arena_release_file();

  // .common.v1.ConfigEmail email = 10 [json_name = "email"];
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const ::common::v1::ConfigEmail& email() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigEmail* release_email();
  ::common::v1::ConfigEmail* mutable_email();
  void set_allocated_email(::common::v1::ConfigEmail* email);
  private:
  const ::common::v1::ConfigEmail& _internal_email() const;
  ::common::v1::ConfigEmail* _internal_mutable_email();
  public:
  void unsafe_arena_set_allocated_email(
      ::common::v1::ConfigEmail* email);
  ::common::v1::ConfigEmail* unsafe_arena_release_email();

  // .common.v1.ConfigRateLimit rate_limit = 11 [json_name = "rateLimit"];
  bool has_rate_limit() const;
  private:
  bool _internal_has_rate_limit() const;
  public:
  void clear_rate_limit();
  const ::common::v1::ConfigRateLimit& rate_limit() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigRateLimit* release_rate_limit();
  ::common::v1::ConfigRateLimit* mutable_rate_limit();
  void set_allocated_rate_limit(::common::v1::ConfigRateLimit* rate_limit);
  private:
  const ::common::v1::ConfigRateLimit& _internal_rate_limit() const;
  ::common::v1::ConfigRateLimit* _internal_mutable_rate_limit();
  public:
  void unsafe_arena_set_allocated_rate_limit(
      ::common::v1::ConfigRateLimit* rate_limit);
  ::common::v1::ConfigRateLimit* unsafe_arena_release_rate_limit();

  // .common.v1.ConfigPrivacy privacy = 12 [json_name = "privacy"];
  bool has_privacy() const;
  private:
  bool _internal_has_privacy() const;
  public:
  void clear_privacy();
  const ::common::v1::ConfigPrivacy& privacy() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigPrivacy* release_privacy();
  ::common::v1::ConfigPrivacy* mutable_privacy();
  void set_allocated_privacy(::common::v1::ConfigPrivacy* privacy);
  private:
  const ::common::v1::ConfigPrivacy& _internal_privacy() const;
  ::common::v1::ConfigPrivacy* _internal_mutable_privacy();
  public:
  void unsafe_arena_set_allocated_privacy(
      ::common::v1::ConfigPrivacy* privacy);
  ::common::v1::ConfigPrivacy* unsafe_arena_release_privacy();

  // .common.v1.ConfigSupport support = 13 [json_name = "support"];
  bool has_support() const;
  private:
  bool _internal_has_support() const;
  public:
  void clear_support();
  const ::common::v1::ConfigSupport& support() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigSupport* release_support();
  ::common::v1::ConfigSupport* mutable_support();
  void set_allocated_support(::common::v1::ConfigSupport* support);
  private:
  const ::common::v1::ConfigSupport& _internal_support() const;
  ::common::v1::ConfigSupport* _internal_mutable_support();
  public:
  void unsafe_arena_set_allocated_support(
      ::common::v1::ConfigSupport* support);
  ::common::v1::ConfigSupport* unsafe_arena_release_support();

  // .common.v1.ConfigLocalization localization = 14 [json_name = "localization"];
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::common::v1::ConfigLocalization& localization() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigLocalization* release_localization();
  ::common::v1::ConfigLocalization* mutable_localization();
  void set_allocated_localization(::common::v1::ConfigLocalization* localization);
  private:
  const ::common::v1::ConfigLocalization& _internal_localization() const;
  ::common::v1::ConfigLocalization* _internal_mutable_localization();
  public:
  void unsafe_arena_set_allocated_localization(
      ::common::v1::ConfigLocalization* localization);
  ::common::v1::ConfigLocalization* unsafe_arena_release_localization();

  // .common.v1.ConfigLdap ldap = 15 [json_name = "ldap"];
  bool has_ldap() const;
  private:
  bool _internal_has_ldap() const;
  public:
  void clear_ldap();
  const ::common::v1::ConfigLdap& ldap() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigLdap* release_ldap();
  ::common::v1::ConfigLdap* mutable_ldap();
  void set_allocated_ldap(::common::v1::ConfigLdap* ldap);
  private:
  const ::common::v1::ConfigLdap& _internal_ldap() const;
  ::common::v1::ConfigLdap* _internal_mutable_ldap();
  public:
  void unsafe_arena_set_allocated_ldap(
      ::common::v1::ConfigLdap* ldap);
  ::common::v1::ConfigLdap* unsafe_arena_release_ldap();

  // .common.v1.ConfigSaml saml = 16 [json_name = "saml"];
  bool has_saml() const;
  private:
  bool _internal_has_saml() const;
  public:
  void clear_saml();
  const ::common::v1::ConfigSaml& saml() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigSaml* release_saml();
  ::common::v1::ConfigSaml* mutable_saml();
  void set_allocated_saml(::common::v1::ConfigSaml* saml);
  private:
  const ::common::v1::ConfigSaml& _internal_saml() const;
  ::common::v1::ConfigSaml* _internal_mutable_saml();
  public:
  void unsafe_arena_set_allocated_saml(
      ::common::v1::ConfigSaml* saml);
  ::common::v1::ConfigSaml* unsafe_arena_release_saml();

  // .common.v1.ConfigNativeApp native_app = 17 [json_name = "nativeApp"];
  bool has_native_app() const;
  private:
  bool _internal_has_native_app() const;
  public:
  void clear_native_app();
  const ::common::v1::ConfigNativeApp& native_app() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigNativeApp* release_native_app();
  ::common::v1::ConfigNativeApp* mutable_native_app();
  void set_allocated_native_app(::common::v1::ConfigNativeApp* native_app);
  private:
  const ::common::v1::ConfigNativeApp& _internal_native_app() const;
  ::common::v1::ConfigNativeApp* _internal_mutable_native_app();
  public:
  void unsafe_arena_set_allocated_native_app(
      ::common::v1::ConfigNativeApp* native_app);
  ::common::v1::ConfigNativeApp* unsafe_arena_release_native_app();

  // .common.v1.ConfigMeilisearch meilisearch = 18 [json_name = "meilisearch"];
  bool has_meilisearch() const;
  private:
  bool _internal_has_meilisearch() const;
  public:
  void clear_meilisearch();
  const ::common::v1::ConfigMeilisearch& meilisearch() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigMeilisearch* release_meilisearch();
  ::common::v1::ConfigMeilisearch* mutable_meilisearch();
  void set_allocated_meilisearch(::common::v1::ConfigMeilisearch* meilisearch);
  private:
  const ::common::v1::ConfigMeilisearch& _internal_meilisearch() const;
  ::common::v1::ConfigMeilisearch* _internal_mutable_meilisearch();
  public:
  void unsafe_arena_set_allocated_meilisearch(
      ::common::v1::ConfigMeilisearch* meilisearch);
  ::common::v1::ConfigMeilisearch* unsafe_arena_release_meilisearch();

  // .common.v1.ConfigBleve bleve = 19 [json_name = "bleve"];
  bool has_bleve() const;
  private:
  bool _internal_has_bleve() const;
  public:
  void clear_bleve();
  const ::common::v1::ConfigBleve& bleve() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigBleve* release_bleve();
  ::common::v1::ConfigBleve* mutable_bleve();
  void set_allocated_bleve(::common::v1::ConfigBleve* bleve);
  private:
  const ::common::v1::ConfigBleve& _internal_bleve() const;
  ::common::v1::ConfigBleve* _internal_mutable_bleve();
  public:
  void unsafe_arena_set_allocated_bleve(
      ::common::v1::ConfigBleve* bleve);
  ::common::v1::ConfigBleve* unsafe_arena_release_bleve();

  // .common.v1.ConfigDataRetention data_retention = 20 [json_name = "dataRetention"];
  bool has_data_retention() const;
  private:
  bool _internal_has_data_retention() const;
  public:
  void clear_data_retention();
  const ::common::v1::ConfigDataRetention& data_retention() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigDataRetention* release_data_retention();
  ::common::v1::ConfigDataRetention* mutable_data_retention();
  void set_allocated_data_retention(::common::v1::ConfigDataRetention* data_retention);
  private:
  const ::common::v1::ConfigDataRetention& _internal_data_retention() const;
  ::common::v1::ConfigDataRetention* _internal_mutable_data_retention();
  public:
  void unsafe_arena_set_allocated_data_retention(
      ::common::v1::ConfigDataRetention* data_retention);
  ::common::v1::ConfigDataRetention* unsafe_arena_release_data_retention();

  // .common.v1.ConfigImageProxy image_proxy = 21 [json_name = "imageProxy"];
  bool has_image_proxy() const;
  private:
  bool _internal_has_image_proxy() const;
  public:
  void clear_image_proxy();
  const ::common::v1::ConfigImageProxy& image_proxy() const;
  PROTOBUF_NODISCARD ::common::v1::ConfigImageProxy* release_image_proxy();
  ::common::v1::ConfigImageProxy* mutable_image_proxy();
  void set_allocated_image_proxy(::common::v1::ConfigImageProxy* image_proxy);
  private:
  const ::common::v1::ConfigImageProxy& _internal_image_proxy() const;
  ::common::v1::ConfigImageProxy* _internal_mutable_image_proxy();
  public:
  void unsafe_arena_set_allocated_image_proxy(
      ::common::v1::ConfigImageProxy* image_proxy);
  ::common::v1::ConfigImageProxy* unsafe_arena_release_image_proxy();

  // @@protoc_insertion_point(class_scope:common.v1.Config)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::v1::ConfigMain* main_;
  ::common::v1::ConfigServices* services_;
  ::common::v1::ConfigSecurity* security_;
  ::common::v1::CacheConfig* cache_;
  ::common::v1::ConfigMetrics* metrics_;
  ::common::v1::ConfigSSO* sso_;
  ::common::v1::ConfigSql* sql_;
  ::common::v1::ConfigPassword* password_;
  ::common::v1::ConfigFile* file_;
  ::common::v1::ConfigEmail* email_;
  ::common::v1::ConfigRateLimit* rate_limit_;
  ::common::v1::ConfigPrivacy* privacy_;
  ::common::v1::ConfigSupport* support_;
  ::common::v1::ConfigLocalization* localization_;
  ::common::v1::ConfigLdap* ldap_;
  ::common::v1::ConfigSaml* saml_;
  ::common::v1::ConfigNativeApp* native_app_;
  ::common::v1::ConfigMeilisearch* meilisearch_;
  ::common::v1::ConfigBleve* bleve_;
  ::common::v1::ConfigDataRetention* data_retention_;
  ::common::v1::ConfigImageProxy* image_proxy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:common.v1.ConfigGetRequest) */ {
 public:
  inline ConfigGetRequest() : ConfigGetRequest(nullptr) {}
  explicit constexpr ConfigGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigGetRequest(const ConfigGetRequest& from);
  ConfigGetRequest(ConfigGetRequest&& from) noexcept
    : ConfigGetRequest() {
    *this = ::std::move(from);
  }

  inline ConfigGetRequest& operator=(const ConfigGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigGetRequest& operator=(ConfigGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigGetRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigGetRequest*>(
               &_ConfigGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ConfigGetRequest& a, ConfigGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ConfigGetRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ConfigGetRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigGetRequest";
  }
  protected:
  explicit ConfigGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:common.v1.ConfigGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigGetResponse) */ {
 public:
  inline ConfigGetResponse() : ConfigGetResponse(nullptr) {}
  ~ConfigGetResponse() override;
  explicit constexpr ConfigGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigGetResponse(const ConfigGetResponse& from);
  ConfigGetResponse(ConfigGetResponse&& from) noexcept
    : ConfigGetResponse() {
    *this = ::std::move(from);
  }

  inline ConfigGetResponse& operator=(const ConfigGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigGetResponse& operator=(ConfigGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigGetResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kData = 1,
    kError = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ConfigGetResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigGetResponse*>(
               &_ConfigGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ConfigGetResponse& a, ConfigGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigGetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigGetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigGetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigGetResponse";
  }
  protected:
  explicit ConfigGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .common.v1.Config data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::common::v1::Config& data() const;
  PROTOBUF_NODISCARD ::common::v1::Config* release_data();
  ::common::v1::Config* mutable_data();
  void set_allocated_data(::common::v1::Config* data);
  private:
  const ::common::v1::Config& _internal_data() const;
  ::common::v1::Config* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::common::v1::Config* data);
  ::common::v1::Config* unsafe_arena_release_data();

  // .common.v1.AppError error = 2 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::common::v1::AppError& error() const;
  PROTOBUF_NODISCARD ::common::v1::AppError* release_error();
  ::common::v1::AppError* mutable_error();
  void set_allocated_error(::common::v1::AppError* error);
  private:
  const ::common::v1::AppError& _internal_error() const;
  ::common::v1::AppError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::common::v1::AppError* error);
  ::common::v1::AppError* unsafe_arena_release_error();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:common.v1.ConfigGetResponse)
 private:
  class _Internal;
  void set_has_data();
  void set_has_error();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::common::v1::Config* data_;
    ::common::v1::AppError* error_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigUpdateRequest) */ {
 public:
  inline ConfigUpdateRequest() : ConfigUpdateRequest(nullptr) {}
  ~ConfigUpdateRequest() override;
  explicit constexpr ConfigUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigUpdateRequest(const ConfigUpdateRequest& from);
  ConfigUpdateRequest(ConfigUpdateRequest&& from) noexcept
    : ConfigUpdateRequest() {
    *this = ::std::move(from);
  }

  inline ConfigUpdateRequest& operator=(const ConfigUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigUpdateRequest& operator=(ConfigUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigUpdateRequest*>(
               &_ConfigUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ConfigUpdateRequest& a, ConfigUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigUpdateRequest";
  }
  protected:
  explicit ConfigUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // .common.v1.Config config = 1 [json_name = "config"];
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::common::v1::Config& config() const;
  PROTOBUF_NODISCARD ::common::v1::Config* release_config();
  ::common::v1::Config* mutable_config();
  void set_allocated_config(::common::v1::Config* config);
  private:
  const ::common::v1::Config& _internal_config() const;
  ::common::v1::Config* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::common::v1::Config* config);
  ::common::v1::Config* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:common.v1.ConfigUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::common::v1::Config* config_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigUpdateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigUpdateResponse) */ {
 public:
  inline ConfigUpdateResponse() : ConfigUpdateResponse(nullptr) {}
  ~ConfigUpdateResponse() override;
  explicit constexpr ConfigUpdateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigUpdateResponse(const ConfigUpdateResponse& from);
  ConfigUpdateResponse(ConfigUpdateResponse&& from) noexcept
    : ConfigUpdateResponse() {
    *this = ::std::move(from);
  }

  inline ConfigUpdateResponse& operator=(const ConfigUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigUpdateResponse& operator=(ConfigUpdateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigUpdateResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kData = 1,
    kError = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ConfigUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigUpdateResponse*>(
               &_ConfigUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ConfigUpdateResponse& a, ConfigUpdateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigUpdateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigUpdateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigUpdateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigUpdateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigUpdateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigUpdateResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigUpdateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigUpdateResponse";
  }
  protected:
  explicit ConfigUpdateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .common.v1.Config data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::common::v1::Config& data() const;
  PROTOBUF_NODISCARD ::common::v1::Config* release_data();
  ::common::v1::Config* mutable_data();
  void set_allocated_data(::common::v1::Config* data);
  private:
  const ::common::v1::Config& _internal_data() const;
  ::common::v1::Config* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::common::v1::Config* data);
  ::common::v1::Config* unsafe_arena_release_data();

  // .common.v1.AppError error = 2 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::common::v1::AppError& error() const;
  PROTOBUF_NODISCARD ::common::v1::AppError* release_error();
  ::common::v1::AppError* mutable_error();
  void set_allocated_error(::common::v1::AppError* error);
  private:
  const ::common::v1::AppError& _internal_error() const;
  ::common::v1::AppError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::common::v1::AppError* error);
  ::common::v1::AppError* unsafe_arena_release_error();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:common.v1.ConfigUpdateResponse)
 private:
  class _Internal;
  void set_has_data();
  void set_has_error();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::common::v1::Config* data_;
    ::common::v1::AppError* error_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigListenerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigListenerResponse) */ {
 public:
  inline ConfigListenerResponse() : ConfigListenerResponse(nullptr) {}
  ~ConfigListenerResponse() override;
  explicit constexpr ConfigListenerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigListenerResponse(const ConfigListenerResponse& from);
  ConfigListenerResponse(ConfigListenerResponse&& from) noexcept
    : ConfigListenerResponse() {
    *this = ::std::move(from);
  }

  inline ConfigListenerResponse& operator=(const ConfigListenerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigListenerResponse& operator=(ConfigListenerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigListenerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kData = 1,
    kError = 2,
    RESPONSE_NOT_SET = 0,
  };

  static inline const ConfigListenerResponse* internal_default_instance() {
    return reinterpret_cast<const ConfigListenerResponse*>(
               &_ConfigListenerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ConfigListenerResponse& a, ConfigListenerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigListenerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigListenerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigListenerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigListenerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigListenerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigListenerResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigListenerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigListenerResponse";
  }
  protected:
  explicit ConfigListenerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .common.v1.Config data = 1 [json_name = "data"];
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::common::v1::Config& data() const;
  PROTOBUF_NODISCARD ::common::v1::Config* release_data();
  ::common::v1::Config* mutable_data();
  void set_allocated_data(::common::v1::Config* data);
  private:
  const ::common::v1::Config& _internal_data() const;
  ::common::v1::Config* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::common::v1::Config* data);
  ::common::v1::Config* unsafe_arena_release_data();

  // .common.v1.AppError error = 2 [json_name = "error"];
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::common::v1::AppError& error() const;
  PROTOBUF_NODISCARD ::common::v1::AppError* release_error();
  ::common::v1::AppError* mutable_error();
  void set_allocated_error(::common::v1::AppError* error);
  private:
  const ::common::v1::AppError& _internal_error() const;
  ::common::v1::AppError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::common::v1::AppError* error);
  ::common::v1::AppError* unsafe_arena_release_error();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:common.v1.ConfigListenerResponse)
 private:
  class _Internal;
  void set_has_data();
  void set_has_error();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::common::v1::Config* data_;
    ::common::v1::AppError* error_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ConfigListenerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:common.v1.ConfigListenerRequest) */ {
 public:
  inline ConfigListenerRequest() : ConfigListenerRequest(nullptr) {}
  ~ConfigListenerRequest() override;
  explicit constexpr ConfigListenerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigListenerRequest(const ConfigListenerRequest& from);
  ConfigListenerRequest(ConfigListenerRequest&& from) noexcept
    : ConfigListenerRequest() {
    *this = ::std::move(from);
  }

  inline ConfigListenerRequest& operator=(const ConfigListenerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigListenerRequest& operator=(ConfigListenerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigListenerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigListenerRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigListenerRequest*>(
               &_ConfigListenerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ConfigListenerRequest& a, ConfigListenerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigListenerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigListenerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfigListenerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfigListenerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigListenerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigListenerRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigListenerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "common.v1.ConfigListenerRequest";
  }
  protected:
  explicit ConfigListenerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // string client_id = 1 [json_name = "clientId"];
  void clear_client_id();
  const std::string& client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_id();
  PROTOBUF_NODISCARD std::string* release_client_id();
  void set_allocated_client_id(std::string* client_id);
  private:
  const std::string& _internal_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_id(const std::string& value);
  std::string* _internal_mutable_client_id();
  public:

  // @@protoc_insertion_point(class_scope:common.v1.ConfigListenerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_common_2fv1_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConfigMain

// optional string env = 1 [json_name = "env"];
inline bool ConfigMain::_internal_has_env() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigMain::has_env() const {
  return _internal_has_env();
}
inline void ConfigMain::clear_env() {
  env_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigMain::env() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.env)
  return _internal_env();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigMain::set_env(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.env)
}
inline std::string* ConfigMain::mutable_env() {
  std::string* _s = _internal_mutable_env();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMain.env)
  return _s;
}
inline const std::string& ConfigMain::_internal_env() const {
  return env_.Get();
}
inline void ConfigMain::_internal_set_env(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  env_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigMain::_internal_mutable_env() {
  _has_bits_[0] |= 0x00000001u;
  return env_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigMain::release_env() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigMain.env)
  if (!_internal_has_env()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = env_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (env_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    env_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigMain::set_allocated_env(std::string* env) {
  if (env != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  env_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), env,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (env_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    env_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigMain.env)
}

// optional int32 read_timeout = 2 [json_name = "readTimeout"];
inline bool ConfigMain::_internal_has_read_timeout() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigMain::has_read_timeout() const {
  return _internal_has_read_timeout();
}
inline void ConfigMain::clear_read_timeout() {
  read_timeout_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ConfigMain::_internal_read_timeout() const {
  return read_timeout_;
}
inline int32_t ConfigMain::read_timeout() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.read_timeout)
  return _internal_read_timeout();
}
inline void ConfigMain::_internal_set_read_timeout(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  read_timeout_ = value;
}
inline void ConfigMain::set_read_timeout(int32_t value) {
  _internal_set_read_timeout(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.read_timeout)
}

// optional int32 write_timeout = 3 [json_name = "writeTimeout"];
inline bool ConfigMain::_internal_has_write_timeout() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigMain::has_write_timeout() const {
  return _internal_has_write_timeout();
}
inline void ConfigMain::clear_write_timeout() {
  write_timeout_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ConfigMain::_internal_write_timeout() const {
  return write_timeout_;
}
inline int32_t ConfigMain::write_timeout() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.write_timeout)
  return _internal_write_timeout();
}
inline void ConfigMain::_internal_set_write_timeout(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  write_timeout_ = value;
}
inline void ConfigMain::set_write_timeout(int32_t value) {
  _internal_set_write_timeout(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.write_timeout)
}

// optional int32 idle_timeout = 4 [json_name = "idleTimeout"];
inline bool ConfigMain::_internal_has_idle_timeout() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigMain::has_idle_timeout() const {
  return _internal_has_idle_timeout();
}
inline void ConfigMain::clear_idle_timeout() {
  idle_timeout_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ConfigMain::_internal_idle_timeout() const {
  return idle_timeout_;
}
inline int32_t ConfigMain::idle_timeout() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.idle_timeout)
  return _internal_idle_timeout();
}
inline void ConfigMain::_internal_set_idle_timeout(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  idle_timeout_ = value;
}
inline void ConfigMain::set_idle_timeout(int32_t value) {
  _internal_set_idle_timeout(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.idle_timeout)
}

// optional bool enable_link_previews = 5 [json_name = "enableLinkPreviews"];
inline bool ConfigMain::_internal_has_enable_link_previews() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_link_previews() const {
  return _internal_has_enable_link_previews();
}
inline void ConfigMain::clear_enable_link_previews() {
  enable_link_previews_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigMain::_internal_enable_link_previews() const {
  return enable_link_previews_;
}
inline bool ConfigMain::enable_link_previews() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_link_previews)
  return _internal_enable_link_previews();
}
inline void ConfigMain::_internal_set_enable_link_previews(bool value) {
  _has_bits_[0] |= 0x00000020u;
  enable_link_previews_ = value;
}
inline void ConfigMain::set_enable_link_previews(bool value) {
  _internal_set_enable_link_previews(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_link_previews)
}

// optional string restrict_link_previews = 6 [json_name = "restrictLinkPreviews"];
inline bool ConfigMain::_internal_has_restrict_link_previews() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigMain::has_restrict_link_previews() const {
  return _internal_has_restrict_link_previews();
}
inline void ConfigMain::clear_restrict_link_previews() {
  restrict_link_previews_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigMain::restrict_link_previews() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.restrict_link_previews)
  return _internal_restrict_link_previews();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigMain::set_restrict_link_previews(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 restrict_link_previews_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.restrict_link_previews)
}
inline std::string* ConfigMain::mutable_restrict_link_previews() {
  std::string* _s = _internal_mutable_restrict_link_previews();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMain.restrict_link_previews)
  return _s;
}
inline const std::string& ConfigMain::_internal_restrict_link_previews() const {
  return restrict_link_previews_.Get();
}
inline void ConfigMain::_internal_set_restrict_link_previews(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  restrict_link_previews_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigMain::_internal_mutable_restrict_link_previews() {
  _has_bits_[0] |= 0x00000002u;
  return restrict_link_previews_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigMain::release_restrict_link_previews() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigMain.restrict_link_previews)
  if (!_internal_has_restrict_link_previews()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = restrict_link_previews_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (restrict_link_previews_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    restrict_link_previews_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigMain::set_allocated_restrict_link_previews(std::string* restrict_link_previews) {
  if (restrict_link_previews != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  restrict_link_previews_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), restrict_link_previews,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (restrict_link_previews_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    restrict_link_previews_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigMain.restrict_link_previews)
}

// optional bool enable_client_performance_debugging = 7 [json_name = "enableClientPerformanceDebugging"];
inline bool ConfigMain::_internal_has_enable_client_performance_debugging() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_client_performance_debugging() const {
  return _internal_has_enable_client_performance_debugging();
}
inline void ConfigMain::clear_enable_client_performance_debugging() {
  enable_client_performance_debugging_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigMain::_internal_enable_client_performance_debugging() const {
  return enable_client_performance_debugging_;
}
inline bool ConfigMain::enable_client_performance_debugging() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_client_performance_debugging)
  return _internal_enable_client_performance_debugging();
}
inline void ConfigMain::_internal_set_enable_client_performance_debugging(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enable_client_performance_debugging_ = value;
}
inline void ConfigMain::set_enable_client_performance_debugging(bool value) {
  _internal_set_enable_client_performance_debugging(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_client_performance_debugging)
}

// optional bool enable_gif_picker = 8 [json_name = "enableGifPicker"];
inline bool ConfigMain::_internal_has_enable_gif_picker() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_gif_picker() const {
  return _internal_has_enable_gif_picker();
}
inline void ConfigMain::clear_enable_gif_picker() {
  enable_gif_picker_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ConfigMain::_internal_enable_gif_picker() const {
  return enable_gif_picker_;
}
inline bool ConfigMain::enable_gif_picker() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_gif_picker)
  return _internal_enable_gif_picker();
}
inline void ConfigMain::_internal_set_enable_gif_picker(bool value) {
  _has_bits_[0] |= 0x00000080u;
  enable_gif_picker_ = value;
}
inline void ConfigMain::set_enable_gif_picker(bool value) {
  _internal_set_enable_gif_picker(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_gif_picker)
}

// optional bool enable_custom_emoji = 9 [json_name = "enableCustomEmoji"];
inline bool ConfigMain::_internal_has_enable_custom_emoji() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_custom_emoji() const {
  return _internal_has_enable_custom_emoji();
}
inline void ConfigMain::clear_enable_custom_emoji() {
  enable_custom_emoji_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ConfigMain::_internal_enable_custom_emoji() const {
  return enable_custom_emoji_;
}
inline bool ConfigMain::enable_custom_emoji() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_custom_emoji)
  return _internal_enable_custom_emoji();
}
inline void ConfigMain::_internal_set_enable_custom_emoji(bool value) {
  _has_bits_[0] |= 0x00000100u;
  enable_custom_emoji_ = value;
}
inline void ConfigMain::set_enable_custom_emoji(bool value) {
  _internal_set_enable_custom_emoji(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_custom_emoji)
}

// optional bool enable_emoji_picker = 10 [json_name = "enableEmojiPicker"];
inline bool ConfigMain::_internal_has_enable_emoji_picker() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_emoji_picker() const {
  return _internal_has_enable_emoji_picker();
}
inline void ConfigMain::clear_enable_emoji_picker() {
  enable_emoji_picker_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ConfigMain::_internal_enable_emoji_picker() const {
  return enable_emoji_picker_;
}
inline bool ConfigMain::enable_emoji_picker() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_emoji_picker)
  return _internal_enable_emoji_picker();
}
inline void ConfigMain::_internal_set_enable_emoji_picker(bool value) {
  _has_bits_[0] |= 0x00000400u;
  enable_emoji_picker_ = value;
}
inline void ConfigMain::set_enable_emoji_picker(bool value) {
  _internal_set_enable_emoji_picker(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_emoji_picker)
}

// optional int64 time_between_user_typing_updates_milliseconds = 11 [json_name = "timeBetweenUserTypingUpdatesMilliseconds"];
inline bool ConfigMain::_internal_has_time_between_user_typing_updates_milliseconds() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigMain::has_time_between_user_typing_updates_milliseconds() const {
  return _internal_has_time_between_user_typing_updates_milliseconds();
}
inline void ConfigMain::clear_time_between_user_typing_updates_milliseconds() {
  time_between_user_typing_updates_milliseconds_ = int64_t{0};
  _has_bits_[0] &= ~0x00000200u;
}
inline int64_t ConfigMain::_internal_time_between_user_typing_updates_milliseconds() const {
  return time_between_user_typing_updates_milliseconds_;
}
inline int64_t ConfigMain::time_between_user_typing_updates_milliseconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.time_between_user_typing_updates_milliseconds)
  return _internal_time_between_user_typing_updates_milliseconds();
}
inline void ConfigMain::_internal_set_time_between_user_typing_updates_milliseconds(int64_t value) {
  _has_bits_[0] |= 0x00000200u;
  time_between_user_typing_updates_milliseconds_ = value;
}
inline void ConfigMain::set_time_between_user_typing_updates_milliseconds(int64_t value) {
  _internal_set_time_between_user_typing_updates_milliseconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.time_between_user_typing_updates_milliseconds)
}

// optional bool enable_file_search = 12 [json_name = "enableFileSearch"];
inline bool ConfigMain::_internal_has_enable_file_search() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_file_search() const {
  return _internal_has_enable_file_search();
}
inline void ConfigMain::clear_enable_file_search() {
  enable_file_search_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ConfigMain::_internal_enable_file_search() const {
  return enable_file_search_;
}
inline bool ConfigMain::enable_file_search() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_file_search)
  return _internal_enable_file_search();
}
inline void ConfigMain::_internal_set_enable_file_search(bool value) {
  _has_bits_[0] |= 0x00000800u;
  enable_file_search_ = value;
}
inline void ConfigMain::set_enable_file_search(bool value) {
  _internal_set_enable_file_search(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_file_search)
}

// optional bool enable_user_typing_messages = 13 [json_name = "enableUserTypingMessages"];
inline bool ConfigMain::_internal_has_enable_user_typing_messages() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_user_typing_messages() const {
  return _internal_has_enable_user_typing_messages();
}
inline void ConfigMain::clear_enable_user_typing_messages() {
  enable_user_typing_messages_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool ConfigMain::_internal_enable_user_typing_messages() const {
  return enable_user_typing_messages_;
}
inline bool ConfigMain::enable_user_typing_messages() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_user_typing_messages)
  return _internal_enable_user_typing_messages();
}
inline void ConfigMain::_internal_set_enable_user_typing_messages(bool value) {
  _has_bits_[0] |= 0x00001000u;
  enable_user_typing_messages_ = value;
}
inline void ConfigMain::set_enable_user_typing_messages(bool value) {
  _internal_set_enable_user_typing_messages(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_user_typing_messages)
}

// optional bool enable_user_statuses = 14 [json_name = "enableUserStatuses"];
inline bool ConfigMain::_internal_has_enable_user_statuses() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_user_statuses() const {
  return _internal_has_enable_user_statuses();
}
inline void ConfigMain::clear_enable_user_statuses() {
  enable_user_statuses_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool ConfigMain::_internal_enable_user_statuses() const {
  return enable_user_statuses_;
}
inline bool ConfigMain::enable_user_statuses() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_user_statuses)
  return _internal_enable_user_statuses();
}
inline void ConfigMain::_internal_set_enable_user_statuses(bool value) {
  _has_bits_[0] |= 0x00002000u;
  enable_user_statuses_ = value;
}
inline void ConfigMain::set_enable_user_statuses(bool value) {
  _internal_set_enable_user_statuses(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_user_statuses)
}

// optional bool enable_email_invitations = 15 [json_name = "enableEmailInvitations"];
inline bool ConfigMain::_internal_has_enable_email_invitations() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_email_invitations() const {
  return _internal_has_enable_email_invitations();
}
inline void ConfigMain::clear_enable_email_invitations() {
  enable_email_invitations_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ConfigMain::_internal_enable_email_invitations() const {
  return enable_email_invitations_;
}
inline bool ConfigMain::enable_email_invitations() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_email_invitations)
  return _internal_enable_email_invitations();
}
inline void ConfigMain::_internal_set_enable_email_invitations(bool value) {
  _has_bits_[0] |= 0x00004000u;
  enable_email_invitations_ = value;
}
inline void ConfigMain::set_enable_email_invitations(bool value) {
  _internal_set_enable_email_invitations(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_email_invitations)
}

// optional bool enable_svgs = 16 [json_name = "enableSvgs"];
inline bool ConfigMain::_internal_has_enable_svgs() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ConfigMain::has_enable_svgs() const {
  return _internal_has_enable_svgs();
}
inline void ConfigMain::clear_enable_svgs() {
  enable_svgs_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool ConfigMain::_internal_enable_svgs() const {
  return enable_svgs_;
}
inline bool ConfigMain::enable_svgs() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.enable_svgs)
  return _internal_enable_svgs();
}
inline void ConfigMain::_internal_set_enable_svgs(bool value) {
  _has_bits_[0] |= 0x00008000u;
  enable_svgs_ = value;
}
inline void ConfigMain::set_enable_svgs(bool value) {
  _internal_set_enable_svgs(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.enable_svgs)
}

// optional bool allow_persistent_notifications = 17 [json_name = "allowPersistentNotifications"];
inline bool ConfigMain::_internal_has_allow_persistent_notifications() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ConfigMain::has_allow_persistent_notifications() const {
  return _internal_has_allow_persistent_notifications();
}
inline void ConfigMain::clear_allow_persistent_notifications() {
  allow_persistent_notifications_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool ConfigMain::_internal_allow_persistent_notifications() const {
  return allow_persistent_notifications_;
}
inline bool ConfigMain::allow_persistent_notifications() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.allow_persistent_notifications)
  return _internal_allow_persistent_notifications();
}
inline void ConfigMain::_internal_set_allow_persistent_notifications(bool value) {
  _has_bits_[0] |= 0x00010000u;
  allow_persistent_notifications_ = value;
}
inline void ConfigMain::set_allow_persistent_notifications(bool value) {
  _internal_set_allow_persistent_notifications(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.allow_persistent_notifications)
}

// optional int32 persistent_notification_interval_minutes = 18 [json_name = "persistentNotificationIntervalMinutes"];
inline bool ConfigMain::_internal_has_persistent_notification_interval_minutes() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ConfigMain::has_persistent_notification_interval_minutes() const {
  return _internal_has_persistent_notification_interval_minutes();
}
inline void ConfigMain::clear_persistent_notification_interval_minutes() {
  persistent_notification_interval_minutes_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t ConfigMain::_internal_persistent_notification_interval_minutes() const {
  return persistent_notification_interval_minutes_;
}
inline int32_t ConfigMain::persistent_notification_interval_minutes() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.persistent_notification_interval_minutes)
  return _internal_persistent_notification_interval_minutes();
}
inline void ConfigMain::_internal_set_persistent_notification_interval_minutes(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  persistent_notification_interval_minutes_ = value;
}
inline void ConfigMain::set_persistent_notification_interval_minutes(int32_t value) {
  _internal_set_persistent_notification_interval_minutes(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.persistent_notification_interval_minutes)
}

// optional int32 persistent_notification_max_count = 19 [json_name = "persistentNotificationMaxCount"];
inline bool ConfigMain::_internal_has_persistent_notification_max_count() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ConfigMain::has_persistent_notification_max_count() const {
  return _internal_has_persistent_notification_max_count();
}
inline void ConfigMain::clear_persistent_notification_max_count() {
  persistent_notification_max_count_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline int32_t ConfigMain::_internal_persistent_notification_max_count() const {
  return persistent_notification_max_count_;
}
inline int32_t ConfigMain::persistent_notification_max_count() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.persistent_notification_max_count)
  return _internal_persistent_notification_max_count();
}
inline void ConfigMain::_internal_set_persistent_notification_max_count(int32_t value) {
  _has_bits_[0] |= 0x00080000u;
  persistent_notification_max_count_ = value;
}
inline void ConfigMain::set_persistent_notification_max_count(int32_t value) {
  _internal_set_persistent_notification_max_count(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.persistent_notification_max_count)
}

// optional int32 persistent_notification_max_recipients = 20 [json_name = "persistentNotificationMaxRecipients"];
inline bool ConfigMain::_internal_has_persistent_notification_max_recipients() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ConfigMain::has_persistent_notification_max_recipients() const {
  return _internal_has_persistent_notification_max_recipients();
}
inline void ConfigMain::clear_persistent_notification_max_recipients() {
  persistent_notification_max_recipients_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline int32_t ConfigMain::_internal_persistent_notification_max_recipients() const {
  return persistent_notification_max_recipients_;
}
inline int32_t ConfigMain::persistent_notification_max_recipients() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.persistent_notification_max_recipients)
  return _internal_persistent_notification_max_recipients();
}
inline void ConfigMain::_internal_set_persistent_notification_max_recipients(int32_t value) {
  _has_bits_[0] |= 0x00100000u;
  persistent_notification_max_recipients_ = value;
}
inline void ConfigMain::set_persistent_notification_max_recipients(int32_t value) {
  _internal_set_persistent_notification_max_recipients(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.persistent_notification_max_recipients)
}

// optional int32 feature_flag_sync_interval_seconds = 21 [json_name = "featureFlagSyncIntervalSeconds"];
inline bool ConfigMain::_internal_has_feature_flag_sync_interval_seconds() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ConfigMain::has_feature_flag_sync_interval_seconds() const {
  return _internal_has_feature_flag_sync_interval_seconds();
}
inline void ConfigMain::clear_feature_flag_sync_interval_seconds() {
  feature_flag_sync_interval_seconds_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline int32_t ConfigMain::_internal_feature_flag_sync_interval_seconds() const {
  return feature_flag_sync_interval_seconds_;
}
inline int32_t ConfigMain::feature_flag_sync_interval_seconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.feature_flag_sync_interval_seconds)
  return _internal_feature_flag_sync_interval_seconds();
}
inline void ConfigMain::_internal_set_feature_flag_sync_interval_seconds(int32_t value) {
  _has_bits_[0] |= 0x00200000u;
  feature_flag_sync_interval_seconds_ = value;
}
inline void ConfigMain::set_feature_flag_sync_interval_seconds(int32_t value) {
  _internal_set_feature_flag_sync_interval_seconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.feature_flag_sync_interval_seconds)
}

// optional bool allow_synced_drafts = 22 [json_name = "allowSyncedDrafts"];
inline bool ConfigMain::_internal_has_allow_synced_drafts() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ConfigMain::has_allow_synced_drafts() const {
  return _internal_has_allow_synced_drafts();
}
inline void ConfigMain::clear_allow_synced_drafts() {
  allow_synced_drafts_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool ConfigMain::_internal_allow_synced_drafts() const {
  return allow_synced_drafts_;
}
inline bool ConfigMain::allow_synced_drafts() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMain.allow_synced_drafts)
  return _internal_allow_synced_drafts();
}
inline void ConfigMain::_internal_set_allow_synced_drafts(bool value) {
  _has_bits_[0] |= 0x00020000u;
  allow_synced_drafts_ = value;
}
inline void ConfigMain::set_allow_synced_drafts(bool value) {
  _internal_set_allow_synced_drafts(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMain.allow_synced_drafts)
}

// -------------------------------------------------------------------

// ConfigServices

// optional string common_service_grpc_url = 1 [json_name = "commonServiceGrpcUrl"];
inline bool ConfigServices::_internal_has_common_service_grpc_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigServices::has_common_service_grpc_url() const {
  return _internal_has_common_service_grpc_url();
}
inline void ConfigServices::clear_common_service_grpc_url() {
  common_service_grpc_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigServices::common_service_grpc_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigServices.common_service_grpc_url)
  return _internal_common_service_grpc_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigServices::set_common_service_grpc_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 common_service_grpc_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigServices.common_service_grpc_url)
}
inline std::string* ConfigServices::mutable_common_service_grpc_url() {
  std::string* _s = _internal_mutable_common_service_grpc_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigServices.common_service_grpc_url)
  return _s;
}
inline const std::string& ConfigServices::_internal_common_service_grpc_url() const {
  return common_service_grpc_url_.Get();
}
inline void ConfigServices::_internal_set_common_service_grpc_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  common_service_grpc_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigServices::_internal_mutable_common_service_grpc_url() {
  _has_bits_[0] |= 0x00000001u;
  return common_service_grpc_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigServices::release_common_service_grpc_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigServices.common_service_grpc_url)
  if (!_internal_has_common_service_grpc_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = common_service_grpc_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (common_service_grpc_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    common_service_grpc_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigServices::set_allocated_common_service_grpc_url(std::string* common_service_grpc_url) {
  if (common_service_grpc_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  common_service_grpc_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), common_service_grpc_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (common_service_grpc_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    common_service_grpc_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigServices.common_service_grpc_url)
}

// optional string user_service_grpc_url = 2 [json_name = "userServiceGrpcUrl"];
inline bool ConfigServices::_internal_has_user_service_grpc_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigServices::has_user_service_grpc_url() const {
  return _internal_has_user_service_grpc_url();
}
inline void ConfigServices::clear_user_service_grpc_url() {
  user_service_grpc_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigServices::user_service_grpc_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigServices.user_service_grpc_url)
  return _internal_user_service_grpc_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigServices::set_user_service_grpc_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_service_grpc_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigServices.user_service_grpc_url)
}
inline std::string* ConfigServices::mutable_user_service_grpc_url() {
  std::string* _s = _internal_mutable_user_service_grpc_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigServices.user_service_grpc_url)
  return _s;
}
inline const std::string& ConfigServices::_internal_user_service_grpc_url() const {
  return user_service_grpc_url_.Get();
}
inline void ConfigServices::_internal_set_user_service_grpc_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_service_grpc_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigServices::_internal_mutable_user_service_grpc_url() {
  _has_bits_[0] |= 0x00000002u;
  return user_service_grpc_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigServices::release_user_service_grpc_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigServices.user_service_grpc_url)
  if (!_internal_has_user_service_grpc_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_service_grpc_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_service_grpc_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_service_grpc_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigServices::set_allocated_user_service_grpc_url(std::string* user_service_grpc_url) {
  if (user_service_grpc_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_service_grpc_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_service_grpc_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_service_grpc_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_service_grpc_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigServices.user_service_grpc_url)
}

// optional string jaeger_collector_url = 3 [json_name = "jaegerCollectorUrl"];
inline bool ConfigServices::_internal_has_jaeger_collector_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigServices::has_jaeger_collector_url() const {
  return _internal_has_jaeger_collector_url();
}
inline void ConfigServices::clear_jaeger_collector_url() {
  jaeger_collector_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigServices::jaeger_collector_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigServices.jaeger_collector_url)
  return _internal_jaeger_collector_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigServices::set_jaeger_collector_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 jaeger_collector_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigServices.jaeger_collector_url)
}
inline std::string* ConfigServices::mutable_jaeger_collector_url() {
  std::string* _s = _internal_mutable_jaeger_collector_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigServices.jaeger_collector_url)
  return _s;
}
inline const std::string& ConfigServices::_internal_jaeger_collector_url() const {
  return jaeger_collector_url_.Get();
}
inline void ConfigServices::_internal_set_jaeger_collector_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  jaeger_collector_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigServices::_internal_mutable_jaeger_collector_url() {
  _has_bits_[0] |= 0x00000004u;
  return jaeger_collector_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigServices::release_jaeger_collector_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigServices.jaeger_collector_url)
  if (!_internal_has_jaeger_collector_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = jaeger_collector_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (jaeger_collector_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    jaeger_collector_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigServices::set_allocated_jaeger_collector_url(std::string* jaeger_collector_url) {
  if (jaeger_collector_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  jaeger_collector_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jaeger_collector_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (jaeger_collector_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    jaeger_collector_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigServices.jaeger_collector_url)
}

// optional string common_service_prometheus_url = 4 [json_name = "commonServicePrometheusUrl"];
inline bool ConfigServices::_internal_has_common_service_prometheus_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigServices::has_common_service_prometheus_url() const {
  return _internal_has_common_service_prometheus_url();
}
inline void ConfigServices::clear_common_service_prometheus_url() {
  common_service_prometheus_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigServices::common_service_prometheus_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigServices.common_service_prometheus_url)
  return _internal_common_service_prometheus_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigServices::set_common_service_prometheus_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 common_service_prometheus_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigServices.common_service_prometheus_url)
}
inline std::string* ConfigServices::mutable_common_service_prometheus_url() {
  std::string* _s = _internal_mutable_common_service_prometheus_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigServices.common_service_prometheus_url)
  return _s;
}
inline const std::string& ConfigServices::_internal_common_service_prometheus_url() const {
  return common_service_prometheus_url_.Get();
}
inline void ConfigServices::_internal_set_common_service_prometheus_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  common_service_prometheus_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigServices::_internal_mutable_common_service_prometheus_url() {
  _has_bits_[0] |= 0x00000008u;
  return common_service_prometheus_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigServices::release_common_service_prometheus_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigServices.common_service_prometheus_url)
  if (!_internal_has_common_service_prometheus_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = common_service_prometheus_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (common_service_prometheus_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    common_service_prometheus_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigServices::set_allocated_common_service_prometheus_url(std::string* common_service_prometheus_url) {
  if (common_service_prometheus_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  common_service_prometheus_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), common_service_prometheus_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (common_service_prometheus_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    common_service_prometheus_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigServices.common_service_prometheus_url)
}

// optional string user_service_prometheus_url = 5 [json_name = "userServicePrometheusUrl"];
inline bool ConfigServices::_internal_has_user_service_prometheus_url() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigServices::has_user_service_prometheus_url() const {
  return _internal_has_user_service_prometheus_url();
}
inline void ConfigServices::clear_user_service_prometheus_url() {
  user_service_prometheus_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigServices::user_service_prometheus_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigServices.user_service_prometheus_url)
  return _internal_user_service_prometheus_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigServices::set_user_service_prometheus_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 user_service_prometheus_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigServices.user_service_prometheus_url)
}
inline std::string* ConfigServices::mutable_user_service_prometheus_url() {
  std::string* _s = _internal_mutable_user_service_prometheus_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigServices.user_service_prometheus_url)
  return _s;
}
inline const std::string& ConfigServices::_internal_user_service_prometheus_url() const {
  return user_service_prometheus_url_.Get();
}
inline void ConfigServices::_internal_set_user_service_prometheus_url(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  user_service_prometheus_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigServices::_internal_mutable_user_service_prometheus_url() {
  _has_bits_[0] |= 0x00000010u;
  return user_service_prometheus_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigServices::release_user_service_prometheus_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigServices.user_service_prometheus_url)
  if (!_internal_has_user_service_prometheus_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = user_service_prometheus_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_service_prometheus_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_service_prometheus_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigServices::set_allocated_user_service_prometheus_url(std::string* user_service_prometheus_url) {
  if (user_service_prometheus_url != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  user_service_prometheus_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_service_prometheus_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_service_prometheus_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_service_prometheus_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigServices.user_service_prometheus_url)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ConfigSecurity

// map<string, string> restricted_usernames = 1 [json_name = "restrictedUsernames"];
inline int ConfigSecurity::_internal_restricted_usernames_size() const {
  return restricted_usernames_.size();
}
inline int ConfigSecurity::restricted_usernames_size() const {
  return _internal_restricted_usernames_size();
}
inline void ConfigSecurity::clear_restricted_usernames() {
  restricted_usernames_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigSecurity::_internal_restricted_usernames() const {
  return restricted_usernames_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ConfigSecurity::restricted_usernames() const {
  // @@protoc_insertion_point(field_map:common.v1.ConfigSecurity.restricted_usernames)
  return _internal_restricted_usernames();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigSecurity::_internal_mutable_restricted_usernames() {
  return restricted_usernames_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ConfigSecurity::mutable_restricted_usernames() {
  // @@protoc_insertion_point(field_mutable_map:common.v1.ConfigSecurity.restricted_usernames)
  return _internal_mutable_restricted_usernames();
}

// optional int32 maximum_login_attempts = 2 [json_name = "maximumLoginAttempts"];
inline bool ConfigSecurity::_internal_has_maximum_login_attempts() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigSecurity::has_maximum_login_attempts() const {
  return _internal_has_maximum_login_attempts();
}
inline void ConfigSecurity::clear_maximum_login_attempts() {
  maximum_login_attempts_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ConfigSecurity::_internal_maximum_login_attempts() const {
  return maximum_login_attempts_;
}
inline int32_t ConfigSecurity::maximum_login_attempts() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.maximum_login_attempts)
  return _internal_maximum_login_attempts();
}
inline void ConfigSecurity::_internal_set_maximum_login_attempts(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  maximum_login_attempts_ = value;
}
inline void ConfigSecurity::set_maximum_login_attempts(int32_t value) {
  _internal_set_maximum_login_attempts(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.maximum_login_attempts)
}

// optional bool enable_insecure_outgoing_connections = 3 [json_name = "enableInsecureOutgoingConnections"];
inline bool ConfigSecurity::_internal_has_enable_insecure_outgoing_connections() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigSecurity::has_enable_insecure_outgoing_connections() const {
  return _internal_has_enable_insecure_outgoing_connections();
}
inline void ConfigSecurity::clear_enable_insecure_outgoing_connections() {
  enable_insecure_outgoing_connections_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigSecurity::_internal_enable_insecure_outgoing_connections() const {
  return enable_insecure_outgoing_connections_;
}
inline bool ConfigSecurity::enable_insecure_outgoing_connections() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.enable_insecure_outgoing_connections)
  return _internal_enable_insecure_outgoing_connections();
}
inline void ConfigSecurity::_internal_set_enable_insecure_outgoing_connections(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_insecure_outgoing_connections_ = value;
}
inline void ConfigSecurity::set_enable_insecure_outgoing_connections(bool value) {
  _internal_set_enable_insecure_outgoing_connections(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.enable_insecure_outgoing_connections)
}

// optional bool enable_multifactor_authentication = 4 [json_name = "enableMultifactorAuthentication"];
inline bool ConfigSecurity::_internal_has_enable_multifactor_authentication() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigSecurity::has_enable_multifactor_authentication() const {
  return _internal_has_enable_multifactor_authentication();
}
inline void ConfigSecurity::clear_enable_multifactor_authentication() {
  enable_multifactor_authentication_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigSecurity::_internal_enable_multifactor_authentication() const {
  return enable_multifactor_authentication_;
}
inline bool ConfigSecurity::enable_multifactor_authentication() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.enable_multifactor_authentication)
  return _internal_enable_multifactor_authentication();
}
inline void ConfigSecurity::_internal_set_enable_multifactor_authentication(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_multifactor_authentication_ = value;
}
inline void ConfigSecurity::set_enable_multifactor_authentication(bool value) {
  _internal_set_enable_multifactor_authentication(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.enable_multifactor_authentication)
}

// optional bool enforce_multifactor_authentication = 5 [json_name = "enforceMultifactorAuthentication"];
inline bool ConfigSecurity::_internal_has_enforce_multifactor_authentication() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigSecurity::has_enforce_multifactor_authentication() const {
  return _internal_has_enforce_multifactor_authentication();
}
inline void ConfigSecurity::clear_enforce_multifactor_authentication() {
  enforce_multifactor_authentication_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigSecurity::_internal_enforce_multifactor_authentication() const {
  return enforce_multifactor_authentication_;
}
inline bool ConfigSecurity::enforce_multifactor_authentication() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.enforce_multifactor_authentication)
  return _internal_enforce_multifactor_authentication();
}
inline void ConfigSecurity::_internal_set_enforce_multifactor_authentication(bool value) {
  _has_bits_[0] |= 0x00000020u;
  enforce_multifactor_authentication_ = value;
}
inline void ConfigSecurity::set_enforce_multifactor_authentication(bool value) {
  _internal_set_enforce_multifactor_authentication(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.enforce_multifactor_authentication)
}

// optional bool enable_oauth_service_provider = 6 [json_name = "enableOauthServiceProvider"];
inline bool ConfigSecurity::_internal_has_enable_oauth_service_provider() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigSecurity::has_enable_oauth_service_provider() const {
  return _internal_has_enable_oauth_service_provider();
}
inline void ConfigSecurity::clear_enable_oauth_service_provider() {
  enable_oauth_service_provider_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigSecurity::_internal_enable_oauth_service_provider() const {
  return enable_oauth_service_provider_;
}
inline bool ConfigSecurity::enable_oauth_service_provider() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.enable_oauth_service_provider)
  return _internal_enable_oauth_service_provider();
}
inline void ConfigSecurity::_internal_set_enable_oauth_service_provider(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enable_oauth_service_provider_ = value;
}
inline void ConfigSecurity::set_enable_oauth_service_provider(bool value) {
  _internal_set_enable_oauth_service_provider(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.enable_oauth_service_provider)
}

// optional bool enable_outgoing_oauth_connections = 7 [json_name = "enableOutgoingOauthConnections"];
inline bool ConfigSecurity::_internal_has_enable_outgoing_oauth_connections() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ConfigSecurity::has_enable_outgoing_oauth_connections() const {
  return _internal_has_enable_outgoing_oauth_connections();
}
inline void ConfigSecurity::clear_enable_outgoing_oauth_connections() {
  enable_outgoing_oauth_connections_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ConfigSecurity::_internal_enable_outgoing_oauth_connections() const {
  return enable_outgoing_oauth_connections_;
}
inline bool ConfigSecurity::enable_outgoing_oauth_connections() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.enable_outgoing_oauth_connections)
  return _internal_enable_outgoing_oauth_connections();
}
inline void ConfigSecurity::_internal_set_enable_outgoing_oauth_connections(bool value) {
  _has_bits_[0] |= 0x00000400u;
  enable_outgoing_oauth_connections_ = value;
}
inline void ConfigSecurity::set_enable_outgoing_oauth_connections(bool value) {
  _internal_set_enable_outgoing_oauth_connections(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.enable_outgoing_oauth_connections)
}

// optional bool terminate_sessions_on_password_change = 8 [json_name = "terminateSessionsOnPasswordChange"];
inline bool ConfigSecurity::_internal_has_terminate_sessions_on_password_change() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ConfigSecurity::has_terminate_sessions_on_password_change() const {
  return _internal_has_terminate_sessions_on_password_change();
}
inline void ConfigSecurity::clear_terminate_sessions_on_password_change() {
  terminate_sessions_on_password_change_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool ConfigSecurity::_internal_terminate_sessions_on_password_change() const {
  return terminate_sessions_on_password_change_;
}
inline bool ConfigSecurity::terminate_sessions_on_password_change() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.terminate_sessions_on_password_change)
  return _internal_terminate_sessions_on_password_change();
}
inline void ConfigSecurity::_internal_set_terminate_sessions_on_password_change(bool value) {
  _has_bits_[0] |= 0x00000800u;
  terminate_sessions_on_password_change_ = value;
}
inline void ConfigSecurity::set_terminate_sessions_on_password_change(bool value) {
  _internal_set_terminate_sessions_on_password_change(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.terminate_sessions_on_password_change)
}

// optional int32 session_length_web_in_hours = 9 [json_name = "sessionLengthWebInHours"];
inline bool ConfigSecurity::_internal_has_session_length_web_in_hours() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigSecurity::has_session_length_web_in_hours() const {
  return _internal_has_session_length_web_in_hours();
}
inline void ConfigSecurity::clear_session_length_web_in_hours() {
  session_length_web_in_hours_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ConfigSecurity::_internal_session_length_web_in_hours() const {
  return session_length_web_in_hours_;
}
inline int32_t ConfigSecurity::session_length_web_in_hours() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.session_length_web_in_hours)
  return _internal_session_length_web_in_hours();
}
inline void ConfigSecurity::_internal_set_session_length_web_in_hours(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  session_length_web_in_hours_ = value;
}
inline void ConfigSecurity::set_session_length_web_in_hours(int32_t value) {
  _internal_set_session_length_web_in_hours(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.session_length_web_in_hours)
}

// optional int32 session_length_mobile_in_hours = 10 [json_name = "sessionLengthMobileInHours"];
inline bool ConfigSecurity::_internal_has_session_length_mobile_in_hours() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigSecurity::has_session_length_mobile_in_hours() const {
  return _internal_has_session_length_mobile_in_hours();
}
inline void ConfigSecurity::clear_session_length_mobile_in_hours() {
  session_length_mobile_in_hours_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ConfigSecurity::_internal_session_length_mobile_in_hours() const {
  return session_length_mobile_in_hours_;
}
inline int32_t ConfigSecurity::session_length_mobile_in_hours() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.session_length_mobile_in_hours)
  return _internal_session_length_mobile_in_hours();
}
inline void ConfigSecurity::_internal_set_session_length_mobile_in_hours(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  session_length_mobile_in_hours_ = value;
}
inline void ConfigSecurity::set_session_length_mobile_in_hours(int32_t value) {
  _internal_set_session_length_mobile_in_hours(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.session_length_mobile_in_hours)
}

// optional int32 session_length_sso_in_hours = 11 [json_name = "sessionLengthSsoInHours"];
inline bool ConfigSecurity::_internal_has_session_length_sso_in_hours() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigSecurity::has_session_length_sso_in_hours() const {
  return _internal_has_session_length_sso_in_hours();
}
inline void ConfigSecurity::clear_session_length_sso_in_hours() {
  session_length_sso_in_hours_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ConfigSecurity::_internal_session_length_sso_in_hours() const {
  return session_length_sso_in_hours_;
}
inline int32_t ConfigSecurity::session_length_sso_in_hours() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.session_length_sso_in_hours)
  return _internal_session_length_sso_in_hours();
}
inline void ConfigSecurity::_internal_set_session_length_sso_in_hours(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  session_length_sso_in_hours_ = value;
}
inline void ConfigSecurity::set_session_length_sso_in_hours(int32_t value) {
  _internal_set_session_length_sso_in_hours(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.session_length_sso_in_hours)
}

// optional string allow_cors_from = 12 [json_name = "allowCorsFrom"];
inline bool ConfigSecurity::_internal_has_allow_cors_from() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigSecurity::has_allow_cors_from() const {
  return _internal_has_allow_cors_from();
}
inline void ConfigSecurity::clear_allow_cors_from() {
  allow_cors_from_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigSecurity::allow_cors_from() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.allow_cors_from)
  return _internal_allow_cors_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSecurity::set_allow_cors_from(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 allow_cors_from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.allow_cors_from)
}
inline std::string* ConfigSecurity::mutable_allow_cors_from() {
  std::string* _s = _internal_mutable_allow_cors_from();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSecurity.allow_cors_from)
  return _s;
}
inline const std::string& ConfigSecurity::_internal_allow_cors_from() const {
  return allow_cors_from_.Get();
}
inline void ConfigSecurity::_internal_set_allow_cors_from(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  allow_cors_from_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSecurity::_internal_mutable_allow_cors_from() {
  _has_bits_[0] |= 0x00000001u;
  return allow_cors_from_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSecurity::release_allow_cors_from() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSecurity.allow_cors_from)
  if (!_internal_has_allow_cors_from()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = allow_cors_from_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (allow_cors_from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    allow_cors_from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSecurity::set_allocated_allow_cors_from(std::string* allow_cors_from) {
  if (allow_cors_from != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  allow_cors_from_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), allow_cors_from,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (allow_cors_from_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    allow_cors_from_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSecurity.allow_cors_from)
}

// optional string cors_exposed_headers = 13 [json_name = "corsExposedHeaders"];
inline bool ConfigSecurity::_internal_has_cors_exposed_headers() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigSecurity::has_cors_exposed_headers() const {
  return _internal_has_cors_exposed_headers();
}
inline void ConfigSecurity::clear_cors_exposed_headers() {
  cors_exposed_headers_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigSecurity::cors_exposed_headers() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.cors_exposed_headers)
  return _internal_cors_exposed_headers();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSecurity::set_cors_exposed_headers(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 cors_exposed_headers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.cors_exposed_headers)
}
inline std::string* ConfigSecurity::mutable_cors_exposed_headers() {
  std::string* _s = _internal_mutable_cors_exposed_headers();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSecurity.cors_exposed_headers)
  return _s;
}
inline const std::string& ConfigSecurity::_internal_cors_exposed_headers() const {
  return cors_exposed_headers_.Get();
}
inline void ConfigSecurity::_internal_set_cors_exposed_headers(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cors_exposed_headers_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSecurity::_internal_mutable_cors_exposed_headers() {
  _has_bits_[0] |= 0x00000002u;
  return cors_exposed_headers_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSecurity::release_cors_exposed_headers() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSecurity.cors_exposed_headers)
  if (!_internal_has_cors_exposed_headers()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = cors_exposed_headers_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cors_exposed_headers_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cors_exposed_headers_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSecurity::set_allocated_cors_exposed_headers(std::string* cors_exposed_headers) {
  if (cors_exposed_headers != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cors_exposed_headers_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cors_exposed_headers,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cors_exposed_headers_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cors_exposed_headers_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSecurity.cors_exposed_headers)
}

// optional bool cors_allow_credentials = 14 [json_name = "corsAllowCredentials"];
inline bool ConfigSecurity::_internal_has_cors_allow_credentials() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ConfigSecurity::has_cors_allow_credentials() const {
  return _internal_has_cors_allow_credentials();
}
inline void ConfigSecurity::clear_cors_allow_credentials() {
  cors_allow_credentials_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool ConfigSecurity::_internal_cors_allow_credentials() const {
  return cors_allow_credentials_;
}
inline bool ConfigSecurity::cors_allow_credentials() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.cors_allow_credentials)
  return _internal_cors_allow_credentials();
}
inline void ConfigSecurity::_internal_set_cors_allow_credentials(bool value) {
  _has_bits_[0] |= 0x00001000u;
  cors_allow_credentials_ = value;
}
inline void ConfigSecurity::set_cors_allow_credentials(bool value) {
  _internal_set_cors_allow_credentials(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.cors_allow_credentials)
}

// optional bool cors_debug = 15 [json_name = "corsDebug"];
inline bool ConfigSecurity::_internal_has_cors_debug() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ConfigSecurity::has_cors_debug() const {
  return _internal_has_cors_debug();
}
inline void ConfigSecurity::clear_cors_debug() {
  cors_debug_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool ConfigSecurity::_internal_cors_debug() const {
  return cors_debug_;
}
inline bool ConfigSecurity::cors_debug() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.cors_debug)
  return _internal_cors_debug();
}
inline void ConfigSecurity::_internal_set_cors_debug(bool value) {
  _has_bits_[0] |= 0x00002000u;
  cors_debug_ = value;
}
inline void ConfigSecurity::set_cors_debug(bool value) {
  _internal_set_cors_debug(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.cors_debug)
}

// optional bool allow_cookies_for_subdomains = 16 [json_name = "allowCookiesForSubdomains"];
inline bool ConfigSecurity::_internal_has_allow_cookies_for_subdomains() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ConfigSecurity::has_allow_cookies_for_subdomains() const {
  return _internal_has_allow_cookies_for_subdomains();
}
inline void ConfigSecurity::clear_allow_cookies_for_subdomains() {
  allow_cookies_for_subdomains_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ConfigSecurity::_internal_allow_cookies_for_subdomains() const {
  return allow_cookies_for_subdomains_;
}
inline bool ConfigSecurity::allow_cookies_for_subdomains() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.allow_cookies_for_subdomains)
  return _internal_allow_cookies_for_subdomains();
}
inline void ConfigSecurity::_internal_set_allow_cookies_for_subdomains(bool value) {
  _has_bits_[0] |= 0x00004000u;
  allow_cookies_for_subdomains_ = value;
}
inline void ConfigSecurity::set_allow_cookies_for_subdomains(bool value) {
  _internal_set_allow_cookies_for_subdomains(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.allow_cookies_for_subdomains)
}

// optional int32 session_cache_in_minutes = 17 [json_name = "sessionCacheInMinutes"];
inline bool ConfigSecurity::_internal_has_session_cache_in_minutes() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ConfigSecurity::has_session_cache_in_minutes() const {
  return _internal_has_session_cache_in_minutes();
}
inline void ConfigSecurity::clear_session_cache_in_minutes() {
  session_cache_in_minutes_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline int32_t ConfigSecurity::_internal_session_cache_in_minutes() const {
  return session_cache_in_minutes_;
}
inline int32_t ConfigSecurity::session_cache_in_minutes() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.session_cache_in_minutes)
  return _internal_session_cache_in_minutes();
}
inline void ConfigSecurity::_internal_set_session_cache_in_minutes(int32_t value) {
  _has_bits_[0] |= 0x00008000u;
  session_cache_in_minutes_ = value;
}
inline void ConfigSecurity::set_session_cache_in_minutes(int32_t value) {
  _internal_set_session_cache_in_minutes(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.session_cache_in_minutes)
}

// optional int32 websocket_secure_port = 18 [json_name = "websocketSecurePort"];
inline bool ConfigSecurity::_internal_has_websocket_secure_port() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ConfigSecurity::has_websocket_secure_port() const {
  return _internal_has_websocket_secure_port();
}
inline void ConfigSecurity::clear_websocket_secure_port() {
  websocket_secure_port_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline int32_t ConfigSecurity::_internal_websocket_secure_port() const {
  return websocket_secure_port_;
}
inline int32_t ConfigSecurity::websocket_secure_port() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.websocket_secure_port)
  return _internal_websocket_secure_port();
}
inline void ConfigSecurity::_internal_set_websocket_secure_port(int32_t value) {
  _has_bits_[0] |= 0x00010000u;
  websocket_secure_port_ = value;
}
inline void ConfigSecurity::set_websocket_secure_port(int32_t value) {
  _internal_set_websocket_secure_port(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.websocket_secure_port)
}

// optional int32 websocket_port = 19 [json_name = "websocketPort"];
inline bool ConfigSecurity::_internal_has_websocket_port() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ConfigSecurity::has_websocket_port() const {
  return _internal_has_websocket_port();
}
inline void ConfigSecurity::clear_websocket_port() {
  websocket_port_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline int32_t ConfigSecurity::_internal_websocket_port() const {
  return websocket_port_;
}
inline int32_t ConfigSecurity::websocket_port() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSecurity.websocket_port)
  return _internal_websocket_port();
}
inline void ConfigSecurity::_internal_set_websocket_port(int32_t value) {
  _has_bits_[0] |= 0x00020000u;
  websocket_port_ = value;
}
inline void ConfigSecurity::set_websocket_port(int32_t value) {
  _internal_set_websocket_port(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSecurity.websocket_port)
}

// -------------------------------------------------------------------

// CacheConfig

// optional string cache_type = 1 [json_name = "cacheType"];
inline bool CacheConfig::_internal_has_cache_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CacheConfig::has_cache_type() const {
  return _internal_has_cache_type();
}
inline void CacheConfig::clear_cache_type() {
  cache_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CacheConfig::cache_type() const {
  // @@protoc_insertion_point(field_get:common.v1.CacheConfig.cache_type)
  return _internal_cache_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheConfig::set_cache_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cache_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.CacheConfig.cache_type)
}
inline std::string* CacheConfig::mutable_cache_type() {
  std::string* _s = _internal_mutable_cache_type();
  // @@protoc_insertion_point(field_mutable:common.v1.CacheConfig.cache_type)
  return _s;
}
inline const std::string& CacheConfig::_internal_cache_type() const {
  return cache_type_.Get();
}
inline void CacheConfig::_internal_set_cache_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cache_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheConfig::_internal_mutable_cache_type() {
  _has_bits_[0] |= 0x00000001u;
  return cache_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheConfig::release_cache_type() {
  // @@protoc_insertion_point(field_release:common.v1.CacheConfig.cache_type)
  if (!_internal_has_cache_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cache_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cache_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CacheConfig::set_allocated_cache_type(std::string* cache_type) {
  if (cache_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cache_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cache_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cache_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.CacheConfig.cache_type)
}

// optional string redis_address = 2 [json_name = "redisAddress"];
inline bool CacheConfig::_internal_has_redis_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CacheConfig::has_redis_address() const {
  return _internal_has_redis_address();
}
inline void CacheConfig::clear_redis_address() {
  redis_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CacheConfig::redis_address() const {
  // @@protoc_insertion_point(field_get:common.v1.CacheConfig.redis_address)
  return _internal_redis_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheConfig::set_redis_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 redis_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.CacheConfig.redis_address)
}
inline std::string* CacheConfig::mutable_redis_address() {
  std::string* _s = _internal_mutable_redis_address();
  // @@protoc_insertion_point(field_mutable:common.v1.CacheConfig.redis_address)
  return _s;
}
inline const std::string& CacheConfig::_internal_redis_address() const {
  return redis_address_.Get();
}
inline void CacheConfig::_internal_set_redis_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  redis_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheConfig::_internal_mutable_redis_address() {
  _has_bits_[0] |= 0x00000002u;
  return redis_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheConfig::release_redis_address() {
  // @@protoc_insertion_point(field_release:common.v1.CacheConfig.redis_address)
  if (!_internal_has_redis_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = redis_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redis_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redis_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CacheConfig::set_allocated_redis_address(std::string* redis_address) {
  if (redis_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  redis_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), redis_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redis_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redis_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.CacheConfig.redis_address)
}

// optional string redis_password = 3 [json_name = "redisPassword"];
inline bool CacheConfig::_internal_has_redis_password() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CacheConfig::has_redis_password() const {
  return _internal_has_redis_password();
}
inline void CacheConfig::clear_redis_password() {
  redis_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CacheConfig::redis_password() const {
  // @@protoc_insertion_point(field_get:common.v1.CacheConfig.redis_password)
  return _internal_redis_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheConfig::set_redis_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 redis_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.CacheConfig.redis_password)
}
inline std::string* CacheConfig::mutable_redis_password() {
  std::string* _s = _internal_mutable_redis_password();
  // @@protoc_insertion_point(field_mutable:common.v1.CacheConfig.redis_password)
  return _s;
}
inline const std::string& CacheConfig::_internal_redis_password() const {
  return redis_password_.Get();
}
inline void CacheConfig::_internal_set_redis_password(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  redis_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheConfig::_internal_mutable_redis_password() {
  _has_bits_[0] |= 0x00000004u;
  return redis_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheConfig::release_redis_password() {
  // @@protoc_insertion_point(field_release:common.v1.CacheConfig.redis_password)
  if (!_internal_has_redis_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = redis_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redis_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redis_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CacheConfig::set_allocated_redis_password(std::string* redis_password) {
  if (redis_password != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  redis_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), redis_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redis_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redis_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.CacheConfig.redis_password)
}

// optional int32 redis_db = 4 [json_name = "redisDb"];
inline bool CacheConfig::_internal_has_redis_db() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CacheConfig::has_redis_db() const {
  return _internal_has_redis_db();
}
inline void CacheConfig::clear_redis_db() {
  redis_db_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CacheConfig::_internal_redis_db() const {
  return redis_db_;
}
inline int32_t CacheConfig::redis_db() const {
  // @@protoc_insertion_point(field_get:common.v1.CacheConfig.redis_db)
  return _internal_redis_db();
}
inline void CacheConfig::_internal_set_redis_db(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  redis_db_ = value;
}
inline void CacheConfig::set_redis_db(int32_t value) {
  _internal_set_redis_db(value);
  // @@protoc_insertion_point(field_set:common.v1.CacheConfig.redis_db)
}

// optional string redis_cache_prefix = 5 [json_name = "redisCachePrefix"];
inline bool CacheConfig::_internal_has_redis_cache_prefix() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CacheConfig::has_redis_cache_prefix() const {
  return _internal_has_redis_cache_prefix();
}
inline void CacheConfig::clear_redis_cache_prefix() {
  redis_cache_prefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CacheConfig::redis_cache_prefix() const {
  // @@protoc_insertion_point(field_get:common.v1.CacheConfig.redis_cache_prefix)
  return _internal_redis_cache_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CacheConfig::set_redis_cache_prefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 redis_cache_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.CacheConfig.redis_cache_prefix)
}
inline std::string* CacheConfig::mutable_redis_cache_prefix() {
  std::string* _s = _internal_mutable_redis_cache_prefix();
  // @@protoc_insertion_point(field_mutable:common.v1.CacheConfig.redis_cache_prefix)
  return _s;
}
inline const std::string& CacheConfig::_internal_redis_cache_prefix() const {
  return redis_cache_prefix_.Get();
}
inline void CacheConfig::_internal_set_redis_cache_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  redis_cache_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CacheConfig::_internal_mutable_redis_cache_prefix() {
  _has_bits_[0] |= 0x00000008u;
  return redis_cache_prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CacheConfig::release_redis_cache_prefix() {
  // @@protoc_insertion_point(field_release:common.v1.CacheConfig.redis_cache_prefix)
  if (!_internal_has_redis_cache_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = redis_cache_prefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redis_cache_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redis_cache_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CacheConfig::set_allocated_redis_cache_prefix(std::string* redis_cache_prefix) {
  if (redis_cache_prefix != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  redis_cache_prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), redis_cache_prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redis_cache_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    redis_cache_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.CacheConfig.redis_cache_prefix)
}

// optional bool disable_client_cache = 6 [json_name = "disableClientCache"];
inline bool CacheConfig::_internal_has_disable_client_cache() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CacheConfig::has_disable_client_cache() const {
  return _internal_has_disable_client_cache();
}
inline void CacheConfig::clear_disable_client_cache() {
  disable_client_cache_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CacheConfig::_internal_disable_client_cache() const {
  return disable_client_cache_;
}
inline bool CacheConfig::disable_client_cache() const {
  // @@protoc_insertion_point(field_get:common.v1.CacheConfig.disable_client_cache)
  return _internal_disable_client_cache();
}
inline void CacheConfig::_internal_set_disable_client_cache(bool value) {
  _has_bits_[0] |= 0x00000020u;
  disable_client_cache_ = value;
}
inline void CacheConfig::set_disable_client_cache(bool value) {
  _internal_set_disable_client_cache(value);
  // @@protoc_insertion_point(field_set:common.v1.CacheConfig.disable_client_cache)
}

// -------------------------------------------------------------------

// ConfigMetrics

// optional bool enable = 1 [json_name = "enable"];
inline bool ConfigMetrics::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigMetrics::has_enable() const {
  return _internal_has_enable();
}
inline void ConfigMetrics::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConfigMetrics::_internal_enable() const {
  return enable_;
}
inline bool ConfigMetrics::enable() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMetrics.enable)
  return _internal_enable();
}
inline void ConfigMetrics::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_ = value;
}
inline void ConfigMetrics::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.enable)
}

// optional int32 block_profile_rate = 2 [json_name = "blockProfileRate"];
inline bool ConfigMetrics::_internal_has_block_profile_rate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigMetrics::has_block_profile_rate() const {
  return _internal_has_block_profile_rate();
}
inline void ConfigMetrics::clear_block_profile_rate() {
  block_profile_rate_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ConfigMetrics::_internal_block_profile_rate() const {
  return block_profile_rate_;
}
inline int32_t ConfigMetrics::block_profile_rate() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMetrics.block_profile_rate)
  return _internal_block_profile_rate();
}
inline void ConfigMetrics::_internal_set_block_profile_rate(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  block_profile_rate_ = value;
}
inline void ConfigMetrics::set_block_profile_rate(int32_t value) {
  _internal_set_block_profile_rate(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.block_profile_rate)
}

// optional string listen_address = 3 [json_name = "listenAddress"];
inline bool ConfigMetrics::_internal_has_listen_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigMetrics::has_listen_address() const {
  return _internal_has_listen_address();
}
inline void ConfigMetrics::clear_listen_address() {
  listen_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigMetrics::listen_address() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMetrics.listen_address)
  return _internal_listen_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigMetrics::set_listen_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 listen_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.listen_address)
}
inline std::string* ConfigMetrics::mutable_listen_address() {
  std::string* _s = _internal_mutable_listen_address();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMetrics.listen_address)
  return _s;
}
inline const std::string& ConfigMetrics::_internal_listen_address() const {
  return listen_address_.Get();
}
inline void ConfigMetrics::_internal_set_listen_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  listen_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigMetrics::_internal_mutable_listen_address() {
  _has_bits_[0] |= 0x00000001u;
  return listen_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigMetrics::release_listen_address() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigMetrics.listen_address)
  if (!_internal_has_listen_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = listen_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (listen_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    listen_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigMetrics::set_allocated_listen_address(std::string* listen_address) {
  if (listen_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  listen_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), listen_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (listen_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    listen_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigMetrics.listen_address)
}

// optional bool enable_client_metrics = 4 [json_name = "enableClientMetrics"];
inline bool ConfigMetrics::_internal_has_enable_client_metrics() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigMetrics::has_enable_client_metrics() const {
  return _internal_has_enable_client_metrics();
}
inline void ConfigMetrics::clear_enable_client_metrics() {
  enable_client_metrics_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigMetrics::_internal_enable_client_metrics() const {
  return enable_client_metrics_;
}
inline bool ConfigMetrics::enable_client_metrics() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMetrics.enable_client_metrics)
  return _internal_enable_client_metrics();
}
inline void ConfigMetrics::_internal_set_enable_client_metrics(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_client_metrics_ = value;
}
inline void ConfigMetrics::set_enable_client_metrics(bool value) {
  _internal_set_enable_client_metrics(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.enable_client_metrics)
}

// optional bool enable_notification_metrics = 5 [json_name = "enableNotificationMetrics"];
inline bool ConfigMetrics::_internal_has_enable_notification_metrics() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigMetrics::has_enable_notification_metrics() const {
  return _internal_has_enable_notification_metrics();
}
inline void ConfigMetrics::clear_enable_notification_metrics() {
  enable_notification_metrics_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigMetrics::_internal_enable_notification_metrics() const {
  return enable_notification_metrics_;
}
inline bool ConfigMetrics::enable_notification_metrics() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMetrics.enable_notification_metrics)
  return _internal_enable_notification_metrics();
}
inline void ConfigMetrics::_internal_set_enable_notification_metrics(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_notification_metrics_ = value;
}
inline void ConfigMetrics::set_enable_notification_metrics(bool value) {
  _internal_set_enable_notification_metrics(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.enable_notification_metrics)
}

// repeated string client_side_user_ids = 6 [json_name = "clientSideUserIds"];
inline int ConfigMetrics::_internal_client_side_user_ids_size() const {
  return client_side_user_ids_.size();
}
inline int ConfigMetrics::client_side_user_ids_size() const {
  return _internal_client_side_user_ids_size();
}
inline void ConfigMetrics::clear_client_side_user_ids() {
  client_side_user_ids_.Clear();
}
inline std::string* ConfigMetrics::add_client_side_user_ids() {
  std::string* _s = _internal_add_client_side_user_ids();
  // @@protoc_insertion_point(field_add_mutable:common.v1.ConfigMetrics.client_side_user_ids)
  return _s;
}
inline const std::string& ConfigMetrics::_internal_client_side_user_ids(int index) const {
  return client_side_user_ids_.Get(index);
}
inline const std::string& ConfigMetrics::client_side_user_ids(int index) const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMetrics.client_side_user_ids)
  return _internal_client_side_user_ids(index);
}
inline std::string* ConfigMetrics::mutable_client_side_user_ids(int index) {
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMetrics.client_side_user_ids)
  return client_side_user_ids_.Mutable(index);
}
inline void ConfigMetrics::set_client_side_user_ids(int index, const std::string& value) {
  client_side_user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.client_side_user_ids)
}
inline void ConfigMetrics::set_client_side_user_ids(int index, std::string&& value) {
  client_side_user_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:common.v1.ConfigMetrics.client_side_user_ids)
}
inline void ConfigMetrics::set_client_side_user_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_side_user_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.v1.ConfigMetrics.client_side_user_ids)
}
inline void ConfigMetrics::set_client_side_user_ids(int index, const char* value, size_t size) {
  client_side_user_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.v1.ConfigMetrics.client_side_user_ids)
}
inline std::string* ConfigMetrics::_internal_add_client_side_user_ids() {
  return client_side_user_ids_.Add();
}
inline void ConfigMetrics::add_client_side_user_ids(const std::string& value) {
  client_side_user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.v1.ConfigMetrics.client_side_user_ids)
}
inline void ConfigMetrics::add_client_side_user_ids(std::string&& value) {
  client_side_user_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.v1.ConfigMetrics.client_side_user_ids)
}
inline void ConfigMetrics::add_client_side_user_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  client_side_user_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.v1.ConfigMetrics.client_side_user_ids)
}
inline void ConfigMetrics::add_client_side_user_ids(const char* value, size_t size) {
  client_side_user_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.v1.ConfigMetrics.client_side_user_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigMetrics::client_side_user_ids() const {
  // @@protoc_insertion_point(field_list:common.v1.ConfigMetrics.client_side_user_ids)
  return client_side_user_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigMetrics::mutable_client_side_user_ids() {
  // @@protoc_insertion_point(field_mutable_list:common.v1.ConfigMetrics.client_side_user_ids)
  return &client_side_user_ids_;
}

// -------------------------------------------------------------------

// ConfigSSO

// optional bool enable = 1 [json_name = "enable"];
inline bool ConfigSSO::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigSSO::has_enable() const {
  return _internal_has_enable();
}
inline void ConfigSSO::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ConfigSSO::_internal_enable() const {
  return enable_;
}
inline bool ConfigSSO::enable() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.enable)
  return _internal_enable();
}
inline void ConfigSSO::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000200u;
  enable_ = value;
}
inline void ConfigSSO::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.enable)
}

// optional string secret = 2 [json_name = "secret"];
inline bool ConfigSSO::_internal_has_secret() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigSSO::has_secret() const {
  return _internal_has_secret();
}
inline void ConfigSSO::clear_secret() {
  secret_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigSSO::secret() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.secret)
  return _internal_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_secret(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.secret)
}
inline std::string* ConfigSSO::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.secret)
  return _s;
}
inline const std::string& ConfigSSO::_internal_secret() const {
  return secret_.Get();
}
inline void ConfigSSO::_internal_set_secret(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_secret() {
  _has_bits_[0] |= 0x00000001u;
  return secret_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_secret() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.secret)
  if (!_internal_has_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = secret_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_secret(std::string* secret) {
  if (secret != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), secret,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.secret)
}

// optional string id = 3 [json_name = "id"];
inline bool ConfigSSO::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigSSO::has_id() const {
  return _internal_has_id();
}
inline void ConfigSSO::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigSSO::id() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.id)
}
inline std::string* ConfigSSO::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.id)
  return _s;
}
inline const std::string& ConfigSSO::_internal_id() const {
  return id_.Get();
}
inline void ConfigSSO::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000002u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_id() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.id)
}

// optional string scope = 4 [json_name = "scope"];
inline bool ConfigSSO::_internal_has_scope() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigSSO::has_scope() const {
  return _internal_has_scope();
}
inline void ConfigSSO::clear_scope() {
  scope_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigSSO::scope() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.scope)
  return _internal_scope();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_scope(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 scope_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.scope)
}
inline std::string* ConfigSSO::mutable_scope() {
  std::string* _s = _internal_mutable_scope();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.scope)
  return _s;
}
inline const std::string& ConfigSSO::_internal_scope() const {
  return scope_.Get();
}
inline void ConfigSSO::_internal_set_scope(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  scope_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_scope() {
  _has_bits_[0] |= 0x00000004u;
  return scope_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_scope() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.scope)
  if (!_internal_has_scope()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = scope_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scope_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scope_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_scope(std::string* scope) {
  if (scope != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  scope_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scope,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scope_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scope_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.scope)
}

// optional string auth_endpoint = 5 [json_name = "authEndpoint"];
inline bool ConfigSSO::_internal_has_auth_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigSSO::has_auth_endpoint() const {
  return _internal_has_auth_endpoint();
}
inline void ConfigSSO::clear_auth_endpoint() {
  auth_endpoint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigSSO::auth_endpoint() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.auth_endpoint)
  return _internal_auth_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_auth_endpoint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 auth_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.auth_endpoint)
}
inline std::string* ConfigSSO::mutable_auth_endpoint() {
  std::string* _s = _internal_mutable_auth_endpoint();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.auth_endpoint)
  return _s;
}
inline const std::string& ConfigSSO::_internal_auth_endpoint() const {
  return auth_endpoint_.Get();
}
inline void ConfigSSO::_internal_set_auth_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  auth_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_auth_endpoint() {
  _has_bits_[0] |= 0x00000008u;
  return auth_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_auth_endpoint() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.auth_endpoint)
  if (!_internal_has_auth_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = auth_endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_auth_endpoint(std::string* auth_endpoint) {
  if (auth_endpoint != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  auth_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.auth_endpoint)
}

// optional string token_endpoint = 6 [json_name = "tokenEndpoint"];
inline bool ConfigSSO::_internal_has_token_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigSSO::has_token_endpoint() const {
  return _internal_has_token_endpoint();
}
inline void ConfigSSO::clear_token_endpoint() {
  token_endpoint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigSSO::token_endpoint() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.token_endpoint)
  return _internal_token_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_token_endpoint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 token_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.token_endpoint)
}
inline std::string* ConfigSSO::mutable_token_endpoint() {
  std::string* _s = _internal_mutable_token_endpoint();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.token_endpoint)
  return _s;
}
inline const std::string& ConfigSSO::_internal_token_endpoint() const {
  return token_endpoint_.Get();
}
inline void ConfigSSO::_internal_set_token_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  token_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_token_endpoint() {
  _has_bits_[0] |= 0x00000010u;
  return token_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_token_endpoint() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.token_endpoint)
  if (!_internal_has_token_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = token_endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_token_endpoint(std::string* token_endpoint) {
  if (token_endpoint != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  token_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.token_endpoint)
}

// optional string user_api_endpoint = 7 [json_name = "userApiEndpoint"];
inline bool ConfigSSO::_internal_has_user_api_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigSSO::has_user_api_endpoint() const {
  return _internal_has_user_api_endpoint();
}
inline void ConfigSSO::clear_user_api_endpoint() {
  user_api_endpoint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConfigSSO::user_api_endpoint() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.user_api_endpoint)
  return _internal_user_api_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_user_api_endpoint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 user_api_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.user_api_endpoint)
}
inline std::string* ConfigSSO::mutable_user_api_endpoint() {
  std::string* _s = _internal_mutable_user_api_endpoint();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.user_api_endpoint)
  return _s;
}
inline const std::string& ConfigSSO::_internal_user_api_endpoint() const {
  return user_api_endpoint_.Get();
}
inline void ConfigSSO::_internal_set_user_api_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  user_api_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_user_api_endpoint() {
  _has_bits_[0] |= 0x00000020u;
  return user_api_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_user_api_endpoint() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.user_api_endpoint)
  if (!_internal_has_user_api_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = user_api_endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_api_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_api_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_user_api_endpoint(std::string* user_api_endpoint) {
  if (user_api_endpoint != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  user_api_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_api_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_api_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_api_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.user_api_endpoint)
}

// optional string discovery_endpoint = 8 [json_name = "discoveryEndpoint"];
inline bool ConfigSSO::_internal_has_discovery_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigSSO::has_discovery_endpoint() const {
  return _internal_has_discovery_endpoint();
}
inline void ConfigSSO::clear_discovery_endpoint() {
  discovery_endpoint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConfigSSO::discovery_endpoint() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.discovery_endpoint)
  return _internal_discovery_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_discovery_endpoint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 discovery_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.discovery_endpoint)
}
inline std::string* ConfigSSO::mutable_discovery_endpoint() {
  std::string* _s = _internal_mutable_discovery_endpoint();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.discovery_endpoint)
  return _s;
}
inline const std::string& ConfigSSO::_internal_discovery_endpoint() const {
  return discovery_endpoint_.Get();
}
inline void ConfigSSO::_internal_set_discovery_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  discovery_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_discovery_endpoint() {
  _has_bits_[0] |= 0x00000040u;
  return discovery_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_discovery_endpoint() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.discovery_endpoint)
  if (!_internal_has_discovery_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = discovery_endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discovery_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discovery_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_discovery_endpoint(std::string* discovery_endpoint) {
  if (discovery_endpoint != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  discovery_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), discovery_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discovery_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discovery_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.discovery_endpoint)
}

// optional string button_text = 9 [json_name = "buttonText"];
inline bool ConfigSSO::_internal_has_button_text() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigSSO::has_button_text() const {
  return _internal_has_button_text();
}
inline void ConfigSSO::clear_button_text() {
  button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ConfigSSO::button_text() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.button_text)
  return _internal_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 button_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.button_text)
}
inline std::string* ConfigSSO::mutable_button_text() {
  std::string* _s = _internal_mutable_button_text();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.button_text)
  return _s;
}
inline const std::string& ConfigSSO::_internal_button_text() const {
  return button_text_.Get();
}
inline void ConfigSSO::_internal_set_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  button_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_button_text() {
  _has_bits_[0] |= 0x00000080u;
  return button_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_button_text() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.button_text)
  if (!_internal_has_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = button_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (button_text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    button_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_button_text(std::string* button_text) {
  if (button_text != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  button_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), button_text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (button_text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    button_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.button_text)
}

// optional string button_color = 10 [json_name = "buttonColor"];
inline bool ConfigSSO::_internal_has_button_color() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigSSO::has_button_color() const {
  return _internal_has_button_color();
}
inline void ConfigSSO::clear_button_color() {
  button_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ConfigSSO::button_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSSO.button_color)
  return _internal_button_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSSO::set_button_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSSO.button_color)
}
inline std::string* ConfigSSO::mutable_button_color() {
  std::string* _s = _internal_mutable_button_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSSO.button_color)
  return _s;
}
inline const std::string& ConfigSSO::_internal_button_color() const {
  return button_color_.Get();
}
inline void ConfigSSO::_internal_set_button_color(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSSO::_internal_mutable_button_color() {
  _has_bits_[0] |= 0x00000100u;
  return button_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSSO::release_button_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSSO.button_color)
  if (!_internal_has_button_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = button_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSSO::set_allocated_button_color(std::string* button_color) {
  if (button_color != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  button_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), button_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSSO.button_color)
}

// -------------------------------------------------------------------

// ConfigSql

// optional string driver_name = 1 [json_name = "driverName"];
inline bool ConfigSql::_internal_has_driver_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigSql::has_driver_name() const {
  return _internal_has_driver_name();
}
inline void ConfigSql::clear_driver_name() {
  driver_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigSql::driver_name() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.driver_name)
  return _internal_driver_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSql::set_driver_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 driver_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.driver_name)
}
inline std::string* ConfigSql::mutable_driver_name() {
  std::string* _s = _internal_mutable_driver_name();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSql.driver_name)
  return _s;
}
inline const std::string& ConfigSql::_internal_driver_name() const {
  return driver_name_.Get();
}
inline void ConfigSql::_internal_set_driver_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  driver_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSql::_internal_mutable_driver_name() {
  _has_bits_[0] |= 0x00000001u;
  return driver_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSql::release_driver_name() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSql.driver_name)
  if (!_internal_has_driver_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = driver_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    driver_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSql::set_allocated_driver_name(std::string* driver_name) {
  if (driver_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  driver_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    driver_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSql.driver_name)
}

// optional string data_source = 2 [json_name = "dataSource"];
inline bool ConfigSql::_internal_has_data_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigSql::has_data_source() const {
  return _internal_has_data_source();
}
inline void ConfigSql::clear_data_source() {
  data_source_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigSql::data_source() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.data_source)
  return _internal_data_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSql::set_data_source(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.data_source)
}
inline std::string* ConfigSql::mutable_data_source() {
  std::string* _s = _internal_mutable_data_source();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSql.data_source)
  return _s;
}
inline const std::string& ConfigSql::_internal_data_source() const {
  return data_source_.Get();
}
inline void ConfigSql::_internal_set_data_source(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSql::_internal_mutable_data_source() {
  _has_bits_[0] |= 0x00000002u;
  return data_source_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSql::release_data_source() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSql.data_source)
  if (!_internal_has_data_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_source_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSql::set_allocated_data_source(std::string* data_source) {
  if (data_source != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_source_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_source,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_source_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSql.data_source)
}

// optional int32 max_idle_conns = 3 [json_name = "maxIdleConns"];
inline bool ConfigSql::_internal_has_max_idle_conns() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigSql::has_max_idle_conns() const {
  return _internal_has_max_idle_conns();
}
inline void ConfigSql::clear_max_idle_conns() {
  max_idle_conns_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t ConfigSql::_internal_max_idle_conns() const {
  return max_idle_conns_;
}
inline int32_t ConfigSql::max_idle_conns() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.max_idle_conns)
  return _internal_max_idle_conns();
}
inline void ConfigSql::_internal_set_max_idle_conns(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  max_idle_conns_ = value;
}
inline void ConfigSql::set_max_idle_conns(int32_t value) {
  _internal_set_max_idle_conns(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.max_idle_conns)
}

// optional int32 conn_max_lifetime_milliseconds = 4 [json_name = "connMaxLifetimeMilliseconds"];
inline bool ConfigSql::_internal_has_conn_max_lifetime_milliseconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigSql::has_conn_max_lifetime_milliseconds() const {
  return _internal_has_conn_max_lifetime_milliseconds();
}
inline void ConfigSql::clear_conn_max_lifetime_milliseconds() {
  conn_max_lifetime_milliseconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ConfigSql::_internal_conn_max_lifetime_milliseconds() const {
  return conn_max_lifetime_milliseconds_;
}
inline int32_t ConfigSql::conn_max_lifetime_milliseconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.conn_max_lifetime_milliseconds)
  return _internal_conn_max_lifetime_milliseconds();
}
inline void ConfigSql::_internal_set_conn_max_lifetime_milliseconds(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  conn_max_lifetime_milliseconds_ = value;
}
inline void ConfigSql::set_conn_max_lifetime_milliseconds(int32_t value) {
  _internal_set_conn_max_lifetime_milliseconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.conn_max_lifetime_milliseconds)
}

// optional int32 conn_max_idle_time_milliseconds = 5 [json_name = "connMaxIdleTimeMilliseconds"];
inline bool ConfigSql::_internal_has_conn_max_idle_time_milliseconds() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigSql::has_conn_max_idle_time_milliseconds() const {
  return _internal_has_conn_max_idle_time_milliseconds();
}
inline void ConfigSql::clear_conn_max_idle_time_milliseconds() {
  conn_max_idle_time_milliseconds_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ConfigSql::_internal_conn_max_idle_time_milliseconds() const {
  return conn_max_idle_time_milliseconds_;
}
inline int32_t ConfigSql::conn_max_idle_time_milliseconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.conn_max_idle_time_milliseconds)
  return _internal_conn_max_idle_time_milliseconds();
}
inline void ConfigSql::_internal_set_conn_max_idle_time_milliseconds(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  conn_max_idle_time_milliseconds_ = value;
}
inline void ConfigSql::set_conn_max_idle_time_milliseconds(int32_t value) {
  _internal_set_conn_max_idle_time_milliseconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.conn_max_idle_time_milliseconds)
}

// optional int32 max_open_conns = 6 [json_name = "maxOpenConns"];
inline bool ConfigSql::_internal_has_max_open_conns() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigSql::has_max_open_conns() const {
  return _internal_has_max_open_conns();
}
inline void ConfigSql::clear_max_open_conns() {
  max_open_conns_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ConfigSql::_internal_max_open_conns() const {
  return max_open_conns_;
}
inline int32_t ConfigSql::max_open_conns() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.max_open_conns)
  return _internal_max_open_conns();
}
inline void ConfigSql::_internal_set_max_open_conns(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  max_open_conns_ = value;
}
inline void ConfigSql::set_max_open_conns(int32_t value) {
  _internal_set_max_open_conns(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.max_open_conns)
}

// optional bool trace = 7 [json_name = "trace"];
inline bool ConfigSql::_internal_has_trace() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigSql::has_trace() const {
  return _internal_has_trace();
}
inline void ConfigSql::clear_trace() {
  trace_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ConfigSql::_internal_trace() const {
  return trace_;
}
inline bool ConfigSql::trace() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.trace)
  return _internal_trace();
}
inline void ConfigSql::_internal_set_trace(bool value) {
  _has_bits_[0] |= 0x00000080u;
  trace_ = value;
}
inline void ConfigSql::set_trace(bool value) {
  _internal_set_trace(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.trace)
}

// optional string at_rest_encrypt_key = 8 [json_name = "atRestEncryptKey"];
inline bool ConfigSql::_internal_has_at_rest_encrypt_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigSql::has_at_rest_encrypt_key() const {
  return _internal_has_at_rest_encrypt_key();
}
inline void ConfigSql::clear_at_rest_encrypt_key() {
  at_rest_encrypt_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigSql::at_rest_encrypt_key() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.at_rest_encrypt_key)
  return _internal_at_rest_encrypt_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSql::set_at_rest_encrypt_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 at_rest_encrypt_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.at_rest_encrypt_key)
}
inline std::string* ConfigSql::mutable_at_rest_encrypt_key() {
  std::string* _s = _internal_mutable_at_rest_encrypt_key();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSql.at_rest_encrypt_key)
  return _s;
}
inline const std::string& ConfigSql::_internal_at_rest_encrypt_key() const {
  return at_rest_encrypt_key_.Get();
}
inline void ConfigSql::_internal_set_at_rest_encrypt_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  at_rest_encrypt_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSql::_internal_mutable_at_rest_encrypt_key() {
  _has_bits_[0] |= 0x00000004u;
  return at_rest_encrypt_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSql::release_at_rest_encrypt_key() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSql.at_rest_encrypt_key)
  if (!_internal_has_at_rest_encrypt_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = at_rest_encrypt_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (at_rest_encrypt_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    at_rest_encrypt_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSql::set_allocated_at_rest_encrypt_key(std::string* at_rest_encrypt_key) {
  if (at_rest_encrypt_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  at_rest_encrypt_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), at_rest_encrypt_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (at_rest_encrypt_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    at_rest_encrypt_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSql.at_rest_encrypt_key)
}

// optional int32 query_timeout = 9 [json_name = "queryTimeout"];
inline bool ConfigSql::_internal_has_query_timeout() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigSql::has_query_timeout() const {
  return _internal_has_query_timeout();
}
inline void ConfigSql::clear_query_timeout() {
  query_timeout_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ConfigSql::_internal_query_timeout() const {
  return query_timeout_;
}
inline int32_t ConfigSql::query_timeout() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.query_timeout)
  return _internal_query_timeout();
}
inline void ConfigSql::_internal_set_query_timeout(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  query_timeout_ = value;
}
inline void ConfigSql::set_query_timeout(int32_t value) {
  _internal_set_query_timeout(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.query_timeout)
}

// optional bool disable_database_search = 10 [json_name = "disableDatabaseSearch"];
inline bool ConfigSql::_internal_has_disable_database_search() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigSql::has_disable_database_search() const {
  return _internal_has_disable_database_search();
}
inline void ConfigSql::clear_disable_database_search() {
  disable_database_search_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ConfigSql::_internal_disable_database_search() const {
  return disable_database_search_;
}
inline bool ConfigSql::disable_database_search() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSql.disable_database_search)
  return _internal_disable_database_search();
}
inline void ConfigSql::_internal_set_disable_database_search(bool value) {
  _has_bits_[0] |= 0x00000100u;
  disable_database_search_ = value;
}
inline void ConfigSql::set_disable_database_search(bool value) {
  _internal_set_disable_database_search(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSql.disable_database_search)
}

// -------------------------------------------------------------------

// ConfigPassword

// optional int32 minimum_length = 1 [json_name = "minimumLength"];
inline bool ConfigPassword::_internal_has_minimum_length() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigPassword::has_minimum_length() const {
  return _internal_has_minimum_length();
}
inline void ConfigPassword::clear_minimum_length() {
  minimum_length_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ConfigPassword::_internal_minimum_length() const {
  return minimum_length_;
}
inline int32_t ConfigPassword::minimum_length() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.minimum_length)
  return _internal_minimum_length();
}
inline void ConfigPassword::_internal_set_minimum_length(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  minimum_length_ = value;
}
inline void ConfigPassword::set_minimum_length(int32_t value) {
  _internal_set_minimum_length(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.minimum_length)
}

// optional int32 maximum_lenght = 2 [json_name = "maximumLenght"];
inline bool ConfigPassword::_internal_has_maximum_lenght() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigPassword::has_maximum_lenght() const {
  return _internal_has_maximum_lenght();
}
inline void ConfigPassword::clear_maximum_lenght() {
  maximum_lenght_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ConfigPassword::_internal_maximum_lenght() const {
  return maximum_lenght_;
}
inline int32_t ConfigPassword::maximum_lenght() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.maximum_lenght)
  return _internal_maximum_lenght();
}
inline void ConfigPassword::_internal_set_maximum_lenght(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_lenght_ = value;
}
inline void ConfigPassword::set_maximum_lenght(int32_t value) {
  _internal_set_maximum_lenght(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.maximum_lenght)
}

// optional bool lowercase = 3 [json_name = "lowercase"];
inline bool ConfigPassword::_internal_has_lowercase() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigPassword::has_lowercase() const {
  return _internal_has_lowercase();
}
inline void ConfigPassword::clear_lowercase() {
  lowercase_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConfigPassword::_internal_lowercase() const {
  return lowercase_;
}
inline bool ConfigPassword::lowercase() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.lowercase)
  return _internal_lowercase();
}
inline void ConfigPassword::_internal_set_lowercase(bool value) {
  _has_bits_[0] |= 0x00000004u;
  lowercase_ = value;
}
inline void ConfigPassword::set_lowercase(bool value) {
  _internal_set_lowercase(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.lowercase)
}

// optional bool number = 4 [json_name = "number"];
inline bool ConfigPassword::_internal_has_number() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigPassword::has_number() const {
  return _internal_has_number();
}
inline void ConfigPassword::clear_number() {
  number_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigPassword::_internal_number() const {
  return number_;
}
inline bool ConfigPassword::number() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.number)
  return _internal_number();
}
inline void ConfigPassword::_internal_set_number(bool value) {
  _has_bits_[0] |= 0x00000008u;
  number_ = value;
}
inline void ConfigPassword::set_number(bool value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.number)
}

// optional bool uppercase = 5 [json_name = "uppercase"];
inline bool ConfigPassword::_internal_has_uppercase() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigPassword::has_uppercase() const {
  return _internal_has_uppercase();
}
inline void ConfigPassword::clear_uppercase() {
  uppercase_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigPassword::_internal_uppercase() const {
  return uppercase_;
}
inline bool ConfigPassword::uppercase() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.uppercase)
  return _internal_uppercase();
}
inline void ConfigPassword::_internal_set_uppercase(bool value) {
  _has_bits_[0] |= 0x00000010u;
  uppercase_ = value;
}
inline void ConfigPassword::set_uppercase(bool value) {
  _internal_set_uppercase(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.uppercase)
}

// optional bool symbol = 6 [json_name = "symbol"];
inline bool ConfigPassword::_internal_has_symbol() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigPassword::has_symbol() const {
  return _internal_has_symbol();
}
inline void ConfigPassword::clear_symbol() {
  symbol_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigPassword::_internal_symbol() const {
  return symbol_;
}
inline bool ConfigPassword::symbol() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.symbol)
  return _internal_symbol();
}
inline void ConfigPassword::_internal_set_symbol(bool value) {
  _has_bits_[0] |= 0x00000020u;
  symbol_ = value;
}
inline void ConfigPassword::set_symbol(bool value) {
  _internal_set_symbol(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.symbol)
}

// optional bool enable_forgot_link = 7 [json_name = "enableForgotLink"];
inline bool ConfigPassword::_internal_has_enable_forgot_link() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigPassword::has_enable_forgot_link() const {
  return _internal_has_enable_forgot_link();
}
inline void ConfigPassword::clear_enable_forgot_link() {
  enable_forgot_link_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigPassword::_internal_enable_forgot_link() const {
  return enable_forgot_link_;
}
inline bool ConfigPassword::enable_forgot_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPassword.enable_forgot_link)
  return _internal_enable_forgot_link();
}
inline void ConfigPassword::_internal_set_enable_forgot_link(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enable_forgot_link_ = value;
}
inline void ConfigPassword::set_enable_forgot_link(bool value) {
  _internal_set_enable_forgot_link(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPassword.enable_forgot_link)
}

// -------------------------------------------------------------------

// ConfigFile

// optional bool enable_file_attachments = 1 [json_name = "enableFileAttachments"];
inline bool ConfigFile::_internal_has_enable_file_attachments() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ConfigFile::has_enable_file_attachments() const {
  return _internal_has_enable_file_attachments();
}
inline void ConfigFile::clear_enable_file_attachments() {
  enable_file_attachments_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ConfigFile::_internal_enable_file_attachments() const {
  return enable_file_attachments_;
}
inline bool ConfigFile::enable_file_attachments() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.enable_file_attachments)
  return _internal_enable_file_attachments();
}
inline void ConfigFile::_internal_set_enable_file_attachments(bool value) {
  _has_bits_[0] |= 0x00004000u;
  enable_file_attachments_ = value;
}
inline void ConfigFile::set_enable_file_attachments(bool value) {
  _internal_set_enable_file_attachments(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.enable_file_attachments)
}

// optional bool enable_mobile_upload = 2 [json_name = "enableMobileUpload"];
inline bool ConfigFile::_internal_has_enable_mobile_upload() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ConfigFile::has_enable_mobile_upload() const {
  return _internal_has_enable_mobile_upload();
}
inline void ConfigFile::clear_enable_mobile_upload() {
  enable_mobile_upload_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool ConfigFile::_internal_enable_mobile_upload() const {
  return enable_mobile_upload_;
}
inline bool ConfigFile::enable_mobile_upload() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.enable_mobile_upload)
  return _internal_enable_mobile_upload();
}
inline void ConfigFile::_internal_set_enable_mobile_upload(bool value) {
  _has_bits_[0] |= 0x00008000u;
  enable_mobile_upload_ = value;
}
inline void ConfigFile::set_enable_mobile_upload(bool value) {
  _internal_set_enable_mobile_upload(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.enable_mobile_upload)
}

// optional bool enable_mobile_download = 3 [json_name = "enableMobileDownload"];
inline bool ConfigFile::_internal_has_enable_mobile_download() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ConfigFile::has_enable_mobile_download() const {
  return _internal_has_enable_mobile_download();
}
inline void ConfigFile::clear_enable_mobile_download() {
  enable_mobile_download_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool ConfigFile::_internal_enable_mobile_download() const {
  return enable_mobile_download_;
}
inline bool ConfigFile::enable_mobile_download() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.enable_mobile_download)
  return _internal_enable_mobile_download();
}
inline void ConfigFile::_internal_set_enable_mobile_download(bool value) {
  _has_bits_[0] |= 0x00010000u;
  enable_mobile_download_ = value;
}
inline void ConfigFile::set_enable_mobile_download(bool value) {
  _internal_set_enable_mobile_download(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.enable_mobile_download)
}

// optional int64 max_file_size = 4 [json_name = "maxFileSize"];
inline bool ConfigFile::_internal_has_max_file_size() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ConfigFile::has_max_file_size() const {
  return _internal_has_max_file_size();
}
inline void ConfigFile::clear_max_file_size() {
  max_file_size_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline int64_t ConfigFile::_internal_max_file_size() const {
  return max_file_size_;
}
inline int64_t ConfigFile::max_file_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.max_file_size)
  return _internal_max_file_size();
}
inline void ConfigFile::_internal_set_max_file_size(int64_t value) {
  _has_bits_[0] |= 0x00000800u;
  max_file_size_ = value;
}
inline void ConfigFile::set_max_file_size(int64_t value) {
  _internal_set_max_file_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.max_file_size)
}

// optional int64 max_image_resolution = 5 [json_name = "maxImageResolution"];
inline bool ConfigFile::_internal_has_max_image_resolution() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ConfigFile::has_max_image_resolution() const {
  return _internal_has_max_image_resolution();
}
inline void ConfigFile::clear_max_image_resolution() {
  max_image_resolution_ = int64_t{0};
  _has_bits_[0] &= ~0x00001000u;
}
inline int64_t ConfigFile::_internal_max_image_resolution() const {
  return max_image_resolution_;
}
inline int64_t ConfigFile::max_image_resolution() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.max_image_resolution)
  return _internal_max_image_resolution();
}
inline void ConfigFile::_internal_set_max_image_resolution(int64_t value) {
  _has_bits_[0] |= 0x00001000u;
  max_image_resolution_ = value;
}
inline void ConfigFile::set_max_image_resolution(int64_t value) {
  _internal_set_max_image_resolution(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.max_image_resolution)
}

// optional int64 max_image_decoder_concurrency = 6 [json_name = "maxImageDecoderConcurrency"];
inline bool ConfigFile::_internal_has_max_image_decoder_concurrency() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ConfigFile::has_max_image_decoder_concurrency() const {
  return _internal_has_max_image_decoder_concurrency();
}
inline void ConfigFile::clear_max_image_decoder_concurrency() {
  max_image_decoder_concurrency_ = int64_t{0};
  _has_bits_[0] &= ~0x00002000u;
}
inline int64_t ConfigFile::_internal_max_image_decoder_concurrency() const {
  return max_image_decoder_concurrency_;
}
inline int64_t ConfigFile::max_image_decoder_concurrency() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.max_image_decoder_concurrency)
  return _internal_max_image_decoder_concurrency();
}
inline void ConfigFile::_internal_set_max_image_decoder_concurrency(int64_t value) {
  _has_bits_[0] |= 0x00002000u;
  max_image_decoder_concurrency_ = value;
}
inline void ConfigFile::set_max_image_decoder_concurrency(int64_t value) {
  _internal_set_max_image_decoder_concurrency(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.max_image_decoder_concurrency)
}

// optional string driver_name = 7 [json_name = "driverName"];
inline bool ConfigFile::_internal_has_driver_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigFile::has_driver_name() const {
  return _internal_has_driver_name();
}
inline void ConfigFile::clear_driver_name() {
  driver_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigFile::driver_name() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.driver_name)
  return _internal_driver_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_driver_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 driver_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.driver_name)
}
inline std::string* ConfigFile::mutable_driver_name() {
  std::string* _s = _internal_mutable_driver_name();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.driver_name)
  return _s;
}
inline const std::string& ConfigFile::_internal_driver_name() const {
  return driver_name_.Get();
}
inline void ConfigFile::_internal_set_driver_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  driver_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_driver_name() {
  _has_bits_[0] |= 0x00000001u;
  return driver_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_driver_name() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.driver_name)
  if (!_internal_has_driver_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = driver_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    driver_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_driver_name(std::string* driver_name) {
  if (driver_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  driver_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), driver_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (driver_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    driver_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.driver_name)
}

// optional string directory = 8 [json_name = "directory"];
inline bool ConfigFile::_internal_has_directory() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigFile::has_directory() const {
  return _internal_has_directory();
}
inline void ConfigFile::clear_directory() {
  directory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigFile::directory() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.directory)
  return _internal_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_directory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.directory)
}
inline std::string* ConfigFile::mutable_directory() {
  std::string* _s = _internal_mutable_directory();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.directory)
  return _s;
}
inline const std::string& ConfigFile::_internal_directory() const {
  return directory_.Get();
}
inline void ConfigFile::_internal_set_directory(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_directory() {
  _has_bits_[0] |= 0x00000002u;
  return directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_directory() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.directory)
  if (!_internal_has_directory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = directory_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (directory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    directory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.directory)
}

// optional bool enable_public_link = 9 [json_name = "enablePublicLink"];
inline bool ConfigFile::_internal_has_enable_public_link() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ConfigFile::has_enable_public_link() const {
  return _internal_has_enable_public_link();
}
inline void ConfigFile::clear_enable_public_link() {
  enable_public_link_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool ConfigFile::_internal_enable_public_link() const {
  return enable_public_link_;
}
inline bool ConfigFile::enable_public_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.enable_public_link)
  return _internal_enable_public_link();
}
inline void ConfigFile::_internal_set_enable_public_link(bool value) {
  _has_bits_[0] |= 0x00020000u;
  enable_public_link_ = value;
}
inline void ConfigFile::set_enable_public_link(bool value) {
  _internal_set_enable_public_link(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.enable_public_link)
}

// optional bool extract_content = 10 [json_name = "extractContent"];
inline bool ConfigFile::_internal_has_extract_content() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ConfigFile::has_extract_content() const {
  return _internal_has_extract_content();
}
inline void ConfigFile::clear_extract_content() {
  extract_content_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool ConfigFile::_internal_extract_content() const {
  return extract_content_;
}
inline bool ConfigFile::extract_content() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.extract_content)
  return _internal_extract_content();
}
inline void ConfigFile::_internal_set_extract_content(bool value) {
  _has_bits_[0] |= 0x00040000u;
  extract_content_ = value;
}
inline void ConfigFile::set_extract_content(bool value) {
  _internal_set_extract_content(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.extract_content)
}

// optional bool archive_recursion = 11 [json_name = "archiveRecursion"];
inline bool ConfigFile::_internal_has_archive_recursion() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ConfigFile::has_archive_recursion() const {
  return _internal_has_archive_recursion();
}
inline void ConfigFile::clear_archive_recursion() {
  archive_recursion_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool ConfigFile::_internal_archive_recursion() const {
  return archive_recursion_;
}
inline bool ConfigFile::archive_recursion() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.archive_recursion)
  return _internal_archive_recursion();
}
inline void ConfigFile::_internal_set_archive_recursion(bool value) {
  _has_bits_[0] |= 0x00080000u;
  archive_recursion_ = value;
}
inline void ConfigFile::set_archive_recursion(bool value) {
  _internal_set_archive_recursion(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.archive_recursion)
}

// optional string public_link_salt = 12 [json_name = "publicLinkSalt"];
inline bool ConfigFile::_internal_has_public_link_salt() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigFile::has_public_link_salt() const {
  return _internal_has_public_link_salt();
}
inline void ConfigFile::clear_public_link_salt() {
  public_link_salt_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigFile::public_link_salt() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.public_link_salt)
  return _internal_public_link_salt();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_public_link_salt(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 public_link_salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.public_link_salt)
}
inline std::string* ConfigFile::mutable_public_link_salt() {
  std::string* _s = _internal_mutable_public_link_salt();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.public_link_salt)
  return _s;
}
inline const std::string& ConfigFile::_internal_public_link_salt() const {
  return public_link_salt_.Get();
}
inline void ConfigFile::_internal_set_public_link_salt(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  public_link_salt_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_public_link_salt() {
  _has_bits_[0] |= 0x00000004u;
  return public_link_salt_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_public_link_salt() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.public_link_salt)
  if (!_internal_has_public_link_salt()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = public_link_salt_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_link_salt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_link_salt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_public_link_salt(std::string* public_link_salt) {
  if (public_link_salt != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  public_link_salt_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_link_salt,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_link_salt_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_link_salt_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.public_link_salt)
}

// optional string initial_font = 13 [json_name = "initialFont"];
inline bool ConfigFile::_internal_has_initial_font() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigFile::has_initial_font() const {
  return _internal_has_initial_font();
}
inline void ConfigFile::clear_initial_font() {
  initial_font_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigFile::initial_font() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.initial_font)
  return _internal_initial_font();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_initial_font(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 initial_font_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.initial_font)
}
inline std::string* ConfigFile::mutable_initial_font() {
  std::string* _s = _internal_mutable_initial_font();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.initial_font)
  return _s;
}
inline const std::string& ConfigFile::_internal_initial_font() const {
  return initial_font_.Get();
}
inline void ConfigFile::_internal_set_initial_font(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  initial_font_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_initial_font() {
  _has_bits_[0] |= 0x00000008u;
  return initial_font_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_initial_font() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.initial_font)
  if (!_internal_has_initial_font()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = initial_font_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (initial_font_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    initial_font_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_initial_font(std::string* initial_font) {
  if (initial_font != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  initial_font_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), initial_font,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (initial_font_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    initial_font_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.initial_font)
}

// optional string amazon_s3_access_key_id = 14 [json_name = "amazonS3AccessKeyId"];
inline bool ConfigFile::_internal_has_amazon_s3_access_key_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_access_key_id() const {
  return _internal_has_amazon_s3_access_key_id();
}
inline void ConfigFile::clear_amazon_s3_access_key_id() {
  amazon_s3_access_key_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigFile::amazon_s3_access_key_id() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_access_key_id)
  return _internal_amazon_s3_access_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_access_key_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 amazon_s3_access_key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_access_key_id)
}
inline std::string* ConfigFile::mutable_amazon_s3_access_key_id() {
  std::string* _s = _internal_mutable_amazon_s3_access_key_id();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_access_key_id)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_access_key_id() const {
  return amazon_s3_access_key_id_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_access_key_id(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  amazon_s3_access_key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_access_key_id() {
  _has_bits_[0] |= 0x00000010u;
  return amazon_s3_access_key_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_access_key_id() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_access_key_id)
  if (!_internal_has_amazon_s3_access_key_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = amazon_s3_access_key_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_access_key_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_access_key_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_access_key_id(std::string* amazon_s3_access_key_id) {
  if (amazon_s3_access_key_id != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  amazon_s3_access_key_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_access_key_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_access_key_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_access_key_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_access_key_id)
}

// optional string amazon_s3_secret_access_key = 15 [json_name = "amazonS3SecretAccessKey"];
inline bool ConfigFile::_internal_has_amazon_s3_secret_access_key() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_secret_access_key() const {
  return _internal_has_amazon_s3_secret_access_key();
}
inline void ConfigFile::clear_amazon_s3_secret_access_key() {
  amazon_s3_secret_access_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConfigFile::amazon_s3_secret_access_key() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_secret_access_key)
  return _internal_amazon_s3_secret_access_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_secret_access_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 amazon_s3_secret_access_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_secret_access_key)
}
inline std::string* ConfigFile::mutable_amazon_s3_secret_access_key() {
  std::string* _s = _internal_mutable_amazon_s3_secret_access_key();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_secret_access_key)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_secret_access_key() const {
  return amazon_s3_secret_access_key_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_secret_access_key(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  amazon_s3_secret_access_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_secret_access_key() {
  _has_bits_[0] |= 0x00000020u;
  return amazon_s3_secret_access_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_secret_access_key() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_secret_access_key)
  if (!_internal_has_amazon_s3_secret_access_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = amazon_s3_secret_access_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_secret_access_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_secret_access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_secret_access_key(std::string* amazon_s3_secret_access_key) {
  if (amazon_s3_secret_access_key != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  amazon_s3_secret_access_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_secret_access_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_secret_access_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_secret_access_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_secret_access_key)
}

// optional string amazon_s3_bucket = 16 [json_name = "amazonS3Bucket"];
inline bool ConfigFile::_internal_has_amazon_s3_bucket() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_bucket() const {
  return _internal_has_amazon_s3_bucket();
}
inline void ConfigFile::clear_amazon_s3_bucket() {
  amazon_s3_bucket_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConfigFile::amazon_s3_bucket() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_bucket)
  return _internal_amazon_s3_bucket();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_bucket(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 amazon_s3_bucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_bucket)
}
inline std::string* ConfigFile::mutable_amazon_s3_bucket() {
  std::string* _s = _internal_mutable_amazon_s3_bucket();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_bucket)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_bucket() const {
  return amazon_s3_bucket_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_bucket(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  amazon_s3_bucket_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_bucket() {
  _has_bits_[0] |= 0x00000040u;
  return amazon_s3_bucket_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_bucket() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_bucket)
  if (!_internal_has_amazon_s3_bucket()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = amazon_s3_bucket_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_bucket_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_bucket(std::string* amazon_s3_bucket) {
  if (amazon_s3_bucket != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  amazon_s3_bucket_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_bucket,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_bucket_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_bucket_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_bucket)
}

// optional string amazon_s3_path_prefix = 17 [json_name = "amazonS3PathPrefix"];
inline bool ConfigFile::_internal_has_amazon_s3_path_prefix() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_path_prefix() const {
  return _internal_has_amazon_s3_path_prefix();
}
inline void ConfigFile::clear_amazon_s3_path_prefix() {
  amazon_s3_path_prefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ConfigFile::amazon_s3_path_prefix() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_path_prefix)
  return _internal_amazon_s3_path_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_path_prefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 amazon_s3_path_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_path_prefix)
}
inline std::string* ConfigFile::mutable_amazon_s3_path_prefix() {
  std::string* _s = _internal_mutable_amazon_s3_path_prefix();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_path_prefix)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_path_prefix() const {
  return amazon_s3_path_prefix_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_path_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  amazon_s3_path_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_path_prefix() {
  _has_bits_[0] |= 0x00000080u;
  return amazon_s3_path_prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_path_prefix() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_path_prefix)
  if (!_internal_has_amazon_s3_path_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = amazon_s3_path_prefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_path_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_path_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_path_prefix(std::string* amazon_s3_path_prefix) {
  if (amazon_s3_path_prefix != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  amazon_s3_path_prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_path_prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_path_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_path_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_path_prefix)
}

// optional string amazon_s3_region = 18 [json_name = "amazonS3Region"];
inline bool ConfigFile::_internal_has_amazon_s3_region() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_region() const {
  return _internal_has_amazon_s3_region();
}
inline void ConfigFile::clear_amazon_s3_region() {
  amazon_s3_region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ConfigFile::amazon_s3_region() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_region)
  return _internal_amazon_s3_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 amazon_s3_region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_region)
}
inline std::string* ConfigFile::mutable_amazon_s3_region() {
  std::string* _s = _internal_mutable_amazon_s3_region();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_region)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_region() const {
  return amazon_s3_region_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_region(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  amazon_s3_region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_region() {
  _has_bits_[0] |= 0x00000100u;
  return amazon_s3_region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_region() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_region)
  if (!_internal_has_amazon_s3_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = amazon_s3_region_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_region(std::string* amazon_s3_region) {
  if (amazon_s3_region != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  amazon_s3_region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_region,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_region)
}

// optional string amazon_s3_endpoint = 19 [json_name = "amazonS3Endpoint"];
inline bool ConfigFile::_internal_has_amazon_s3_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_endpoint() const {
  return _internal_has_amazon_s3_endpoint();
}
inline void ConfigFile::clear_amazon_s3_endpoint() {
  amazon_s3_endpoint_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ConfigFile::amazon_s3_endpoint() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_endpoint)
  return _internal_amazon_s3_endpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_endpoint(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 amazon_s3_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_endpoint)
}
inline std::string* ConfigFile::mutable_amazon_s3_endpoint() {
  std::string* _s = _internal_mutable_amazon_s3_endpoint();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_endpoint)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_endpoint() const {
  return amazon_s3_endpoint_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  amazon_s3_endpoint_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_endpoint() {
  _has_bits_[0] |= 0x00000200u;
  return amazon_s3_endpoint_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_endpoint() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_endpoint)
  if (!_internal_has_amazon_s3_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = amazon_s3_endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_endpoint(std::string* amazon_s3_endpoint) {
  if (amazon_s3_endpoint != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  amazon_s3_endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_endpoint,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_endpoint_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_endpoint)
}

// optional bool amazon_s3_ssl = 20 [json_name = "amazonS3Ssl"];
inline bool ConfigFile::_internal_has_amazon_s3_ssl() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_ssl() const {
  return _internal_has_amazon_s3_ssl();
}
inline void ConfigFile::clear_amazon_s3_ssl() {
  amazon_s3_ssl_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool ConfigFile::_internal_amazon_s3_ssl() const {
  return amazon_s3_ssl_;
}
inline bool ConfigFile::amazon_s3_ssl() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_ssl)
  return _internal_amazon_s3_ssl();
}
inline void ConfigFile::_internal_set_amazon_s3_ssl(bool value) {
  _has_bits_[0] |= 0x00100000u;
  amazon_s3_ssl_ = value;
}
inline void ConfigFile::set_amazon_s3_ssl(bool value) {
  _internal_set_amazon_s3_ssl(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_ssl)
}

// optional bool amazon_s3_sign_v2 = 21 [json_name = "amazonS3SignV2"];
inline bool ConfigFile::_internal_has_amazon_s3_sign_v2() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_sign_v2() const {
  return _internal_has_amazon_s3_sign_v2();
}
inline void ConfigFile::clear_amazon_s3_sign_v2() {
  amazon_s3_sign_v2_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool ConfigFile::_internal_amazon_s3_sign_v2() const {
  return amazon_s3_sign_v2_;
}
inline bool ConfigFile::amazon_s3_sign_v2() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_sign_v2)
  return _internal_amazon_s3_sign_v2();
}
inline void ConfigFile::_internal_set_amazon_s3_sign_v2(bool value) {
  _has_bits_[0] |= 0x00200000u;
  amazon_s3_sign_v2_ = value;
}
inline void ConfigFile::set_amazon_s3_sign_v2(bool value) {
  _internal_set_amazon_s3_sign_v2(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_sign_v2)
}

// optional bool amazon_s3_sse = 22 [json_name = "amazonS3Sse"];
inline bool ConfigFile::_internal_has_amazon_s3_sse() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_sse() const {
  return _internal_has_amazon_s3_sse();
}
inline void ConfigFile::clear_amazon_s3_sse() {
  amazon_s3_sse_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool ConfigFile::_internal_amazon_s3_sse() const {
  return amazon_s3_sse_;
}
inline bool ConfigFile::amazon_s3_sse() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_sse)
  return _internal_amazon_s3_sse();
}
inline void ConfigFile::_internal_set_amazon_s3_sse(bool value) {
  _has_bits_[0] |= 0x01000000u;
  amazon_s3_sse_ = value;
}
inline void ConfigFile::set_amazon_s3_sse(bool value) {
  _internal_set_amazon_s3_sse(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_sse)
}

// optional bool amazon_s3_trace = 23 [json_name = "amazonS3Trace"];
inline bool ConfigFile::_internal_has_amazon_s3_trace() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_trace() const {
  return _internal_has_amazon_s3_trace();
}
inline void ConfigFile::clear_amazon_s3_trace() {
  amazon_s3_trace_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool ConfigFile::_internal_amazon_s3_trace() const {
  return amazon_s3_trace_;
}
inline bool ConfigFile::amazon_s3_trace() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_trace)
  return _internal_amazon_s3_trace();
}
inline void ConfigFile::_internal_set_amazon_s3_trace(bool value) {
  _has_bits_[0] |= 0x02000000u;
  amazon_s3_trace_ = value;
}
inline void ConfigFile::set_amazon_s3_trace(bool value) {
  _internal_set_amazon_s3_trace(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_trace)
}

// optional int64 amazon_s3_request_timeout_milliseconds = 24 [json_name = "amazonS3RequestTimeoutMilliseconds"];
inline bool ConfigFile::_internal_has_amazon_s3_request_timeout_milliseconds() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_request_timeout_milliseconds() const {
  return _internal_has_amazon_s3_request_timeout_milliseconds();
}
inline void ConfigFile::clear_amazon_s3_request_timeout_milliseconds() {
  amazon_s3_request_timeout_milliseconds_ = int64_t{0};
  _has_bits_[0] &= ~0x00400000u;
}
inline int64_t ConfigFile::_internal_amazon_s3_request_timeout_milliseconds() const {
  return amazon_s3_request_timeout_milliseconds_;
}
inline int64_t ConfigFile::amazon_s3_request_timeout_milliseconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_request_timeout_milliseconds)
  return _internal_amazon_s3_request_timeout_milliseconds();
}
inline void ConfigFile::_internal_set_amazon_s3_request_timeout_milliseconds(int64_t value) {
  _has_bits_[0] |= 0x00400000u;
  amazon_s3_request_timeout_milliseconds_ = value;
}
inline void ConfigFile::set_amazon_s3_request_timeout_milliseconds(int64_t value) {
  _internal_set_amazon_s3_request_timeout_milliseconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_request_timeout_milliseconds)
}

// optional int64 amazon_s3_upload_part_size_bytes = 25 [json_name = "amazonS3UploadPartSizeBytes"];
inline bool ConfigFile::_internal_has_amazon_s3_upload_part_size_bytes() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_upload_part_size_bytes() const {
  return _internal_has_amazon_s3_upload_part_size_bytes();
}
inline void ConfigFile::clear_amazon_s3_upload_part_size_bytes() {
  amazon_s3_upload_part_size_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00800000u;
}
inline int64_t ConfigFile::_internal_amazon_s3_upload_part_size_bytes() const {
  return amazon_s3_upload_part_size_bytes_;
}
inline int64_t ConfigFile::amazon_s3_upload_part_size_bytes() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_upload_part_size_bytes)
  return _internal_amazon_s3_upload_part_size_bytes();
}
inline void ConfigFile::_internal_set_amazon_s3_upload_part_size_bytes(int64_t value) {
  _has_bits_[0] |= 0x00800000u;
  amazon_s3_upload_part_size_bytes_ = value;
}
inline void ConfigFile::set_amazon_s3_upload_part_size_bytes(int64_t value) {
  _internal_set_amazon_s3_upload_part_size_bytes(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_upload_part_size_bytes)
}

// optional string amazon_s3_storage_class = 26 [json_name = "amazonS3StorageClass"];
inline bool ConfigFile::_internal_has_amazon_s3_storage_class() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ConfigFile::has_amazon_s3_storage_class() const {
  return _internal_has_amazon_s3_storage_class();
}
inline void ConfigFile::clear_amazon_s3_storage_class() {
  amazon_s3_storage_class_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ConfigFile::amazon_s3_storage_class() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigFile.amazon_s3_storage_class)
  return _internal_amazon_s3_storage_class();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigFile::set_amazon_s3_storage_class(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 amazon_s3_storage_class_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigFile.amazon_s3_storage_class)
}
inline std::string* ConfigFile::mutable_amazon_s3_storage_class() {
  std::string* _s = _internal_mutable_amazon_s3_storage_class();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigFile.amazon_s3_storage_class)
  return _s;
}
inline const std::string& ConfigFile::_internal_amazon_s3_storage_class() const {
  return amazon_s3_storage_class_.Get();
}
inline void ConfigFile::_internal_set_amazon_s3_storage_class(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  amazon_s3_storage_class_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigFile::_internal_mutable_amazon_s3_storage_class() {
  _has_bits_[0] |= 0x00000400u;
  return amazon_s3_storage_class_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigFile::release_amazon_s3_storage_class() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigFile.amazon_s3_storage_class)
  if (!_internal_has_amazon_s3_storage_class()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = amazon_s3_storage_class_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_storage_class_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_storage_class_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigFile::set_allocated_amazon_s3_storage_class(std::string* amazon_s3_storage_class) {
  if (amazon_s3_storage_class != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  amazon_s3_storage_class_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), amazon_s3_storage_class,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (amazon_s3_storage_class_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    amazon_s3_storage_class_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigFile.amazon_s3_storage_class)
}

// -------------------------------------------------------------------

// ConfigEmail

// optional bool send_email_notifications = 1 [json_name = "sendEmailNotifications"];
inline bool ConfigEmail::_internal_has_send_email_notifications() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ConfigEmail::has_send_email_notifications() const {
  return _internal_has_send_email_notifications();
}
inline void ConfigEmail::clear_send_email_notifications() {
  send_email_notifications_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool ConfigEmail::_internal_send_email_notifications() const {
  return send_email_notifications_;
}
inline bool ConfigEmail::send_email_notifications() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.send_email_notifications)
  return _internal_send_email_notifications();
}
inline void ConfigEmail::_internal_set_send_email_notifications(bool value) {
  _has_bits_[0] |= 0x00002000u;
  send_email_notifications_ = value;
}
inline void ConfigEmail::set_send_email_notifications(bool value) {
  _internal_set_send_email_notifications(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.send_email_notifications)
}

// optional bool require_email_verification = 2 [json_name = "requireEmailVerification"];
inline bool ConfigEmail::_internal_has_require_email_verification() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ConfigEmail::has_require_email_verification() const {
  return _internal_has_require_email_verification();
}
inline void ConfigEmail::clear_require_email_verification() {
  require_email_verification_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool ConfigEmail::_internal_require_email_verification() const {
  return require_email_verification_;
}
inline bool ConfigEmail::require_email_verification() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.require_email_verification)
  return _internal_require_email_verification();
}
inline void ConfigEmail::_internal_set_require_email_verification(bool value) {
  _has_bits_[0] |= 0x00004000u;
  require_email_verification_ = value;
}
inline void ConfigEmail::set_require_email_verification(bool value) {
  _internal_set_require_email_verification(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.require_email_verification)
}

// optional string feedback_email = 3 [json_name = "feedbackEmail"];
inline bool ConfigEmail::_internal_has_feedback_email() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigEmail::has_feedback_email() const {
  return _internal_has_feedback_email();
}
inline void ConfigEmail::clear_feedback_email() {
  feedback_email_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigEmail::feedback_email() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.feedback_email)
  return _internal_feedback_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_feedback_email(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 feedback_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.feedback_email)
}
inline std::string* ConfigEmail::mutable_feedback_email() {
  std::string* _s = _internal_mutable_feedback_email();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.feedback_email)
  return _s;
}
inline const std::string& ConfigEmail::_internal_feedback_email() const {
  return feedback_email_.Get();
}
inline void ConfigEmail::_internal_set_feedback_email(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  feedback_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_feedback_email() {
  _has_bits_[0] |= 0x00000001u;
  return feedback_email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_feedback_email() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.feedback_email)
  if (!_internal_has_feedback_email()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = feedback_email_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (feedback_email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    feedback_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_feedback_email(std::string* feedback_email) {
  if (feedback_email != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  feedback_email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), feedback_email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (feedback_email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    feedback_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.feedback_email)
}

// optional string reply_to_address = 4 [json_name = "replyToAddress"];
inline bool ConfigEmail::_internal_has_reply_to_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigEmail::has_reply_to_address() const {
  return _internal_has_reply_to_address();
}
inline void ConfigEmail::clear_reply_to_address() {
  reply_to_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigEmail::reply_to_address() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.reply_to_address)
  return _internal_reply_to_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_reply_to_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 reply_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.reply_to_address)
}
inline std::string* ConfigEmail::mutable_reply_to_address() {
  std::string* _s = _internal_mutable_reply_to_address();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.reply_to_address)
  return _s;
}
inline const std::string& ConfigEmail::_internal_reply_to_address() const {
  return reply_to_address_.Get();
}
inline void ConfigEmail::_internal_set_reply_to_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  reply_to_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_reply_to_address() {
  _has_bits_[0] |= 0x00000002u;
  return reply_to_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_reply_to_address() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.reply_to_address)
  if (!_internal_has_reply_to_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = reply_to_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reply_to_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reply_to_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_reply_to_address(std::string* reply_to_address) {
  if (reply_to_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  reply_to_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reply_to_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reply_to_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reply_to_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.reply_to_address)
}

// optional bool enable_smtp_auth = 5 [json_name = "enableSmtpAuth"];
inline bool ConfigEmail::_internal_has_enable_smtp_auth() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ConfigEmail::has_enable_smtp_auth() const {
  return _internal_has_enable_smtp_auth();
}
inline void ConfigEmail::clear_enable_smtp_auth() {
  enable_smtp_auth_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool ConfigEmail::_internal_enable_smtp_auth() const {
  return enable_smtp_auth_;
}
inline bool ConfigEmail::enable_smtp_auth() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.enable_smtp_auth)
  return _internal_enable_smtp_auth();
}
inline void ConfigEmail::_internal_set_enable_smtp_auth(bool value) {
  _has_bits_[0] |= 0x00008000u;
  enable_smtp_auth_ = value;
}
inline void ConfigEmail::set_enable_smtp_auth(bool value) {
  _internal_set_enable_smtp_auth(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.enable_smtp_auth)
}

// optional string smtp_username = 6 [json_name = "smtpUsername"];
inline bool ConfigEmail::_internal_has_smtp_username() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigEmail::has_smtp_username() const {
  return _internal_has_smtp_username();
}
inline void ConfigEmail::clear_smtp_username() {
  smtp_username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigEmail::smtp_username() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.smtp_username)
  return _internal_smtp_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_smtp_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 smtp_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.smtp_username)
}
inline std::string* ConfigEmail::mutable_smtp_username() {
  std::string* _s = _internal_mutable_smtp_username();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.smtp_username)
  return _s;
}
inline const std::string& ConfigEmail::_internal_smtp_username() const {
  return smtp_username_.Get();
}
inline void ConfigEmail::_internal_set_smtp_username(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  smtp_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_smtp_username() {
  _has_bits_[0] |= 0x00000004u;
  return smtp_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_smtp_username() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.smtp_username)
  if (!_internal_has_smtp_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = smtp_username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_smtp_username(std::string* smtp_username) {
  if (smtp_username != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  smtp_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smtp_username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.smtp_username)
}

// optional string smtp_password = 7 [json_name = "smtpPassword"];
inline bool ConfigEmail::_internal_has_smtp_password() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigEmail::has_smtp_password() const {
  return _internal_has_smtp_password();
}
inline void ConfigEmail::clear_smtp_password() {
  smtp_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigEmail::smtp_password() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.smtp_password)
  return _internal_smtp_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_smtp_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 smtp_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.smtp_password)
}
inline std::string* ConfigEmail::mutable_smtp_password() {
  std::string* _s = _internal_mutable_smtp_password();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.smtp_password)
  return _s;
}
inline const std::string& ConfigEmail::_internal_smtp_password() const {
  return smtp_password_.Get();
}
inline void ConfigEmail::_internal_set_smtp_password(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  smtp_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_smtp_password() {
  _has_bits_[0] |= 0x00000008u;
  return smtp_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_smtp_password() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.smtp_password)
  if (!_internal_has_smtp_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = smtp_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_smtp_password(std::string* smtp_password) {
  if (smtp_password != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  smtp_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smtp_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.smtp_password)
}

// optional string smtp_server = 8 [json_name = "smtpServer"];
inline bool ConfigEmail::_internal_has_smtp_server() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigEmail::has_smtp_server() const {
  return _internal_has_smtp_server();
}
inline void ConfigEmail::clear_smtp_server() {
  smtp_server_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigEmail::smtp_server() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.smtp_server)
  return _internal_smtp_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_smtp_server(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 smtp_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.smtp_server)
}
inline std::string* ConfigEmail::mutable_smtp_server() {
  std::string* _s = _internal_mutable_smtp_server();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.smtp_server)
  return _s;
}
inline const std::string& ConfigEmail::_internal_smtp_server() const {
  return smtp_server_.Get();
}
inline void ConfigEmail::_internal_set_smtp_server(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  smtp_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_smtp_server() {
  _has_bits_[0] |= 0x00000010u;
  return smtp_server_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_smtp_server() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.smtp_server)
  if (!_internal_has_smtp_server()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = smtp_server_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_smtp_server(std::string* smtp_server) {
  if (smtp_server != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  smtp_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smtp_server,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.smtp_server)
}

// optional string smtp_port = 9 [json_name = "smtpPort"];
inline bool ConfigEmail::_internal_has_smtp_port() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigEmail::has_smtp_port() const {
  return _internal_has_smtp_port();
}
inline void ConfigEmail::clear_smtp_port() {
  smtp_port_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConfigEmail::smtp_port() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.smtp_port)
  return _internal_smtp_port();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_smtp_port(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 smtp_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.smtp_port)
}
inline std::string* ConfigEmail::mutable_smtp_port() {
  std::string* _s = _internal_mutable_smtp_port();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.smtp_port)
  return _s;
}
inline const std::string& ConfigEmail::_internal_smtp_port() const {
  return smtp_port_.Get();
}
inline void ConfigEmail::_internal_set_smtp_port(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  smtp_port_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_smtp_port() {
  _has_bits_[0] |= 0x00000020u;
  return smtp_port_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_smtp_port() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.smtp_port)
  if (!_internal_has_smtp_port()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = smtp_port_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_port_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_port_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_smtp_port(std::string* smtp_port) {
  if (smtp_port != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  smtp_port_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), smtp_port,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (smtp_port_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    smtp_port_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.smtp_port)
}

// optional int32 smtp_server_timeout = 10 [json_name = "smtpServerTimeout"];
inline bool ConfigEmail::_internal_has_smtp_server_timeout() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ConfigEmail::has_smtp_server_timeout() const {
  return _internal_has_smtp_server_timeout();
}
inline void ConfigEmail::clear_smtp_server_timeout() {
  smtp_server_timeout_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline int32_t ConfigEmail::_internal_smtp_server_timeout() const {
  return smtp_server_timeout_;
}
inline int32_t ConfigEmail::smtp_server_timeout() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.smtp_server_timeout)
  return _internal_smtp_server_timeout();
}
inline void ConfigEmail::_internal_set_smtp_server_timeout(int32_t value) {
  _has_bits_[0] |= 0x00020000u;
  smtp_server_timeout_ = value;
}
inline void ConfigEmail::set_smtp_server_timeout(int32_t value) {
  _internal_set_smtp_server_timeout(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.smtp_server_timeout)
}

// optional string connection_security = 11 [json_name = "connectionSecurity"];
inline bool ConfigEmail::_internal_has_connection_security() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigEmail::has_connection_security() const {
  return _internal_has_connection_security();
}
inline void ConfigEmail::clear_connection_security() {
  connection_security_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConfigEmail::connection_security() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.connection_security)
  return _internal_connection_security();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_connection_security(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 connection_security_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.connection_security)
}
inline std::string* ConfigEmail::mutable_connection_security() {
  std::string* _s = _internal_mutable_connection_security();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.connection_security)
  return _s;
}
inline const std::string& ConfigEmail::_internal_connection_security() const {
  return connection_security_.Get();
}
inline void ConfigEmail::_internal_set_connection_security(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  connection_security_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_connection_security() {
  _has_bits_[0] |= 0x00000040u;
  return connection_security_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_connection_security() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.connection_security)
  if (!_internal_has_connection_security()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = connection_security_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connection_security_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connection_security_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_connection_security(std::string* connection_security) {
  if (connection_security != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  connection_security_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connection_security,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connection_security_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connection_security_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.connection_security)
}

// optional bool send_push_notifications = 12 [json_name = "sendPushNotifications"];
inline bool ConfigEmail::_internal_has_send_push_notifications() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ConfigEmail::has_send_push_notifications() const {
  return _internal_has_send_push_notifications();
}
inline void ConfigEmail::clear_send_push_notifications() {
  send_push_notifications_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool ConfigEmail::_internal_send_push_notifications() const {
  return send_push_notifications_;
}
inline bool ConfigEmail::send_push_notifications() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.send_push_notifications)
  return _internal_send_push_notifications();
}
inline void ConfigEmail::_internal_set_send_push_notifications(bool value) {
  _has_bits_[0] |= 0x00010000u;
  send_push_notifications_ = value;
}
inline void ConfigEmail::set_send_push_notifications(bool value) {
  _internal_set_send_push_notifications(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.send_push_notifications)
}

// optional string push_notification_server = 13 [json_name = "pushNotificationServer"];
inline bool ConfigEmail::_internal_has_push_notification_server() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigEmail::has_push_notification_server() const {
  return _internal_has_push_notification_server();
}
inline void ConfigEmail::clear_push_notification_server() {
  push_notification_server_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ConfigEmail::push_notification_server() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.push_notification_server)
  return _internal_push_notification_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_push_notification_server(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 push_notification_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.push_notification_server)
}
inline std::string* ConfigEmail::mutable_push_notification_server() {
  std::string* _s = _internal_mutable_push_notification_server();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.push_notification_server)
  return _s;
}
inline const std::string& ConfigEmail::_internal_push_notification_server() const {
  return push_notification_server_.Get();
}
inline void ConfigEmail::_internal_set_push_notification_server(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  push_notification_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_push_notification_server() {
  _has_bits_[0] |= 0x00000080u;
  return push_notification_server_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_push_notification_server() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.push_notification_server)
  if (!_internal_has_push_notification_server()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = push_notification_server_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_notification_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_notification_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_push_notification_server(std::string* push_notification_server) {
  if (push_notification_server != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  push_notification_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), push_notification_server,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_notification_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_notification_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.push_notification_server)
}

// optional string push_notification_contents = 14 [json_name = "pushNotificationContents"];
inline bool ConfigEmail::_internal_has_push_notification_contents() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigEmail::has_push_notification_contents() const {
  return _internal_has_push_notification_contents();
}
inline void ConfigEmail::clear_push_notification_contents() {
  push_notification_contents_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ConfigEmail::push_notification_contents() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.push_notification_contents)
  return _internal_push_notification_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_push_notification_contents(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 push_notification_contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.push_notification_contents)
}
inline std::string* ConfigEmail::mutable_push_notification_contents() {
  std::string* _s = _internal_mutable_push_notification_contents();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.push_notification_contents)
  return _s;
}
inline const std::string& ConfigEmail::_internal_push_notification_contents() const {
  return push_notification_contents_.Get();
}
inline void ConfigEmail::_internal_set_push_notification_contents(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  push_notification_contents_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_push_notification_contents() {
  _has_bits_[0] |= 0x00000100u;
  return push_notification_contents_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_push_notification_contents() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.push_notification_contents)
  if (!_internal_has_push_notification_contents()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = push_notification_contents_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_notification_contents_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_notification_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_push_notification_contents(std::string* push_notification_contents) {
  if (push_notification_contents != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  push_notification_contents_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), push_notification_contents,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (push_notification_contents_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    push_notification_contents_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.push_notification_contents)
}

// optional int32 push_notification_buffer = 15 [json_name = "pushNotificationBuffer"];
inline bool ConfigEmail::_internal_has_push_notification_buffer() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ConfigEmail::has_push_notification_buffer() const {
  return _internal_has_push_notification_buffer();
}
inline void ConfigEmail::clear_push_notification_buffer() {
  push_notification_buffer_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t ConfigEmail::_internal_push_notification_buffer() const {
  return push_notification_buffer_;
}
inline int32_t ConfigEmail::push_notification_buffer() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.push_notification_buffer)
  return _internal_push_notification_buffer();
}
inline void ConfigEmail::_internal_set_push_notification_buffer(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  push_notification_buffer_ = value;
}
inline void ConfigEmail::set_push_notification_buffer(int32_t value) {
  _internal_set_push_notification_buffer(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.push_notification_buffer)
}

// optional bool enable_email_batching = 16 [json_name = "enableEmailBatching"];
inline bool ConfigEmail::_internal_has_enable_email_batching() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ConfigEmail::has_enable_email_batching() const {
  return _internal_has_enable_email_batching();
}
inline void ConfigEmail::clear_enable_email_batching() {
  enable_email_batching_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool ConfigEmail::_internal_enable_email_batching() const {
  return enable_email_batching_;
}
inline bool ConfigEmail::enable_email_batching() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.enable_email_batching)
  return _internal_enable_email_batching();
}
inline void ConfigEmail::_internal_set_enable_email_batching(bool value) {
  _has_bits_[0] |= 0x00100000u;
  enable_email_batching_ = value;
}
inline void ConfigEmail::set_enable_email_batching(bool value) {
  _internal_set_enable_email_batching(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.enable_email_batching)
}

// optional int32 email_batching_buffer_size = 17 [json_name = "emailBatchingBufferSize"];
inline bool ConfigEmail::_internal_has_email_batching_buffer_size() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ConfigEmail::has_email_batching_buffer_size() const {
  return _internal_has_email_batching_buffer_size();
}
inline void ConfigEmail::clear_email_batching_buffer_size() {
  email_batching_buffer_size_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline int32_t ConfigEmail::_internal_email_batching_buffer_size() const {
  return email_batching_buffer_size_;
}
inline int32_t ConfigEmail::email_batching_buffer_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.email_batching_buffer_size)
  return _internal_email_batching_buffer_size();
}
inline void ConfigEmail::_internal_set_email_batching_buffer_size(int32_t value) {
  _has_bits_[0] |= 0x00080000u;
  email_batching_buffer_size_ = value;
}
inline void ConfigEmail::set_email_batching_buffer_size(int32_t value) {
  _internal_set_email_batching_buffer_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.email_batching_buffer_size)
}

// optional int32 email_batching_interval = 18 [json_name = "emailBatchingInterval"];
inline bool ConfigEmail::_internal_has_email_batching_interval() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ConfigEmail::has_email_batching_interval() const {
  return _internal_has_email_batching_interval();
}
inline void ConfigEmail::clear_email_batching_interval() {
  email_batching_interval_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline int32_t ConfigEmail::_internal_email_batching_interval() const {
  return email_batching_interval_;
}
inline int32_t ConfigEmail::email_batching_interval() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.email_batching_interval)
  return _internal_email_batching_interval();
}
inline void ConfigEmail::_internal_set_email_batching_interval(int32_t value) {
  _has_bits_[0] |= 0x00400000u;
  email_batching_interval_ = value;
}
inline void ConfigEmail::set_email_batching_interval(int32_t value) {
  _internal_set_email_batching_interval(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.email_batching_interval)
}

// optional bool skip_server_certificate_verification = 19 [json_name = "skipServerCertificateVerification"];
inline bool ConfigEmail::_internal_has_skip_server_certificate_verification() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ConfigEmail::has_skip_server_certificate_verification() const {
  return _internal_has_skip_server_certificate_verification();
}
inline void ConfigEmail::clear_skip_server_certificate_verification() {
  skip_server_certificate_verification_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool ConfigEmail::_internal_skip_server_certificate_verification() const {
  return skip_server_certificate_verification_;
}
inline bool ConfigEmail::skip_server_certificate_verification() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.skip_server_certificate_verification)
  return _internal_skip_server_certificate_verification();
}
inline void ConfigEmail::_internal_set_skip_server_certificate_verification(bool value) {
  _has_bits_[0] |= 0x00200000u;
  skip_server_certificate_verification_ = value;
}
inline void ConfigEmail::set_skip_server_certificate_verification(bool value) {
  _internal_set_skip_server_certificate_verification(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.skip_server_certificate_verification)
}

// optional string email_notification_contents_type = 20 [json_name = "emailNotificationContentsType"];
inline bool ConfigEmail::_internal_has_email_notification_contents_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigEmail::has_email_notification_contents_type() const {
  return _internal_has_email_notification_contents_type();
}
inline void ConfigEmail::clear_email_notification_contents_type() {
  email_notification_contents_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ConfigEmail::email_notification_contents_type() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.email_notification_contents_type)
  return _internal_email_notification_contents_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_email_notification_contents_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 email_notification_contents_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.email_notification_contents_type)
}
inline std::string* ConfigEmail::mutable_email_notification_contents_type() {
  std::string* _s = _internal_mutable_email_notification_contents_type();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.email_notification_contents_type)
  return _s;
}
inline const std::string& ConfigEmail::_internal_email_notification_contents_type() const {
  return email_notification_contents_type_.Get();
}
inline void ConfigEmail::_internal_set_email_notification_contents_type(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  email_notification_contents_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_email_notification_contents_type() {
  _has_bits_[0] |= 0x00000200u;
  return email_notification_contents_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_email_notification_contents_type() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.email_notification_contents_type)
  if (!_internal_has_email_notification_contents_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = email_notification_contents_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_notification_contents_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_notification_contents_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_email_notification_contents_type(std::string* email_notification_contents_type) {
  if (email_notification_contents_type != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  email_notification_contents_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email_notification_contents_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_notification_contents_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_notification_contents_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.email_notification_contents_type)
}

// optional string login_button_color = 21 [json_name = "loginButtonColor"];
inline bool ConfigEmail::_internal_has_login_button_color() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ConfigEmail::has_login_button_color() const {
  return _internal_has_login_button_color();
}
inline void ConfigEmail::clear_login_button_color() {
  login_button_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ConfigEmail::login_button_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.login_button_color)
  return _internal_login_button_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_login_button_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 login_button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.login_button_color)
}
inline std::string* ConfigEmail::mutable_login_button_color() {
  std::string* _s = _internal_mutable_login_button_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.login_button_color)
  return _s;
}
inline const std::string& ConfigEmail::_internal_login_button_color() const {
  return login_button_color_.Get();
}
inline void ConfigEmail::_internal_set_login_button_color(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  login_button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_login_button_color() {
  _has_bits_[0] |= 0x00000400u;
  return login_button_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_login_button_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.login_button_color)
  if (!_internal_has_login_button_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = login_button_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_login_button_color(std::string* login_button_color) {
  if (login_button_color != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  login_button_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.login_button_color)
}

// optional string login_button_border_color = 22 [json_name = "loginButtonBorderColor"];
inline bool ConfigEmail::_internal_has_login_button_border_color() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ConfigEmail::has_login_button_border_color() const {
  return _internal_has_login_button_border_color();
}
inline void ConfigEmail::clear_login_button_border_color() {
  login_button_border_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ConfigEmail::login_button_border_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.login_button_border_color)
  return _internal_login_button_border_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_login_button_border_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 login_button_border_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.login_button_border_color)
}
inline std::string* ConfigEmail::mutable_login_button_border_color() {
  std::string* _s = _internal_mutable_login_button_border_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.login_button_border_color)
  return _s;
}
inline const std::string& ConfigEmail::_internal_login_button_border_color() const {
  return login_button_border_color_.Get();
}
inline void ConfigEmail::_internal_set_login_button_border_color(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  login_button_border_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_login_button_border_color() {
  _has_bits_[0] |= 0x00000800u;
  return login_button_border_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_login_button_border_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.login_button_border_color)
  if (!_internal_has_login_button_border_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = login_button_border_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_border_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_border_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_login_button_border_color(std::string* login_button_border_color) {
  if (login_button_border_color != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  login_button_border_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_border_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_border_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_border_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.login_button_border_color)
}

// optional string login_button_text_color = 23 [json_name = "loginButtonTextColor"];
inline bool ConfigEmail::_internal_has_login_button_text_color() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ConfigEmail::has_login_button_text_color() const {
  return _internal_has_login_button_text_color();
}
inline void ConfigEmail::clear_login_button_text_color() {
  login_button_text_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ConfigEmail::login_button_text_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigEmail.login_button_text_color)
  return _internal_login_button_text_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigEmail::set_login_button_text_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 login_button_text_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigEmail.login_button_text_color)
}
inline std::string* ConfigEmail::mutable_login_button_text_color() {
  std::string* _s = _internal_mutable_login_button_text_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigEmail.login_button_text_color)
  return _s;
}
inline const std::string& ConfigEmail::_internal_login_button_text_color() const {
  return login_button_text_color_.Get();
}
inline void ConfigEmail::_internal_set_login_button_text_color(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  login_button_text_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigEmail::_internal_mutable_login_button_text_color() {
  _has_bits_[0] |= 0x00001000u;
  return login_button_text_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigEmail::release_login_button_text_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigEmail.login_button_text_color)
  if (!_internal_has_login_button_text_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = login_button_text_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigEmail::set_allocated_login_button_text_color(std::string* login_button_text_color) {
  if (login_button_text_color != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  login_button_text_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_text_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigEmail.login_button_text_color)
}

// -------------------------------------------------------------------

// ConfigRateLimit

// optional bool enable = 1 [json_name = "enable"];
inline bool ConfigRateLimit::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigRateLimit::has_enable() const {
  return _internal_has_enable();
}
inline void ConfigRateLimit::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigRateLimit::_internal_enable() const {
  return enable_;
}
inline bool ConfigRateLimit::enable() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.enable)
  return _internal_enable();
}
inline void ConfigRateLimit::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_ = value;
}
inline void ConfigRateLimit::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.enable)
}

// optional int32 per_sec = 2 [json_name = "perSec"];
inline bool ConfigRateLimit::_internal_has_per_sec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigRateLimit::has_per_sec() const {
  return _internal_has_per_sec();
}
inline void ConfigRateLimit::clear_per_sec() {
  per_sec_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t ConfigRateLimit::_internal_per_sec() const {
  return per_sec_;
}
inline int32_t ConfigRateLimit::per_sec() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.per_sec)
  return _internal_per_sec();
}
inline void ConfigRateLimit::_internal_set_per_sec(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  per_sec_ = value;
}
inline void ConfigRateLimit::set_per_sec(int32_t value) {
  _internal_set_per_sec(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.per_sec)
}

// optional int32 max_burst = 3 [json_name = "maxBurst"];
inline bool ConfigRateLimit::_internal_has_max_burst() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigRateLimit::has_max_burst() const {
  return _internal_has_max_burst();
}
inline void ConfigRateLimit::clear_max_burst() {
  max_burst_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ConfigRateLimit::_internal_max_burst() const {
  return max_burst_;
}
inline int32_t ConfigRateLimit::max_burst() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.max_burst)
  return _internal_max_burst();
}
inline void ConfigRateLimit::_internal_set_max_burst(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  max_burst_ = value;
}
inline void ConfigRateLimit::set_max_burst(int32_t value) {
  _internal_set_max_burst(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.max_burst)
}

// optional int32 memory_store_size = 4 [json_name = "memoryStoreSize"];
inline bool ConfigRateLimit::_internal_has_memory_store_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigRateLimit::has_memory_store_size() const {
  return _internal_has_memory_store_size();
}
inline void ConfigRateLimit::clear_memory_store_size() {
  memory_store_size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t ConfigRateLimit::_internal_memory_store_size() const {
  return memory_store_size_;
}
inline int32_t ConfigRateLimit::memory_store_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.memory_store_size)
  return _internal_memory_store_size();
}
inline void ConfigRateLimit::_internal_set_memory_store_size(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  memory_store_size_ = value;
}
inline void ConfigRateLimit::set_memory_store_size(int32_t value) {
  _internal_set_memory_store_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.memory_store_size)
}

// optional bool vary_by_remote_addr = 5 [json_name = "varyByRemoteAddr"];
inline bool ConfigRateLimit::_internal_has_vary_by_remote_addr() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigRateLimit::has_vary_by_remote_addr() const {
  return _internal_has_vary_by_remote_addr();
}
inline void ConfigRateLimit::clear_vary_by_remote_addr() {
  vary_by_remote_addr_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigRateLimit::_internal_vary_by_remote_addr() const {
  return vary_by_remote_addr_;
}
inline bool ConfigRateLimit::vary_by_remote_addr() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.vary_by_remote_addr)
  return _internal_vary_by_remote_addr();
}
inline void ConfigRateLimit::_internal_set_vary_by_remote_addr(bool value) {
  _has_bits_[0] |= 0x00000010u;
  vary_by_remote_addr_ = value;
}
inline void ConfigRateLimit::set_vary_by_remote_addr(bool value) {
  _internal_set_vary_by_remote_addr(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.vary_by_remote_addr)
}

// optional bool vary_by_user = 6 [json_name = "varyByUser"];
inline bool ConfigRateLimit::_internal_has_vary_by_user() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigRateLimit::has_vary_by_user() const {
  return _internal_has_vary_by_user();
}
inline void ConfigRateLimit::clear_vary_by_user() {
  vary_by_user_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigRateLimit::_internal_vary_by_user() const {
  return vary_by_user_;
}
inline bool ConfigRateLimit::vary_by_user() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.vary_by_user)
  return _internal_vary_by_user();
}
inline void ConfigRateLimit::_internal_set_vary_by_user(bool value) {
  _has_bits_[0] |= 0x00000020u;
  vary_by_user_ = value;
}
inline void ConfigRateLimit::set_vary_by_user(bool value) {
  _internal_set_vary_by_user(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.vary_by_user)
}

// string vary_by_header = 7 [json_name = "varyByHeader"];
inline void ConfigRateLimit::clear_vary_by_header() {
  vary_by_header_.ClearToEmpty();
}
inline const std::string& ConfigRateLimit::vary_by_header() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigRateLimit.vary_by_header)
  return _internal_vary_by_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigRateLimit::set_vary_by_header(ArgT0&& arg0, ArgT... args) {
 
 vary_by_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigRateLimit.vary_by_header)
}
inline std::string* ConfigRateLimit::mutable_vary_by_header() {
  std::string* _s = _internal_mutable_vary_by_header();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigRateLimit.vary_by_header)
  return _s;
}
inline const std::string& ConfigRateLimit::_internal_vary_by_header() const {
  return vary_by_header_.Get();
}
inline void ConfigRateLimit::_internal_set_vary_by_header(const std::string& value) {
  
  vary_by_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigRateLimit::_internal_mutable_vary_by_header() {
  
  return vary_by_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigRateLimit::release_vary_by_header() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigRateLimit.vary_by_header)
  return vary_by_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigRateLimit::set_allocated_vary_by_header(std::string* vary_by_header) {
  if (vary_by_header != nullptr) {
    
  } else {
    
  }
  vary_by_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vary_by_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (vary_by_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    vary_by_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigRateLimit.vary_by_header)
}

// -------------------------------------------------------------------

// ConfigPrivacy

// optional bool show_email_address = 1 [json_name = "showEmailAddress"];
inline bool ConfigPrivacy::_internal_has_show_email_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigPrivacy::has_show_email_address() const {
  return _internal_has_show_email_address();
}
inline void ConfigPrivacy::clear_show_email_address() {
  show_email_address_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ConfigPrivacy::_internal_show_email_address() const {
  return show_email_address_;
}
inline bool ConfigPrivacy::show_email_address() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPrivacy.show_email_address)
  return _internal_show_email_address();
}
inline void ConfigPrivacy::_internal_set_show_email_address(bool value) {
  _has_bits_[0] |= 0x00000001u;
  show_email_address_ = value;
}
inline void ConfigPrivacy::set_show_email_address(bool value) {
  _internal_set_show_email_address(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPrivacy.show_email_address)
}

// optional bool show_full_name = 2 [json_name = "showFullName"];
inline bool ConfigPrivacy::_internal_has_show_full_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigPrivacy::has_show_full_name() const {
  return _internal_has_show_full_name();
}
inline void ConfigPrivacy::clear_show_full_name() {
  show_full_name_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ConfigPrivacy::_internal_show_full_name() const {
  return show_full_name_;
}
inline bool ConfigPrivacy::show_full_name() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigPrivacy.show_full_name)
  return _internal_show_full_name();
}
inline void ConfigPrivacy::_internal_set_show_full_name(bool value) {
  _has_bits_[0] |= 0x00000002u;
  show_full_name_ = value;
}
inline void ConfigPrivacy::set_show_full_name(bool value) {
  _internal_set_show_full_name(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigPrivacy.show_full_name)
}

// -------------------------------------------------------------------

// ConfigSupport

// optional string terms_of_service_link = 1 [json_name = "termsOfServiceLink"];
inline bool ConfigSupport::_internal_has_terms_of_service_link() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigSupport::has_terms_of_service_link() const {
  return _internal_has_terms_of_service_link();
}
inline void ConfigSupport::clear_terms_of_service_link() {
  terms_of_service_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigSupport::terms_of_service_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.terms_of_service_link)
  return _internal_terms_of_service_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_terms_of_service_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 terms_of_service_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.terms_of_service_link)
}
inline std::string* ConfigSupport::mutable_terms_of_service_link() {
  std::string* _s = _internal_mutable_terms_of_service_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.terms_of_service_link)
  return _s;
}
inline const std::string& ConfigSupport::_internal_terms_of_service_link() const {
  return terms_of_service_link_.Get();
}
inline void ConfigSupport::_internal_set_terms_of_service_link(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  terms_of_service_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_terms_of_service_link() {
  _has_bits_[0] |= 0x00000001u;
  return terms_of_service_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_terms_of_service_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.terms_of_service_link)
  if (!_internal_has_terms_of_service_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = terms_of_service_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (terms_of_service_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    terms_of_service_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_terms_of_service_link(std::string* terms_of_service_link) {
  if (terms_of_service_link != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  terms_of_service_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), terms_of_service_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (terms_of_service_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    terms_of_service_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.terms_of_service_link)
}

// optional string privacy_policy_link = 2 [json_name = "privacyPolicyLink"];
inline bool ConfigSupport::_internal_has_privacy_policy_link() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigSupport::has_privacy_policy_link() const {
  return _internal_has_privacy_policy_link();
}
inline void ConfigSupport::clear_privacy_policy_link() {
  privacy_policy_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigSupport::privacy_policy_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.privacy_policy_link)
  return _internal_privacy_policy_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_privacy_policy_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 privacy_policy_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.privacy_policy_link)
}
inline std::string* ConfigSupport::mutable_privacy_policy_link() {
  std::string* _s = _internal_mutable_privacy_policy_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.privacy_policy_link)
  return _s;
}
inline const std::string& ConfigSupport::_internal_privacy_policy_link() const {
  return privacy_policy_link_.Get();
}
inline void ConfigSupport::_internal_set_privacy_policy_link(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  privacy_policy_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_privacy_policy_link() {
  _has_bits_[0] |= 0x00000002u;
  return privacy_policy_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_privacy_policy_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.privacy_policy_link)
  if (!_internal_has_privacy_policy_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = privacy_policy_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privacy_policy_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privacy_policy_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_privacy_policy_link(std::string* privacy_policy_link) {
  if (privacy_policy_link != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  privacy_policy_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), privacy_policy_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (privacy_policy_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    privacy_policy_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.privacy_policy_link)
}

// optional string about_link = 3 [json_name = "aboutLink"];
inline bool ConfigSupport::_internal_has_about_link() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigSupport::has_about_link() const {
  return _internal_has_about_link();
}
inline void ConfigSupport::clear_about_link() {
  about_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigSupport::about_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.about_link)
  return _internal_about_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_about_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 about_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.about_link)
}
inline std::string* ConfigSupport::mutable_about_link() {
  std::string* _s = _internal_mutable_about_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.about_link)
  return _s;
}
inline const std::string& ConfigSupport::_internal_about_link() const {
  return about_link_.Get();
}
inline void ConfigSupport::_internal_set_about_link(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  about_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_about_link() {
  _has_bits_[0] |= 0x00000004u;
  return about_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_about_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.about_link)
  if (!_internal_has_about_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = about_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (about_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    about_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_about_link(std::string* about_link) {
  if (about_link != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  about_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), about_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (about_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    about_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.about_link)
}

// optional string help_link = 4 [json_name = "helpLink"];
inline bool ConfigSupport::_internal_has_help_link() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigSupport::has_help_link() const {
  return _internal_has_help_link();
}
inline void ConfigSupport::clear_help_link() {
  help_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigSupport::help_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.help_link)
  return _internal_help_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_help_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 help_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.help_link)
}
inline std::string* ConfigSupport::mutable_help_link() {
  std::string* _s = _internal_mutable_help_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.help_link)
  return _s;
}
inline const std::string& ConfigSupport::_internal_help_link() const {
  return help_link_.Get();
}
inline void ConfigSupport::_internal_set_help_link(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  help_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_help_link() {
  _has_bits_[0] |= 0x00000008u;
  return help_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_help_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.help_link)
  if (!_internal_has_help_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = help_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (help_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    help_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_help_link(std::string* help_link) {
  if (help_link != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  help_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), help_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (help_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    help_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.help_link)
}

// optional string report_a_problem_link = 5 [json_name = "reportAProblemLink"];
inline bool ConfigSupport::_internal_has_report_a_problem_link() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigSupport::has_report_a_problem_link() const {
  return _internal_has_report_a_problem_link();
}
inline void ConfigSupport::clear_report_a_problem_link() {
  report_a_problem_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigSupport::report_a_problem_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.report_a_problem_link)
  return _internal_report_a_problem_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_report_a_problem_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 report_a_problem_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.report_a_problem_link)
}
inline std::string* ConfigSupport::mutable_report_a_problem_link() {
  std::string* _s = _internal_mutable_report_a_problem_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.report_a_problem_link)
  return _s;
}
inline const std::string& ConfigSupport::_internal_report_a_problem_link() const {
  return report_a_problem_link_.Get();
}
inline void ConfigSupport::_internal_set_report_a_problem_link(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  report_a_problem_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_report_a_problem_link() {
  _has_bits_[0] |= 0x00000010u;
  return report_a_problem_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_report_a_problem_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.report_a_problem_link)
  if (!_internal_has_report_a_problem_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = report_a_problem_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (report_a_problem_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    report_a_problem_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_report_a_problem_link(std::string* report_a_problem_link) {
  if (report_a_problem_link != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  report_a_problem_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), report_a_problem_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (report_a_problem_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    report_a_problem_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.report_a_problem_link)
}

// optional string forgot_password_link = 6 [json_name = "forgotPasswordLink"];
inline bool ConfigSupport::_internal_has_forgot_password_link() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigSupport::has_forgot_password_link() const {
  return _internal_has_forgot_password_link();
}
inline void ConfigSupport::clear_forgot_password_link() {
  forgot_password_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConfigSupport::forgot_password_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.forgot_password_link)
  return _internal_forgot_password_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_forgot_password_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 forgot_password_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.forgot_password_link)
}
inline std::string* ConfigSupport::mutable_forgot_password_link() {
  std::string* _s = _internal_mutable_forgot_password_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.forgot_password_link)
  return _s;
}
inline const std::string& ConfigSupport::_internal_forgot_password_link() const {
  return forgot_password_link_.Get();
}
inline void ConfigSupport::_internal_set_forgot_password_link(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  forgot_password_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_forgot_password_link() {
  _has_bits_[0] |= 0x00000020u;
  return forgot_password_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_forgot_password_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.forgot_password_link)
  if (!_internal_has_forgot_password_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = forgot_password_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (forgot_password_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    forgot_password_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_forgot_password_link(std::string* forgot_password_link) {
  if (forgot_password_link != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  forgot_password_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), forgot_password_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (forgot_password_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    forgot_password_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.forgot_password_link)
}

// optional string support_email = 7 [json_name = "supportEmail"];
inline bool ConfigSupport::_internal_has_support_email() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigSupport::has_support_email() const {
  return _internal_has_support_email();
}
inline void ConfigSupport::clear_support_email() {
  support_email_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConfigSupport::support_email() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSupport.support_email)
  return _internal_support_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSupport::set_support_email(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 support_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSupport.support_email)
}
inline std::string* ConfigSupport::mutable_support_email() {
  std::string* _s = _internal_mutable_support_email();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSupport.support_email)
  return _s;
}
inline const std::string& ConfigSupport::_internal_support_email() const {
  return support_email_.Get();
}
inline void ConfigSupport::_internal_set_support_email(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  support_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSupport::_internal_mutable_support_email() {
  _has_bits_[0] |= 0x00000040u;
  return support_email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSupport::release_support_email() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSupport.support_email)
  if (!_internal_has_support_email()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = support_email_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (support_email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    support_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSupport::set_allocated_support_email(std::string* support_email) {
  if (support_email != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  support_email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), support_email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (support_email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    support_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSupport.support_email)
}

// -------------------------------------------------------------------

// ConfigLocalization

// optional string default_server_locale = 1 [json_name = "defaultServerLocale"];
inline bool ConfigLocalization::_internal_has_default_server_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigLocalization::has_default_server_locale() const {
  return _internal_has_default_server_locale();
}
inline void ConfigLocalization::clear_default_server_locale() {
  default_server_locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigLocalization::default_server_locale() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLocalization.default_server_locale)
  return _internal_default_server_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLocalization::set_default_server_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 default_server_locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLocalization.default_server_locale)
}
inline std::string* ConfigLocalization::mutable_default_server_locale() {
  std::string* _s = _internal_mutable_default_server_locale();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLocalization.default_server_locale)
  return _s;
}
inline const std::string& ConfigLocalization::_internal_default_server_locale() const {
  return default_server_locale_.Get();
}
inline void ConfigLocalization::_internal_set_default_server_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  default_server_locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLocalization::_internal_mutable_default_server_locale() {
  _has_bits_[0] |= 0x00000001u;
  return default_server_locale_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLocalization::release_default_server_locale() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLocalization.default_server_locale)
  if (!_internal_has_default_server_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = default_server_locale_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_server_locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    default_server_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLocalization::set_allocated_default_server_locale(std::string* default_server_locale) {
  if (default_server_locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  default_server_locale_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_server_locale,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_server_locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    default_server_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLocalization.default_server_locale)
}

// optional string default_client_locale = 2 [json_name = "defaultClientLocale"];
inline bool ConfigLocalization::_internal_has_default_client_locale() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigLocalization::has_default_client_locale() const {
  return _internal_has_default_client_locale();
}
inline void ConfigLocalization::clear_default_client_locale() {
  default_client_locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigLocalization::default_client_locale() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLocalization.default_client_locale)
  return _internal_default_client_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLocalization::set_default_client_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 default_client_locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLocalization.default_client_locale)
}
inline std::string* ConfigLocalization::mutable_default_client_locale() {
  std::string* _s = _internal_mutable_default_client_locale();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLocalization.default_client_locale)
  return _s;
}
inline const std::string& ConfigLocalization::_internal_default_client_locale() const {
  return default_client_locale_.Get();
}
inline void ConfigLocalization::_internal_set_default_client_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  default_client_locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLocalization::_internal_mutable_default_client_locale() {
  _has_bits_[0] |= 0x00000002u;
  return default_client_locale_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLocalization::release_default_client_locale() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLocalization.default_client_locale)
  if (!_internal_has_default_client_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = default_client_locale_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_client_locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    default_client_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLocalization::set_allocated_default_client_locale(std::string* default_client_locale) {
  if (default_client_locale != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  default_client_locale_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), default_client_locale,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_client_locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    default_client_locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLocalization.default_client_locale)
}

// optional string available_locales = 3 [json_name = "availableLocales"];
inline bool ConfigLocalization::_internal_has_available_locales() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigLocalization::has_available_locales() const {
  return _internal_has_available_locales();
}
inline void ConfigLocalization::clear_available_locales() {
  available_locales_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigLocalization::available_locales() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLocalization.available_locales)
  return _internal_available_locales();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLocalization::set_available_locales(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 available_locales_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLocalization.available_locales)
}
inline std::string* ConfigLocalization::mutable_available_locales() {
  std::string* _s = _internal_mutable_available_locales();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLocalization.available_locales)
  return _s;
}
inline const std::string& ConfigLocalization::_internal_available_locales() const {
  return available_locales_.Get();
}
inline void ConfigLocalization::_internal_set_available_locales(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  available_locales_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLocalization::_internal_mutable_available_locales() {
  _has_bits_[0] |= 0x00000004u;
  return available_locales_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLocalization::release_available_locales() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLocalization.available_locales)
  if (!_internal_has_available_locales()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = available_locales_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (available_locales_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    available_locales_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLocalization::set_allocated_available_locales(std::string* available_locales) {
  if (available_locales != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  available_locales_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), available_locales,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (available_locales_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    available_locales_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLocalization.available_locales)
}

// -------------------------------------------------------------------

// ConfigLdap

// optional bool enable = 1 [json_name = "enable"];
inline bool ConfigLdap::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_enable() const {
  return _internal_has_enable();
}
inline void ConfigLdap::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool ConfigLdap::_internal_enable() const {
  return enable_;
}
inline bool ConfigLdap::enable() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.enable)
  return _internal_enable();
}
inline void ConfigLdap::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x01000000u;
  enable_ = value;
}
inline void ConfigLdap::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.enable)
}

// optional bool enable_sync = 2 [json_name = "enableSync"];
inline bool ConfigLdap::_internal_has_enable_sync() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_enable_sync() const {
  return _internal_has_enable_sync();
}
inline void ConfigLdap::clear_enable_sync() {
  enable_sync_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool ConfigLdap::_internal_enable_sync() const {
  return enable_sync_;
}
inline bool ConfigLdap::enable_sync() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.enable_sync)
  return _internal_enable_sync();
}
inline void ConfigLdap::_internal_set_enable_sync(bool value) {
  _has_bits_[0] |= 0x02000000u;
  enable_sync_ = value;
}
inline void ConfigLdap::set_enable_sync(bool value) {
  _internal_set_enable_sync(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.enable_sync)
}

// optional string ldap_server = 3 [json_name = "ldapServer"];
inline bool ConfigLdap::_internal_has_ldap_server() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigLdap::has_ldap_server() const {
  return _internal_has_ldap_server();
}
inline void ConfigLdap::clear_ldap_server() {
  ldap_server_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigLdap::ldap_server() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.ldap_server)
  return _internal_ldap_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_ldap_server(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ldap_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.ldap_server)
}
inline std::string* ConfigLdap::mutable_ldap_server() {
  std::string* _s = _internal_mutable_ldap_server();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.ldap_server)
  return _s;
}
inline const std::string& ConfigLdap::_internal_ldap_server() const {
  return ldap_server_.Get();
}
inline void ConfigLdap::_internal_set_ldap_server(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ldap_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_ldap_server() {
  _has_bits_[0] |= 0x00000001u;
  return ldap_server_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_ldap_server() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.ldap_server)
  if (!_internal_has_ldap_server()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ldap_server_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ldap_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ldap_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_ldap_server(std::string* ldap_server) {
  if (ldap_server != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ldap_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ldap_server,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ldap_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ldap_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.ldap_server)
}

// optional int32 ldap_port = 4 [json_name = "ldapPort"];
inline bool ConfigLdap::_internal_has_ldap_port() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool ConfigLdap::has_ldap_port() const {
  return _internal_has_ldap_port();
}
inline void ConfigLdap::clear_ldap_port() {
  ldap_port_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline int32_t ConfigLdap::_internal_ldap_port() const {
  return ldap_port_;
}
inline int32_t ConfigLdap::ldap_port() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.ldap_port)
  return _internal_ldap_port();
}
inline void ConfigLdap::_internal_set_ldap_port(int32_t value) {
  _has_bits_[0] |= 0x00800000u;
  ldap_port_ = value;
}
inline void ConfigLdap::set_ldap_port(int32_t value) {
  _internal_set_ldap_port(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.ldap_port)
}

// optional string connection_security = 5 [json_name = "connectionSecurity"];
inline bool ConfigLdap::_internal_has_connection_security() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigLdap::has_connection_security() const {
  return _internal_has_connection_security();
}
inline void ConfigLdap::clear_connection_security() {
  connection_security_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigLdap::connection_security() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.connection_security)
  return _internal_connection_security();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_connection_security(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 connection_security_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.connection_security)
}
inline std::string* ConfigLdap::mutable_connection_security() {
  std::string* _s = _internal_mutable_connection_security();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.connection_security)
  return _s;
}
inline const std::string& ConfigLdap::_internal_connection_security() const {
  return connection_security_.Get();
}
inline void ConfigLdap::_internal_set_connection_security(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  connection_security_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_connection_security() {
  _has_bits_[0] |= 0x00000002u;
  return connection_security_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_connection_security() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.connection_security)
  if (!_internal_has_connection_security()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = connection_security_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connection_security_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connection_security_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_connection_security(std::string* connection_security) {
  if (connection_security != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  connection_security_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), connection_security,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (connection_security_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    connection_security_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.connection_security)
}

// optional string base_dn = 6 [json_name = "baseDn"];
inline bool ConfigLdap::_internal_has_base_dn() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigLdap::has_base_dn() const {
  return _internal_has_base_dn();
}
inline void ConfigLdap::clear_base_dn() {
  base_dn_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigLdap::base_dn() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.base_dn)
  return _internal_base_dn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_base_dn(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 base_dn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.base_dn)
}
inline std::string* ConfigLdap::mutable_base_dn() {
  std::string* _s = _internal_mutable_base_dn();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.base_dn)
  return _s;
}
inline const std::string& ConfigLdap::_internal_base_dn() const {
  return base_dn_.Get();
}
inline void ConfigLdap::_internal_set_base_dn(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  base_dn_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_base_dn() {
  _has_bits_[0] |= 0x00000004u;
  return base_dn_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_base_dn() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.base_dn)
  if (!_internal_has_base_dn()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = base_dn_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (base_dn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    base_dn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_base_dn(std::string* base_dn) {
  if (base_dn != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  base_dn_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), base_dn,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (base_dn_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    base_dn_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.base_dn)
}

// optional string bind_username = 7 [json_name = "bindUsername"];
inline bool ConfigLdap::_internal_has_bind_username() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigLdap::has_bind_username() const {
  return _internal_has_bind_username();
}
inline void ConfigLdap::clear_bind_username() {
  bind_username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigLdap::bind_username() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.bind_username)
  return _internal_bind_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_bind_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 bind_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.bind_username)
}
inline std::string* ConfigLdap::mutable_bind_username() {
  std::string* _s = _internal_mutable_bind_username();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.bind_username)
  return _s;
}
inline const std::string& ConfigLdap::_internal_bind_username() const {
  return bind_username_.Get();
}
inline void ConfigLdap::_internal_set_bind_username(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  bind_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_bind_username() {
  _has_bits_[0] |= 0x00000008u;
  return bind_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_bind_username() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.bind_username)
  if (!_internal_has_bind_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = bind_username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bind_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bind_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_bind_username(std::string* bind_username) {
  if (bind_username != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  bind_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bind_username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bind_username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bind_username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.bind_username)
}

// optional string bind_password = 8 [json_name = "bindPassword"];
inline bool ConfigLdap::_internal_has_bind_password() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigLdap::has_bind_password() const {
  return _internal_has_bind_password();
}
inline void ConfigLdap::clear_bind_password() {
  bind_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigLdap::bind_password() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.bind_password)
  return _internal_bind_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_bind_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 bind_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.bind_password)
}
inline std::string* ConfigLdap::mutable_bind_password() {
  std::string* _s = _internal_mutable_bind_password();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.bind_password)
  return _s;
}
inline const std::string& ConfigLdap::_internal_bind_password() const {
  return bind_password_.Get();
}
inline void ConfigLdap::_internal_set_bind_password(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  bind_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_bind_password() {
  _has_bits_[0] |= 0x00000010u;
  return bind_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_bind_password() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.bind_password)
  if (!_internal_has_bind_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = bind_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bind_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bind_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_bind_password(std::string* bind_password) {
  if (bind_password != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  bind_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bind_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (bind_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    bind_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.bind_password)
}

// optional int32 maximum_login_attempts = 9 [json_name = "maximumLoginAttempts"];
inline bool ConfigLdap::_internal_has_maximum_login_attempts() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_maximum_login_attempts() const {
  return _internal_has_maximum_login_attempts();
}
inline void ConfigLdap::clear_maximum_login_attempts() {
  maximum_login_attempts_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline int32_t ConfigLdap::_internal_maximum_login_attempts() const {
  return maximum_login_attempts_;
}
inline int32_t ConfigLdap::maximum_login_attempts() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.maximum_login_attempts)
  return _internal_maximum_login_attempts();
}
inline void ConfigLdap::_internal_set_maximum_login_attempts(int32_t value) {
  _has_bits_[0] |= 0x08000000u;
  maximum_login_attempts_ = value;
}
inline void ConfigLdap::set_maximum_login_attempts(int32_t value) {
  _internal_set_maximum_login_attempts(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.maximum_login_attempts)
}

// optional string user_filter = 10 [json_name = "userFilter"];
inline bool ConfigLdap::_internal_has_user_filter() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigLdap::has_user_filter() const {
  return _internal_has_user_filter();
}
inline void ConfigLdap::clear_user_filter() {
  user_filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConfigLdap::user_filter() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.user_filter)
  return _internal_user_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_user_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 user_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.user_filter)
}
inline std::string* ConfigLdap::mutable_user_filter() {
  std::string* _s = _internal_mutable_user_filter();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.user_filter)
  return _s;
}
inline const std::string& ConfigLdap::_internal_user_filter() const {
  return user_filter_.Get();
}
inline void ConfigLdap::_internal_set_user_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  user_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_user_filter() {
  _has_bits_[0] |= 0x00000020u;
  return user_filter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_user_filter() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.user_filter)
  if (!_internal_has_user_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = user_filter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_user_filter(std::string* user_filter) {
  if (user_filter != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  user_filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_filter,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.user_filter)
}

// optional string group_filter = 11 [json_name = "groupFilter"];
inline bool ConfigLdap::_internal_has_group_filter() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigLdap::has_group_filter() const {
  return _internal_has_group_filter();
}
inline void ConfigLdap::clear_group_filter() {
  group_filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConfigLdap::group_filter() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.group_filter)
  return _internal_group_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_group_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 group_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.group_filter)
}
inline std::string* ConfigLdap::mutable_group_filter() {
  std::string* _s = _internal_mutable_group_filter();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.group_filter)
  return _s;
}
inline const std::string& ConfigLdap::_internal_group_filter() const {
  return group_filter_.Get();
}
inline void ConfigLdap::_internal_set_group_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  group_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_group_filter() {
  _has_bits_[0] |= 0x00000040u;
  return group_filter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_group_filter() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.group_filter)
  if (!_internal_has_group_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = group_filter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_group_filter(std::string* group_filter) {
  if (group_filter != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  group_filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_filter,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.group_filter)
}

// optional bool enable_admin_filter = 12 [json_name = "enableAdminFilter"];
inline bool ConfigLdap::_internal_has_enable_admin_filter() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_enable_admin_filter() const {
  return _internal_has_enable_admin_filter();
}
inline void ConfigLdap::clear_enable_admin_filter() {
  enable_admin_filter_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool ConfigLdap::_internal_enable_admin_filter() const {
  return enable_admin_filter_;
}
inline bool ConfigLdap::enable_admin_filter() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.enable_admin_filter)
  return _internal_enable_admin_filter();
}
inline void ConfigLdap::_internal_set_enable_admin_filter(bool value) {
  _has_bits_[0] |= 0x04000000u;
  enable_admin_filter_ = value;
}
inline void ConfigLdap::set_enable_admin_filter(bool value) {
  _internal_set_enable_admin_filter(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.enable_admin_filter)
}

// optional string admin_filter = 13 [json_name = "adminFilter"];
inline bool ConfigLdap::_internal_has_admin_filter() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigLdap::has_admin_filter() const {
  return _internal_has_admin_filter();
}
inline void ConfigLdap::clear_admin_filter() {
  admin_filter_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ConfigLdap::admin_filter() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.admin_filter)
  return _internal_admin_filter();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_admin_filter(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 admin_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.admin_filter)
}
inline std::string* ConfigLdap::mutable_admin_filter() {
  std::string* _s = _internal_mutable_admin_filter();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.admin_filter)
  return _s;
}
inline const std::string& ConfigLdap::_internal_admin_filter() const {
  return admin_filter_.Get();
}
inline void ConfigLdap::_internal_set_admin_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  admin_filter_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_admin_filter() {
  _has_bits_[0] |= 0x00000080u;
  return admin_filter_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_admin_filter() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.admin_filter)
  if (!_internal_has_admin_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = admin_filter_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (admin_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    admin_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_admin_filter(std::string* admin_filter) {
  if (admin_filter != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  admin_filter_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), admin_filter,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (admin_filter_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    admin_filter_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.admin_filter)
}

// optional string group_display_name_attribute = 14 [json_name = "groupDisplayNameAttribute"];
inline bool ConfigLdap::_internal_has_group_display_name_attribute() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigLdap::has_group_display_name_attribute() const {
  return _internal_has_group_display_name_attribute();
}
inline void ConfigLdap::clear_group_display_name_attribute() {
  group_display_name_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ConfigLdap::group_display_name_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.group_display_name_attribute)
  return _internal_group_display_name_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_group_display_name_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 group_display_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.group_display_name_attribute)
}
inline std::string* ConfigLdap::mutable_group_display_name_attribute() {
  std::string* _s = _internal_mutable_group_display_name_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.group_display_name_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_group_display_name_attribute() const {
  return group_display_name_attribute_.Get();
}
inline void ConfigLdap::_internal_set_group_display_name_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  group_display_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_group_display_name_attribute() {
  _has_bits_[0] |= 0x00000100u;
  return group_display_name_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_group_display_name_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.group_display_name_attribute)
  if (!_internal_has_group_display_name_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = group_display_name_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_display_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_display_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_group_display_name_attribute(std::string* group_display_name_attribute) {
  if (group_display_name_attribute != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  group_display_name_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_display_name_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_display_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_display_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.group_display_name_attribute)
}

// optional string group_id_attribute = 15 [json_name = "groupIdAttribute"];
inline bool ConfigLdap::_internal_has_group_id_attribute() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigLdap::has_group_id_attribute() const {
  return _internal_has_group_id_attribute();
}
inline void ConfigLdap::clear_group_id_attribute() {
  group_id_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ConfigLdap::group_id_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.group_id_attribute)
  return _internal_group_id_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_group_id_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 group_id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.group_id_attribute)
}
inline std::string* ConfigLdap::mutable_group_id_attribute() {
  std::string* _s = _internal_mutable_group_id_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.group_id_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_group_id_attribute() const {
  return group_id_attribute_.Get();
}
inline void ConfigLdap::_internal_set_group_id_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  group_id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_group_id_attribute() {
  _has_bits_[0] |= 0x00000200u;
  return group_id_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_group_id_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.group_id_attribute)
  if (!_internal_has_group_id_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = group_id_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_group_id_attribute(std::string* group_id_attribute) {
  if (group_id_attribute != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  group_id_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), group_id_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (group_id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    group_id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.group_id_attribute)
}

// optional string first_name_attribute = 16 [json_name = "firstNameAttribute"];
inline bool ConfigLdap::_internal_has_first_name_attribute() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ConfigLdap::has_first_name_attribute() const {
  return _internal_has_first_name_attribute();
}
inline void ConfigLdap::clear_first_name_attribute() {
  first_name_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ConfigLdap::first_name_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.first_name_attribute)
  return _internal_first_name_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_first_name_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 first_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.first_name_attribute)
}
inline std::string* ConfigLdap::mutable_first_name_attribute() {
  std::string* _s = _internal_mutable_first_name_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.first_name_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_first_name_attribute() const {
  return first_name_attribute_.Get();
}
inline void ConfigLdap::_internal_set_first_name_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  first_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_first_name_attribute() {
  _has_bits_[0] |= 0x00000400u;
  return first_name_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_first_name_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.first_name_attribute)
  if (!_internal_has_first_name_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = first_name_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_first_name_attribute(std::string* first_name_attribute) {
  if (first_name_attribute != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  first_name_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.first_name_attribute)
}

// optional string last_name_attribute = 17 [json_name = "lastNameAttribute"];
inline bool ConfigLdap::_internal_has_last_name_attribute() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ConfigLdap::has_last_name_attribute() const {
  return _internal_has_last_name_attribute();
}
inline void ConfigLdap::clear_last_name_attribute() {
  last_name_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ConfigLdap::last_name_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.last_name_attribute)
  return _internal_last_name_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_last_name_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 last_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.last_name_attribute)
}
inline std::string* ConfigLdap::mutable_last_name_attribute() {
  std::string* _s = _internal_mutable_last_name_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.last_name_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_last_name_attribute() const {
  return last_name_attribute_.Get();
}
inline void ConfigLdap::_internal_set_last_name_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  last_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_last_name_attribute() {
  _has_bits_[0] |= 0x00000800u;
  return last_name_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_last_name_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.last_name_attribute)
  if (!_internal_has_last_name_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = last_name_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_last_name_attribute(std::string* last_name_attribute) {
  if (last_name_attribute != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  last_name_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_name_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.last_name_attribute)
}

// optional string email_attribute = 18 [json_name = "emailAttribute"];
inline bool ConfigLdap::_internal_has_email_attribute() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ConfigLdap::has_email_attribute() const {
  return _internal_has_email_attribute();
}
inline void ConfigLdap::clear_email_attribute() {
  email_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ConfigLdap::email_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.email_attribute)
  return _internal_email_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_email_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 email_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.email_attribute)
}
inline std::string* ConfigLdap::mutable_email_attribute() {
  std::string* _s = _internal_mutable_email_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.email_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_email_attribute() const {
  return email_attribute_.Get();
}
inline void ConfigLdap::_internal_set_email_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  email_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_email_attribute() {
  _has_bits_[0] |= 0x00001000u;
  return email_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_email_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.email_attribute)
  if (!_internal_has_email_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = email_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_email_attribute(std::string* email_attribute) {
  if (email_attribute != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  email_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.email_attribute)
}

// optional string username_attribute = 19 [json_name = "usernameAttribute"];
inline bool ConfigLdap::_internal_has_username_attribute() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ConfigLdap::has_username_attribute() const {
  return _internal_has_username_attribute();
}
inline void ConfigLdap::clear_username_attribute() {
  username_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& ConfigLdap::username_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.username_attribute)
  return _internal_username_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_username_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 username_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.username_attribute)
}
inline std::string* ConfigLdap::mutable_username_attribute() {
  std::string* _s = _internal_mutable_username_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.username_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_username_attribute() const {
  return username_attribute_.Get();
}
inline void ConfigLdap::_internal_set_username_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  username_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_username_attribute() {
  _has_bits_[0] |= 0x00002000u;
  return username_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_username_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.username_attribute)
  if (!_internal_has_username_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = username_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_username_attribute(std::string* username_attribute) {
  if (username_attribute != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  username_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.username_attribute)
}

// optional string nickname_attribute = 20 [json_name = "nicknameAttribute"];
inline bool ConfigLdap::_internal_has_nickname_attribute() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ConfigLdap::has_nickname_attribute() const {
  return _internal_has_nickname_attribute();
}
inline void ConfigLdap::clear_nickname_attribute() {
  nickname_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& ConfigLdap::nickname_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.nickname_attribute)
  return _internal_nickname_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_nickname_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 nickname_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.nickname_attribute)
}
inline std::string* ConfigLdap::mutable_nickname_attribute() {
  std::string* _s = _internal_mutable_nickname_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.nickname_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_nickname_attribute() const {
  return nickname_attribute_.Get();
}
inline void ConfigLdap::_internal_set_nickname_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  nickname_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_nickname_attribute() {
  _has_bits_[0] |= 0x00004000u;
  return nickname_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_nickname_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.nickname_attribute)
  if (!_internal_has_nickname_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  auto* p = nickname_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_nickname_attribute(std::string* nickname_attribute) {
  if (nickname_attribute != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  nickname_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.nickname_attribute)
}

// optional string id_attribute = 21 [json_name = "idAttribute"];
inline bool ConfigLdap::_internal_has_id_attribute() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ConfigLdap::has_id_attribute() const {
  return _internal_has_id_attribute();
}
inline void ConfigLdap::clear_id_attribute() {
  id_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& ConfigLdap::id_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.id_attribute)
  return _internal_id_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_id_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.id_attribute)
}
inline std::string* ConfigLdap::mutable_id_attribute() {
  std::string* _s = _internal_mutable_id_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.id_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_id_attribute() const {
  return id_attribute_.Get();
}
inline void ConfigLdap::_internal_set_id_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_id_attribute() {
  _has_bits_[0] |= 0x00008000u;
  return id_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_id_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.id_attribute)
  if (!_internal_has_id_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  auto* p = id_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_id_attribute(std::string* id_attribute) {
  if (id_attribute != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  id_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.id_attribute)
}

// optional string position_attribute = 22 [json_name = "positionAttribute"];
inline bool ConfigLdap::_internal_has_position_attribute() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ConfigLdap::has_position_attribute() const {
  return _internal_has_position_attribute();
}
inline void ConfigLdap::clear_position_attribute() {
  position_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& ConfigLdap::position_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.position_attribute)
  return _internal_position_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_position_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 position_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.position_attribute)
}
inline std::string* ConfigLdap::mutable_position_attribute() {
  std::string* _s = _internal_mutable_position_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.position_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_position_attribute() const {
  return position_attribute_.Get();
}
inline void ConfigLdap::_internal_set_position_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  position_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_position_attribute() {
  _has_bits_[0] |= 0x00010000u;
  return position_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_position_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.position_attribute)
  if (!_internal_has_position_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  auto* p = position_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (position_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    position_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_position_attribute(std::string* position_attribute) {
  if (position_attribute != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  position_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), position_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (position_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    position_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.position_attribute)
}

// optional string login_id_attribute = 23 [json_name = "loginIdAttribute"];
inline bool ConfigLdap::_internal_has_login_id_attribute() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ConfigLdap::has_login_id_attribute() const {
  return _internal_has_login_id_attribute();
}
inline void ConfigLdap::clear_login_id_attribute() {
  login_id_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& ConfigLdap::login_id_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.login_id_attribute)
  return _internal_login_id_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_login_id_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00020000u;
 login_id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.login_id_attribute)
}
inline std::string* ConfigLdap::mutable_login_id_attribute() {
  std::string* _s = _internal_mutable_login_id_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.login_id_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_login_id_attribute() const {
  return login_id_attribute_.Get();
}
inline void ConfigLdap::_internal_set_login_id_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  login_id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_login_id_attribute() {
  _has_bits_[0] |= 0x00020000u;
  return login_id_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_login_id_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.login_id_attribute)
  if (!_internal_has_login_id_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  auto* p = login_id_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_login_id_attribute(std::string* login_id_attribute) {
  if (login_id_attribute != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  login_id_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_id_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.login_id_attribute)
}

// optional string picture_attribute = 24 [json_name = "pictureAttribute"];
inline bool ConfigLdap::_internal_has_picture_attribute() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ConfigLdap::has_picture_attribute() const {
  return _internal_has_picture_attribute();
}
inline void ConfigLdap::clear_picture_attribute() {
  picture_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& ConfigLdap::picture_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.picture_attribute)
  return _internal_picture_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_picture_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00040000u;
 picture_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.picture_attribute)
}
inline std::string* ConfigLdap::mutable_picture_attribute() {
  std::string* _s = _internal_mutable_picture_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.picture_attribute)
  return _s;
}
inline const std::string& ConfigLdap::_internal_picture_attribute() const {
  return picture_attribute_.Get();
}
inline void ConfigLdap::_internal_set_picture_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  picture_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_picture_attribute() {
  _has_bits_[0] |= 0x00040000u;
  return picture_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_picture_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.picture_attribute)
  if (!_internal_has_picture_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  auto* p = picture_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (picture_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    picture_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_picture_attribute(std::string* picture_attribute) {
  if (picture_attribute != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  picture_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), picture_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (picture_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    picture_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.picture_attribute)
}

// optional int32 sync_interval_minutes = 25 [json_name = "syncIntervalMinutes"];
inline bool ConfigLdap::_internal_has_sync_interval_minutes() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_sync_interval_minutes() const {
  return _internal_has_sync_interval_minutes();
}
inline void ConfigLdap::clear_sync_interval_minutes() {
  sync_interval_minutes_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline int32_t ConfigLdap::_internal_sync_interval_minutes() const {
  return sync_interval_minutes_;
}
inline int32_t ConfigLdap::sync_interval_minutes() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.sync_interval_minutes)
  return _internal_sync_interval_minutes();
}
inline void ConfigLdap::_internal_set_sync_interval_minutes(int32_t value) {
  _has_bits_[0] |= 0x10000000u;
  sync_interval_minutes_ = value;
}
inline void ConfigLdap::set_sync_interval_minutes(int32_t value) {
  _internal_set_sync_interval_minutes(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.sync_interval_minutes)
}

// optional int32 query_timeout = 26 [json_name = "queryTimeout"];
inline bool ConfigLdap::_internal_has_query_timeout() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_query_timeout() const {
  return _internal_has_query_timeout();
}
inline void ConfigLdap::clear_query_timeout() {
  query_timeout_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline int32_t ConfigLdap::_internal_query_timeout() const {
  return query_timeout_;
}
inline int32_t ConfigLdap::query_timeout() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.query_timeout)
  return _internal_query_timeout();
}
inline void ConfigLdap::_internal_set_query_timeout(int32_t value) {
  _has_bits_[0] |= 0x20000000u;
  query_timeout_ = value;
}
inline void ConfigLdap::set_query_timeout(int32_t value) {
  _internal_set_query_timeout(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.query_timeout)
}

// optional int32 max_page_size = 27 [json_name = "maxPageSize"];
inline bool ConfigLdap::_internal_has_max_page_size() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool ConfigLdap::has_max_page_size() const {
  return _internal_has_max_page_size();
}
inline void ConfigLdap::clear_max_page_size() {
  max_page_size_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline int32_t ConfigLdap::_internal_max_page_size() const {
  return max_page_size_;
}
inline int32_t ConfigLdap::max_page_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.max_page_size)
  return _internal_max_page_size();
}
inline void ConfigLdap::_internal_set_max_page_size(int32_t value) {
  _has_bits_[0] |= 0x40000000u;
  max_page_size_ = value;
}
inline void ConfigLdap::set_max_page_size(int32_t value) {
  _internal_set_max_page_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.max_page_size)
}

// optional string login_field_name = 28 [json_name = "loginFieldName"];
inline bool ConfigLdap::_internal_has_login_field_name() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ConfigLdap::has_login_field_name() const {
  return _internal_has_login_field_name();
}
inline void ConfigLdap::clear_login_field_name() {
  login_field_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& ConfigLdap::login_field_name() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.login_field_name)
  return _internal_login_field_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_login_field_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00080000u;
 login_field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.login_field_name)
}
inline std::string* ConfigLdap::mutable_login_field_name() {
  std::string* _s = _internal_mutable_login_field_name();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.login_field_name)
  return _s;
}
inline const std::string& ConfigLdap::_internal_login_field_name() const {
  return login_field_name_.Get();
}
inline void ConfigLdap::_internal_set_login_field_name(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  login_field_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_login_field_name() {
  _has_bits_[0] |= 0x00080000u;
  return login_field_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_login_field_name() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.login_field_name)
  if (!_internal_has_login_field_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  auto* p = login_field_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_field_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_field_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_login_field_name(std::string* login_field_name) {
  if (login_field_name != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  login_field_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_field_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_field_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_field_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.login_field_name)
}

// optional string login_button_color = 29 [json_name = "loginButtonColor"];
inline bool ConfigLdap::_internal_has_login_button_color() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ConfigLdap::has_login_button_color() const {
  return _internal_has_login_button_color();
}
inline void ConfigLdap::clear_login_button_color() {
  login_button_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00100000u;
}
inline const std::string& ConfigLdap::login_button_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.login_button_color)
  return _internal_login_button_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_login_button_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00100000u;
 login_button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.login_button_color)
}
inline std::string* ConfigLdap::mutable_login_button_color() {
  std::string* _s = _internal_mutable_login_button_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.login_button_color)
  return _s;
}
inline const std::string& ConfigLdap::_internal_login_button_color() const {
  return login_button_color_.Get();
}
inline void ConfigLdap::_internal_set_login_button_color(const std::string& value) {
  _has_bits_[0] |= 0x00100000u;
  login_button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_login_button_color() {
  _has_bits_[0] |= 0x00100000u;
  return login_button_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_login_button_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.login_button_color)
  if (!_internal_has_login_button_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00100000u;
  auto* p = login_button_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_login_button_color(std::string* login_button_color) {
  if (login_button_color != nullptr) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  login_button_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.login_button_color)
}

// optional string login_button_border_color = 30 [json_name = "loginButtonBorderColor"];
inline bool ConfigLdap::_internal_has_login_button_border_color() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ConfigLdap::has_login_button_border_color() const {
  return _internal_has_login_button_border_color();
}
inline void ConfigLdap::clear_login_button_border_color() {
  login_button_border_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00200000u;
}
inline const std::string& ConfigLdap::login_button_border_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.login_button_border_color)
  return _internal_login_button_border_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_login_button_border_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00200000u;
 login_button_border_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.login_button_border_color)
}
inline std::string* ConfigLdap::mutable_login_button_border_color() {
  std::string* _s = _internal_mutable_login_button_border_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.login_button_border_color)
  return _s;
}
inline const std::string& ConfigLdap::_internal_login_button_border_color() const {
  return login_button_border_color_.Get();
}
inline void ConfigLdap::_internal_set_login_button_border_color(const std::string& value) {
  _has_bits_[0] |= 0x00200000u;
  login_button_border_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_login_button_border_color() {
  _has_bits_[0] |= 0x00200000u;
  return login_button_border_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_login_button_border_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.login_button_border_color)
  if (!_internal_has_login_button_border_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00200000u;
  auto* p = login_button_border_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_border_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_border_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_login_button_border_color(std::string* login_button_border_color) {
  if (login_button_border_color != nullptr) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  login_button_border_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_border_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_border_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_border_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.login_button_border_color)
}

// optional string login_button_text_color = 31 [json_name = "loginButtonTextColor"];
inline bool ConfigLdap::_internal_has_login_button_text_color() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ConfigLdap::has_login_button_text_color() const {
  return _internal_has_login_button_text_color();
}
inline void ConfigLdap::clear_login_button_text_color() {
  login_button_text_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00400000u;
}
inline const std::string& ConfigLdap::login_button_text_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigLdap.login_button_text_color)
  return _internal_login_button_text_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigLdap::set_login_button_text_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00400000u;
 login_button_text_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigLdap.login_button_text_color)
}
inline std::string* ConfigLdap::mutable_login_button_text_color() {
  std::string* _s = _internal_mutable_login_button_text_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigLdap.login_button_text_color)
  return _s;
}
inline const std::string& ConfigLdap::_internal_login_button_text_color() const {
  return login_button_text_color_.Get();
}
inline void ConfigLdap::_internal_set_login_button_text_color(const std::string& value) {
  _has_bits_[0] |= 0x00400000u;
  login_button_text_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigLdap::_internal_mutable_login_button_text_color() {
  _has_bits_[0] |= 0x00400000u;
  return login_button_text_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigLdap::release_login_button_text_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigLdap.login_button_text_color)
  if (!_internal_has_login_button_text_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00400000u;
  auto* p = login_button_text_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigLdap::set_allocated_login_button_text_color(std::string* login_button_text_color) {
  if (login_button_text_color != nullptr) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  login_button_text_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_text_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigLdap.login_button_text_color)
}

// -------------------------------------------------------------------

// ConfigSaml

// optional bool enable = 1 [json_name = "enable"];
inline bool ConfigSaml::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_enable() const {
  return _internal_has_enable();
}
inline void ConfigSaml::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool ConfigSaml::_internal_enable() const {
  return enable_;
}
inline bool ConfigSaml::enable() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.enable)
  return _internal_enable();
}
inline void ConfigSaml::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x02000000u;
  enable_ = value;
}
inline void ConfigSaml::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.enable)
}

// optional bool enable_sync_with_ldap = 2 [json_name = "enableSyncWithLdap"];
inline bool ConfigSaml::_internal_has_enable_sync_with_ldap() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_enable_sync_with_ldap() const {
  return _internal_has_enable_sync_with_ldap();
}
inline void ConfigSaml::clear_enable_sync_with_ldap() {
  enable_sync_with_ldap_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool ConfigSaml::_internal_enable_sync_with_ldap() const {
  return enable_sync_with_ldap_;
}
inline bool ConfigSaml::enable_sync_with_ldap() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.enable_sync_with_ldap)
  return _internal_enable_sync_with_ldap();
}
inline void ConfigSaml::_internal_set_enable_sync_with_ldap(bool value) {
  _has_bits_[0] |= 0x04000000u;
  enable_sync_with_ldap_ = value;
}
inline void ConfigSaml::set_enable_sync_with_ldap(bool value) {
  _internal_set_enable_sync_with_ldap(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.enable_sync_with_ldap)
}

// optional bool enable_sync_with_ldap_include_auth = 3 [json_name = "enableSyncWithLdapIncludeAuth"];
inline bool ConfigSaml::_internal_has_enable_sync_with_ldap_include_auth() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_enable_sync_with_ldap_include_auth() const {
  return _internal_has_enable_sync_with_ldap_include_auth();
}
inline void ConfigSaml::clear_enable_sync_with_ldap_include_auth() {
  enable_sync_with_ldap_include_auth_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool ConfigSaml::_internal_enable_sync_with_ldap_include_auth() const {
  return enable_sync_with_ldap_include_auth_;
}
inline bool ConfigSaml::enable_sync_with_ldap_include_auth() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.enable_sync_with_ldap_include_auth)
  return _internal_enable_sync_with_ldap_include_auth();
}
inline void ConfigSaml::_internal_set_enable_sync_with_ldap_include_auth(bool value) {
  _has_bits_[0] |= 0x08000000u;
  enable_sync_with_ldap_include_auth_ = value;
}
inline void ConfigSaml::set_enable_sync_with_ldap_include_auth(bool value) {
  _internal_set_enable_sync_with_ldap_include_auth(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.enable_sync_with_ldap_include_auth)
}

// optional bool ignore_guests_ldap_sync = 4 [json_name = "ignoreGuestsLdapSync"];
inline bool ConfigSaml::_internal_has_ignore_guests_ldap_sync() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_ignore_guests_ldap_sync() const {
  return _internal_has_ignore_guests_ldap_sync();
}
inline void ConfigSaml::clear_ignore_guests_ldap_sync() {
  ignore_guests_ldap_sync_ = false;
  _has_bits_[0] &= ~0x10000000u;
}
inline bool ConfigSaml::_internal_ignore_guests_ldap_sync() const {
  return ignore_guests_ldap_sync_;
}
inline bool ConfigSaml::ignore_guests_ldap_sync() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.ignore_guests_ldap_sync)
  return _internal_ignore_guests_ldap_sync();
}
inline void ConfigSaml::_internal_set_ignore_guests_ldap_sync(bool value) {
  _has_bits_[0] |= 0x10000000u;
  ignore_guests_ldap_sync_ = value;
}
inline void ConfigSaml::set_ignore_guests_ldap_sync(bool value) {
  _internal_set_ignore_guests_ldap_sync(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.ignore_guests_ldap_sync)
}

// optional bool verify = 5 [json_name = "verify"];
inline bool ConfigSaml::_internal_has_verify() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_verify() const {
  return _internal_has_verify();
}
inline void ConfigSaml::clear_verify() {
  verify_ = false;
  _has_bits_[0] &= ~0x20000000u;
}
inline bool ConfigSaml::_internal_verify() const {
  return verify_;
}
inline bool ConfigSaml::verify() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.verify)
  return _internal_verify();
}
inline void ConfigSaml::_internal_set_verify(bool value) {
  _has_bits_[0] |= 0x20000000u;
  verify_ = value;
}
inline void ConfigSaml::set_verify(bool value) {
  _internal_set_verify(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.verify)
}

// optional bool encrypt = 6 [json_name = "encrypt"];
inline bool ConfigSaml::_internal_has_encrypt() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_encrypt() const {
  return _internal_has_encrypt();
}
inline void ConfigSaml::clear_encrypt() {
  encrypt_ = false;
  _has_bits_[0] &= ~0x40000000u;
}
inline bool ConfigSaml::_internal_encrypt() const {
  return encrypt_;
}
inline bool ConfigSaml::encrypt() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.encrypt)
  return _internal_encrypt();
}
inline void ConfigSaml::_internal_set_encrypt(bool value) {
  _has_bits_[0] |= 0x40000000u;
  encrypt_ = value;
}
inline void ConfigSaml::set_encrypt(bool value) {
  _internal_set_encrypt(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.encrypt)
}

// optional bool sign_request = 7 [json_name = "signRequest"];
inline bool ConfigSaml::_internal_has_sign_request() const {
  bool value = (_has_bits_[0] & 0x80000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_sign_request() const {
  return _internal_has_sign_request();
}
inline void ConfigSaml::clear_sign_request() {
  sign_request_ = false;
  _has_bits_[0] &= ~0x80000000u;
}
inline bool ConfigSaml::_internal_sign_request() const {
  return sign_request_;
}
inline bool ConfigSaml::sign_request() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.sign_request)
  return _internal_sign_request();
}
inline void ConfigSaml::_internal_set_sign_request(bool value) {
  _has_bits_[0] |= 0x80000000u;
  sign_request_ = value;
}
inline void ConfigSaml::set_sign_request(bool value) {
  _internal_set_sign_request(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.sign_request)
}

// optional string idp_url = 8 [json_name = "idpUrl"];
inline bool ConfigSaml::_internal_has_idp_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigSaml::has_idp_url() const {
  return _internal_has_idp_url();
}
inline void ConfigSaml::clear_idp_url() {
  idp_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigSaml::idp_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.idp_url)
  return _internal_idp_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_idp_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 idp_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.idp_url)
}
inline std::string* ConfigSaml::mutable_idp_url() {
  std::string* _s = _internal_mutable_idp_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.idp_url)
  return _s;
}
inline const std::string& ConfigSaml::_internal_idp_url() const {
  return idp_url_.Get();
}
inline void ConfigSaml::_internal_set_idp_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  idp_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_idp_url() {
  _has_bits_[0] |= 0x00000001u;
  return idp_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_idp_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.idp_url)
  if (!_internal_has_idp_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = idp_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_idp_url(std::string* idp_url) {
  if (idp_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  idp_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idp_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.idp_url)
}

// optional string idp_descriptor_url = 9 [json_name = "idpDescriptorUrl"];
inline bool ConfigSaml::_internal_has_idp_descriptor_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigSaml::has_idp_descriptor_url() const {
  return _internal_has_idp_descriptor_url();
}
inline void ConfigSaml::clear_idp_descriptor_url() {
  idp_descriptor_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigSaml::idp_descriptor_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.idp_descriptor_url)
  return _internal_idp_descriptor_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_idp_descriptor_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 idp_descriptor_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.idp_descriptor_url)
}
inline std::string* ConfigSaml::mutable_idp_descriptor_url() {
  std::string* _s = _internal_mutable_idp_descriptor_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.idp_descriptor_url)
  return _s;
}
inline const std::string& ConfigSaml::_internal_idp_descriptor_url() const {
  return idp_descriptor_url_.Get();
}
inline void ConfigSaml::_internal_set_idp_descriptor_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  idp_descriptor_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_idp_descriptor_url() {
  _has_bits_[0] |= 0x00000002u;
  return idp_descriptor_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_idp_descriptor_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.idp_descriptor_url)
  if (!_internal_has_idp_descriptor_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = idp_descriptor_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_descriptor_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_descriptor_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_idp_descriptor_url(std::string* idp_descriptor_url) {
  if (idp_descriptor_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  idp_descriptor_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idp_descriptor_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_descriptor_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_descriptor_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.idp_descriptor_url)
}

// optional string idp_metadata_url = 10 [json_name = "idpMetadataUrl"];
inline bool ConfigSaml::_internal_has_idp_metadata_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigSaml::has_idp_metadata_url() const {
  return _internal_has_idp_metadata_url();
}
inline void ConfigSaml::clear_idp_metadata_url() {
  idp_metadata_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigSaml::idp_metadata_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.idp_metadata_url)
  return _internal_idp_metadata_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_idp_metadata_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 idp_metadata_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.idp_metadata_url)
}
inline std::string* ConfigSaml::mutable_idp_metadata_url() {
  std::string* _s = _internal_mutable_idp_metadata_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.idp_metadata_url)
  return _s;
}
inline const std::string& ConfigSaml::_internal_idp_metadata_url() const {
  return idp_metadata_url_.Get();
}
inline void ConfigSaml::_internal_set_idp_metadata_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  idp_metadata_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_idp_metadata_url() {
  _has_bits_[0] |= 0x00000004u;
  return idp_metadata_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_idp_metadata_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.idp_metadata_url)
  if (!_internal_has_idp_metadata_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = idp_metadata_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_metadata_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_metadata_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_idp_metadata_url(std::string* idp_metadata_url) {
  if (idp_metadata_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  idp_metadata_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idp_metadata_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_metadata_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_metadata_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.idp_metadata_url)
}

// optional string service_provider_identifier = 11 [json_name = "serviceProviderIdentifier"];
inline bool ConfigSaml::_internal_has_service_provider_identifier() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigSaml::has_service_provider_identifier() const {
  return _internal_has_service_provider_identifier();
}
inline void ConfigSaml::clear_service_provider_identifier() {
  service_provider_identifier_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ConfigSaml::service_provider_identifier() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.service_provider_identifier)
  return _internal_service_provider_identifier();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_service_provider_identifier(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 service_provider_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.service_provider_identifier)
}
inline std::string* ConfigSaml::mutable_service_provider_identifier() {
  std::string* _s = _internal_mutable_service_provider_identifier();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.service_provider_identifier)
  return _s;
}
inline const std::string& ConfigSaml::_internal_service_provider_identifier() const {
  return service_provider_identifier_.Get();
}
inline void ConfigSaml::_internal_set_service_provider_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  service_provider_identifier_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_service_provider_identifier() {
  _has_bits_[0] |= 0x00000008u;
  return service_provider_identifier_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_service_provider_identifier() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.service_provider_identifier)
  if (!_internal_has_service_provider_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = service_provider_identifier_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_provider_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_provider_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_service_provider_identifier(std::string* service_provider_identifier) {
  if (service_provider_identifier != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  service_provider_identifier_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_provider_identifier,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (service_provider_identifier_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    service_provider_identifier_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.service_provider_identifier)
}

// optional string assertion_consumer_service_url = 12 [json_name = "assertionConsumerServiceUrl"];
inline bool ConfigSaml::_internal_has_assertion_consumer_service_url() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigSaml::has_assertion_consumer_service_url() const {
  return _internal_has_assertion_consumer_service_url();
}
inline void ConfigSaml::clear_assertion_consumer_service_url() {
  assertion_consumer_service_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ConfigSaml::assertion_consumer_service_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.assertion_consumer_service_url)
  return _internal_assertion_consumer_service_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_assertion_consumer_service_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 assertion_consumer_service_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.assertion_consumer_service_url)
}
inline std::string* ConfigSaml::mutable_assertion_consumer_service_url() {
  std::string* _s = _internal_mutable_assertion_consumer_service_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.assertion_consumer_service_url)
  return _s;
}
inline const std::string& ConfigSaml::_internal_assertion_consumer_service_url() const {
  return assertion_consumer_service_url_.Get();
}
inline void ConfigSaml::_internal_set_assertion_consumer_service_url(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  assertion_consumer_service_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_assertion_consumer_service_url() {
  _has_bits_[0] |= 0x00000010u;
  return assertion_consumer_service_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_assertion_consumer_service_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.assertion_consumer_service_url)
  if (!_internal_has_assertion_consumer_service_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = assertion_consumer_service_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assertion_consumer_service_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assertion_consumer_service_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_assertion_consumer_service_url(std::string* assertion_consumer_service_url) {
  if (assertion_consumer_service_url != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  assertion_consumer_service_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), assertion_consumer_service_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (assertion_consumer_service_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    assertion_consumer_service_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.assertion_consumer_service_url)
}

// optional string signature_algorithm = 13 [json_name = "signatureAlgorithm"];
inline bool ConfigSaml::_internal_has_signature_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigSaml::has_signature_algorithm() const {
  return _internal_has_signature_algorithm();
}
inline void ConfigSaml::clear_signature_algorithm() {
  signature_algorithm_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& ConfigSaml::signature_algorithm() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.signature_algorithm)
  return _internal_signature_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_signature_algorithm(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 signature_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.signature_algorithm)
}
inline std::string* ConfigSaml::mutable_signature_algorithm() {
  std::string* _s = _internal_mutable_signature_algorithm();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.signature_algorithm)
  return _s;
}
inline const std::string& ConfigSaml::_internal_signature_algorithm() const {
  return signature_algorithm_.Get();
}
inline void ConfigSaml::_internal_set_signature_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  signature_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_signature_algorithm() {
  _has_bits_[0] |= 0x00000020u;
  return signature_algorithm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_signature_algorithm() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.signature_algorithm)
  if (!_internal_has_signature_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = signature_algorithm_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_signature_algorithm(std::string* signature_algorithm) {
  if (signature_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  signature_algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature_algorithm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.signature_algorithm)
}

// optional string canonical_algorithm = 14 [json_name = "canonicalAlgorithm"];
inline bool ConfigSaml::_internal_has_canonical_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigSaml::has_canonical_algorithm() const {
  return _internal_has_canonical_algorithm();
}
inline void ConfigSaml::clear_canonical_algorithm() {
  canonical_algorithm_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& ConfigSaml::canonical_algorithm() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.canonical_algorithm)
  return _internal_canonical_algorithm();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_canonical_algorithm(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 canonical_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.canonical_algorithm)
}
inline std::string* ConfigSaml::mutable_canonical_algorithm() {
  std::string* _s = _internal_mutable_canonical_algorithm();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.canonical_algorithm)
  return _s;
}
inline const std::string& ConfigSaml::_internal_canonical_algorithm() const {
  return canonical_algorithm_.Get();
}
inline void ConfigSaml::_internal_set_canonical_algorithm(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  canonical_algorithm_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_canonical_algorithm() {
  _has_bits_[0] |= 0x00000040u;
  return canonical_algorithm_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_canonical_algorithm() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.canonical_algorithm)
  if (!_internal_has_canonical_algorithm()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = canonical_algorithm_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (canonical_algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    canonical_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_canonical_algorithm(std::string* canonical_algorithm) {
  if (canonical_algorithm != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  canonical_algorithm_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), canonical_algorithm,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (canonical_algorithm_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    canonical_algorithm_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.canonical_algorithm)
}

// optional string scoping_idp_provider_id = 15 [json_name = "scopingIdpProviderId"];
inline bool ConfigSaml::_internal_has_scoping_idp_provider_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigSaml::has_scoping_idp_provider_id() const {
  return _internal_has_scoping_idp_provider_id();
}
inline void ConfigSaml::clear_scoping_idp_provider_id() {
  scoping_idp_provider_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& ConfigSaml::scoping_idp_provider_id() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.scoping_idp_provider_id)
  return _internal_scoping_idp_provider_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_scoping_idp_provider_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 scoping_idp_provider_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.scoping_idp_provider_id)
}
inline std::string* ConfigSaml::mutable_scoping_idp_provider_id() {
  std::string* _s = _internal_mutable_scoping_idp_provider_id();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.scoping_idp_provider_id)
  return _s;
}
inline const std::string& ConfigSaml::_internal_scoping_idp_provider_id() const {
  return scoping_idp_provider_id_.Get();
}
inline void ConfigSaml::_internal_set_scoping_idp_provider_id(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  scoping_idp_provider_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_scoping_idp_provider_id() {
  _has_bits_[0] |= 0x00000080u;
  return scoping_idp_provider_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_scoping_idp_provider_id() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.scoping_idp_provider_id)
  if (!_internal_has_scoping_idp_provider_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = scoping_idp_provider_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scoping_idp_provider_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scoping_idp_provider_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_scoping_idp_provider_id(std::string* scoping_idp_provider_id) {
  if (scoping_idp_provider_id != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  scoping_idp_provider_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scoping_idp_provider_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scoping_idp_provider_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scoping_idp_provider_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.scoping_idp_provider_id)
}

// optional string scoping_idp_name = 16 [json_name = "scopingIdpName"];
inline bool ConfigSaml::_internal_has_scoping_idp_name() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigSaml::has_scoping_idp_name() const {
  return _internal_has_scoping_idp_name();
}
inline void ConfigSaml::clear_scoping_idp_name() {
  scoping_idp_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& ConfigSaml::scoping_idp_name() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.scoping_idp_name)
  return _internal_scoping_idp_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_scoping_idp_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 scoping_idp_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.scoping_idp_name)
}
inline std::string* ConfigSaml::mutable_scoping_idp_name() {
  std::string* _s = _internal_mutable_scoping_idp_name();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.scoping_idp_name)
  return _s;
}
inline const std::string& ConfigSaml::_internal_scoping_idp_name() const {
  return scoping_idp_name_.Get();
}
inline void ConfigSaml::_internal_set_scoping_idp_name(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  scoping_idp_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_scoping_idp_name() {
  _has_bits_[0] |= 0x00000100u;
  return scoping_idp_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_scoping_idp_name() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.scoping_idp_name)
  if (!_internal_has_scoping_idp_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = scoping_idp_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scoping_idp_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scoping_idp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_scoping_idp_name(std::string* scoping_idp_name) {
  if (scoping_idp_name != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  scoping_idp_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), scoping_idp_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (scoping_idp_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    scoping_idp_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.scoping_idp_name)
}

// optional string idp_certificate_file = 17 [json_name = "idpCertificateFile"];
inline bool ConfigSaml::_internal_has_idp_certificate_file() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigSaml::has_idp_certificate_file() const {
  return _internal_has_idp_certificate_file();
}
inline void ConfigSaml::clear_idp_certificate_file() {
  idp_certificate_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& ConfigSaml::idp_certificate_file() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.idp_certificate_file)
  return _internal_idp_certificate_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_idp_certificate_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 idp_certificate_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.idp_certificate_file)
}
inline std::string* ConfigSaml::mutable_idp_certificate_file() {
  std::string* _s = _internal_mutable_idp_certificate_file();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.idp_certificate_file)
  return _s;
}
inline const std::string& ConfigSaml::_internal_idp_certificate_file() const {
  return idp_certificate_file_.Get();
}
inline void ConfigSaml::_internal_set_idp_certificate_file(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  idp_certificate_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_idp_certificate_file() {
  _has_bits_[0] |= 0x00000200u;
  return idp_certificate_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_idp_certificate_file() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.idp_certificate_file)
  if (!_internal_has_idp_certificate_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = idp_certificate_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_certificate_file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_certificate_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_idp_certificate_file(std::string* idp_certificate_file) {
  if (idp_certificate_file != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  idp_certificate_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idp_certificate_file,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idp_certificate_file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idp_certificate_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.idp_certificate_file)
}

// optional string public_certificate_file = 18 [json_name = "publicCertificateFile"];
inline bool ConfigSaml::_internal_has_public_certificate_file() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ConfigSaml::has_public_certificate_file() const {
  return _internal_has_public_certificate_file();
}
inline void ConfigSaml::clear_public_certificate_file() {
  public_certificate_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& ConfigSaml::public_certificate_file() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.public_certificate_file)
  return _internal_public_certificate_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_public_certificate_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 public_certificate_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.public_certificate_file)
}
inline std::string* ConfigSaml::mutable_public_certificate_file() {
  std::string* _s = _internal_mutable_public_certificate_file();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.public_certificate_file)
  return _s;
}
inline const std::string& ConfigSaml::_internal_public_certificate_file() const {
  return public_certificate_file_.Get();
}
inline void ConfigSaml::_internal_set_public_certificate_file(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  public_certificate_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_public_certificate_file() {
  _has_bits_[0] |= 0x00000400u;
  return public_certificate_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_public_certificate_file() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.public_certificate_file)
  if (!_internal_has_public_certificate_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = public_certificate_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_certificate_file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_certificate_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_public_certificate_file(std::string* public_certificate_file) {
  if (public_certificate_file != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  public_certificate_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_certificate_file,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_certificate_file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_certificate_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.public_certificate_file)
}

// optional string private_key_file = 19 [json_name = "privateKeyFile"];
inline bool ConfigSaml::_internal_has_private_key_file() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ConfigSaml::has_private_key_file() const {
  return _internal_has_private_key_file();
}
inline void ConfigSaml::clear_private_key_file() {
  private_key_file_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& ConfigSaml::private_key_file() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.private_key_file)
  return _internal_private_key_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_private_key_file(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 private_key_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.private_key_file)
}
inline std::string* ConfigSaml::mutable_private_key_file() {
  std::string* _s = _internal_mutable_private_key_file();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.private_key_file)
  return _s;
}
inline const std::string& ConfigSaml::_internal_private_key_file() const {
  return private_key_file_.Get();
}
inline void ConfigSaml::_internal_set_private_key_file(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  private_key_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_private_key_file() {
  _has_bits_[0] |= 0x00000800u;
  return private_key_file_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_private_key_file() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.private_key_file)
  if (!_internal_has_private_key_file()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = private_key_file_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_key_file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_key_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_private_key_file(std::string* private_key_file) {
  if (private_key_file != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  private_key_file_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key_file,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (private_key_file_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    private_key_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.private_key_file)
}

// optional string id_attribute = 20 [json_name = "idAttribute"];
inline bool ConfigSaml::_internal_has_id_attribute() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ConfigSaml::has_id_attribute() const {
  return _internal_has_id_attribute();
}
inline void ConfigSaml::clear_id_attribute() {
  id_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& ConfigSaml::id_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.id_attribute)
  return _internal_id_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_id_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.id_attribute)
}
inline std::string* ConfigSaml::mutable_id_attribute() {
  std::string* _s = _internal_mutable_id_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.id_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_id_attribute() const {
  return id_attribute_.Get();
}
inline void ConfigSaml::_internal_set_id_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  id_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_id_attribute() {
  _has_bits_[0] |= 0x00001000u;
  return id_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_id_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.id_attribute)
  if (!_internal_has_id_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = id_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_id_attribute(std::string* id_attribute) {
  if (id_attribute != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  id_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.id_attribute)
}

// optional bool enable_admin_attribute = 21 [json_name = "enableAdminAttribute"];
inline bool ConfigSaml::_internal_has_enable_admin_attribute() const {
  bool value = (_has_bits_[1] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigSaml::has_enable_admin_attribute() const {
  return _internal_has_enable_admin_attribute();
}
inline void ConfigSaml::clear_enable_admin_attribute() {
  enable_admin_attribute_ = false;
  _has_bits_[1] &= ~0x00000001u;
}
inline bool ConfigSaml::_internal_enable_admin_attribute() const {
  return enable_admin_attribute_;
}
inline bool ConfigSaml::enable_admin_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.enable_admin_attribute)
  return _internal_enable_admin_attribute();
}
inline void ConfigSaml::_internal_set_enable_admin_attribute(bool value) {
  _has_bits_[1] |= 0x00000001u;
  enable_admin_attribute_ = value;
}
inline void ConfigSaml::set_enable_admin_attribute(bool value) {
  _internal_set_enable_admin_attribute(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.enable_admin_attribute)
}

// optional string admin_attribute = 22 [json_name = "adminAttribute"];
inline bool ConfigSaml::_internal_has_admin_attribute() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool ConfigSaml::has_admin_attribute() const {
  return _internal_has_admin_attribute();
}
inline void ConfigSaml::clear_admin_attribute() {
  admin_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& ConfigSaml::admin_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.admin_attribute)
  return _internal_admin_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_admin_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 admin_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.admin_attribute)
}
inline std::string* ConfigSaml::mutable_admin_attribute() {
  std::string* _s = _internal_mutable_admin_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.admin_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_admin_attribute() const {
  return admin_attribute_.Get();
}
inline void ConfigSaml::_internal_set_admin_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  admin_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_admin_attribute() {
  _has_bits_[0] |= 0x00002000u;
  return admin_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_admin_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.admin_attribute)
  if (!_internal_has_admin_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = admin_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (admin_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    admin_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_admin_attribute(std::string* admin_attribute) {
  if (admin_attribute != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  admin_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), admin_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (admin_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    admin_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.admin_attribute)
}

// optional string first_name_attribute = 23 [json_name = "firstNameAttribute"];
inline bool ConfigSaml::_internal_has_first_name_attribute() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool ConfigSaml::has_first_name_attribute() const {
  return _internal_has_first_name_attribute();
}
inline void ConfigSaml::clear_first_name_attribute() {
  first_name_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00004000u;
}
inline const std::string& ConfigSaml::first_name_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.first_name_attribute)
  return _internal_first_name_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_first_name_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00004000u;
 first_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.first_name_attribute)
}
inline std::string* ConfigSaml::mutable_first_name_attribute() {
  std::string* _s = _internal_mutable_first_name_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.first_name_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_first_name_attribute() const {
  return first_name_attribute_.Get();
}
inline void ConfigSaml::_internal_set_first_name_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00004000u;
  first_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_first_name_attribute() {
  _has_bits_[0] |= 0x00004000u;
  return first_name_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_first_name_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.first_name_attribute)
  if (!_internal_has_first_name_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00004000u;
  auto* p = first_name_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_first_name_attribute(std::string* first_name_attribute) {
  if (first_name_attribute != nullptr) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  first_name_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.first_name_attribute)
}

// optional string last_name_attribute = 24 [json_name = "lastNameAttribute"];
inline bool ConfigSaml::_internal_has_last_name_attribute() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool ConfigSaml::has_last_name_attribute() const {
  return _internal_has_last_name_attribute();
}
inline void ConfigSaml::clear_last_name_attribute() {
  last_name_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00008000u;
}
inline const std::string& ConfigSaml::last_name_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.last_name_attribute)
  return _internal_last_name_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_last_name_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00008000u;
 last_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.last_name_attribute)
}
inline std::string* ConfigSaml::mutable_last_name_attribute() {
  std::string* _s = _internal_mutable_last_name_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.last_name_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_last_name_attribute() const {
  return last_name_attribute_.Get();
}
inline void ConfigSaml::_internal_set_last_name_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00008000u;
  last_name_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_last_name_attribute() {
  _has_bits_[0] |= 0x00008000u;
  return last_name_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_last_name_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.last_name_attribute)
  if (!_internal_has_last_name_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00008000u;
  auto* p = last_name_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_last_name_attribute(std::string* last_name_attribute) {
  if (last_name_attribute != nullptr) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  last_name_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_name_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.last_name_attribute)
}

// optional string email_attribute = 25 [json_name = "emailAttribute"];
inline bool ConfigSaml::_internal_has_email_attribute() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool ConfigSaml::has_email_attribute() const {
  return _internal_has_email_attribute();
}
inline void ConfigSaml::clear_email_attribute() {
  email_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00010000u;
}
inline const std::string& ConfigSaml::email_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.email_attribute)
  return _internal_email_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_email_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00010000u;
 email_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.email_attribute)
}
inline std::string* ConfigSaml::mutable_email_attribute() {
  std::string* _s = _internal_mutable_email_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.email_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_email_attribute() const {
  return email_attribute_.Get();
}
inline void ConfigSaml::_internal_set_email_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00010000u;
  email_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_email_attribute() {
  _has_bits_[0] |= 0x00010000u;
  return email_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_email_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.email_attribute)
  if (!_internal_has_email_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00010000u;
  auto* p = email_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_email_attribute(std::string* email_attribute) {
  if (email_attribute != nullptr) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  email_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.email_attribute)
}

// optional string username_attribute = 26 [json_name = "usernameAttribute"];
inline bool ConfigSaml::_internal_has_username_attribute() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool ConfigSaml::has_username_attribute() const {
  return _internal_has_username_attribute();
}
inline void ConfigSaml::clear_username_attribute() {
  username_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00020000u;
}
inline const std::string& ConfigSaml::username_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.username_attribute)
  return _internal_username_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_username_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00020000u;
 username_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.username_attribute)
}
inline std::string* ConfigSaml::mutable_username_attribute() {
  std::string* _s = _internal_mutable_username_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.username_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_username_attribute() const {
  return username_attribute_.Get();
}
inline void ConfigSaml::_internal_set_username_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00020000u;
  username_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_username_attribute() {
  _has_bits_[0] |= 0x00020000u;
  return username_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_username_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.username_attribute)
  if (!_internal_has_username_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00020000u;
  auto* p = username_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_username_attribute(std::string* username_attribute) {
  if (username_attribute != nullptr) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  username_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.username_attribute)
}

// optional string nickname_attribute = 27 [json_name = "nicknameAttribute"];
inline bool ConfigSaml::_internal_has_nickname_attribute() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool ConfigSaml::has_nickname_attribute() const {
  return _internal_has_nickname_attribute();
}
inline void ConfigSaml::clear_nickname_attribute() {
  nickname_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00040000u;
}
inline const std::string& ConfigSaml::nickname_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.nickname_attribute)
  return _internal_nickname_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_nickname_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00040000u;
 nickname_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.nickname_attribute)
}
inline std::string* ConfigSaml::mutable_nickname_attribute() {
  std::string* _s = _internal_mutable_nickname_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.nickname_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_nickname_attribute() const {
  return nickname_attribute_.Get();
}
inline void ConfigSaml::_internal_set_nickname_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00040000u;
  nickname_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_nickname_attribute() {
  _has_bits_[0] |= 0x00040000u;
  return nickname_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_nickname_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.nickname_attribute)
  if (!_internal_has_nickname_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00040000u;
  auto* p = nickname_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_nickname_attribute(std::string* nickname_attribute) {
  if (nickname_attribute != nullptr) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  nickname_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.nickname_attribute)
}

// optional string locale_attribute = 28 [json_name = "localeAttribute"];
inline bool ConfigSaml::_internal_has_locale_attribute() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool ConfigSaml::has_locale_attribute() const {
  return _internal_has_locale_attribute();
}
inline void ConfigSaml::clear_locale_attribute() {
  locale_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00080000u;
}
inline const std::string& ConfigSaml::locale_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.locale_attribute)
  return _internal_locale_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_locale_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00080000u;
 locale_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.locale_attribute)
}
inline std::string* ConfigSaml::mutable_locale_attribute() {
  std::string* _s = _internal_mutable_locale_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.locale_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_locale_attribute() const {
  return locale_attribute_.Get();
}
inline void ConfigSaml::_internal_set_locale_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00080000u;
  locale_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_locale_attribute() {
  _has_bits_[0] |= 0x00080000u;
  return locale_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_locale_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.locale_attribute)
  if (!_internal_has_locale_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00080000u;
  auto* p = locale_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_locale_attribute(std::string* locale_attribute) {
  if (locale_attribute != nullptr) {
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  locale_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locale_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.locale_attribute)
}

// optional string position_attribute = 29 [json_name = "positionAttribute"];
inline bool ConfigSaml::_internal_has_position_attribute() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool ConfigSaml::has_position_attribute() const {
  return _internal_has_position_attribute();
}
inline void ConfigSaml::clear_position_attribute() {
  position_attribute_.ClearToEmpty();
  _has_bits_[0] &= ~0x00100000u;
}
inline const std::string& ConfigSaml::position_attribute() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.position_attribute)
  return _internal_position_attribute();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_position_attribute(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00100000u;
 position_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.position_attribute)
}
inline std::string* ConfigSaml::mutable_position_attribute() {
  std::string* _s = _internal_mutable_position_attribute();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.position_attribute)
  return _s;
}
inline const std::string& ConfigSaml::_internal_position_attribute() const {
  return position_attribute_.Get();
}
inline void ConfigSaml::_internal_set_position_attribute(const std::string& value) {
  _has_bits_[0] |= 0x00100000u;
  position_attribute_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_position_attribute() {
  _has_bits_[0] |= 0x00100000u;
  return position_attribute_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_position_attribute() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.position_attribute)
  if (!_internal_has_position_attribute()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00100000u;
  auto* p = position_attribute_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (position_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    position_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_position_attribute(std::string* position_attribute) {
  if (position_attribute != nullptr) {
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  position_attribute_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), position_attribute,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (position_attribute_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    position_attribute_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.position_attribute)
}

// optional string login_button_text = 30 [json_name = "loginButtonText"];
inline bool ConfigSaml::_internal_has_login_button_text() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool ConfigSaml::has_login_button_text() const {
  return _internal_has_login_button_text();
}
inline void ConfigSaml::clear_login_button_text() {
  login_button_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00200000u;
}
inline const std::string& ConfigSaml::login_button_text() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.login_button_text)
  return _internal_login_button_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_login_button_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00200000u;
 login_button_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.login_button_text)
}
inline std::string* ConfigSaml::mutable_login_button_text() {
  std::string* _s = _internal_mutable_login_button_text();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.login_button_text)
  return _s;
}
inline const std::string& ConfigSaml::_internal_login_button_text() const {
  return login_button_text_.Get();
}
inline void ConfigSaml::_internal_set_login_button_text(const std::string& value) {
  _has_bits_[0] |= 0x00200000u;
  login_button_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_login_button_text() {
  _has_bits_[0] |= 0x00200000u;
  return login_button_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_login_button_text() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.login_button_text)
  if (!_internal_has_login_button_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00200000u;
  auto* p = login_button_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_login_button_text(std::string* login_button_text) {
  if (login_button_text != nullptr) {
    _has_bits_[0] |= 0x00200000u;
  } else {
    _has_bits_[0] &= ~0x00200000u;
  }
  login_button_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.login_button_text)
}

// optional string login_button_color = 31 [json_name = "loginButtonColor"];
inline bool ConfigSaml::_internal_has_login_button_color() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool ConfigSaml::has_login_button_color() const {
  return _internal_has_login_button_color();
}
inline void ConfigSaml::clear_login_button_color() {
  login_button_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00400000u;
}
inline const std::string& ConfigSaml::login_button_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.login_button_color)
  return _internal_login_button_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_login_button_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00400000u;
 login_button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.login_button_color)
}
inline std::string* ConfigSaml::mutable_login_button_color() {
  std::string* _s = _internal_mutable_login_button_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.login_button_color)
  return _s;
}
inline const std::string& ConfigSaml::_internal_login_button_color() const {
  return login_button_color_.Get();
}
inline void ConfigSaml::_internal_set_login_button_color(const std::string& value) {
  _has_bits_[0] |= 0x00400000u;
  login_button_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_login_button_color() {
  _has_bits_[0] |= 0x00400000u;
  return login_button_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_login_button_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.login_button_color)
  if (!_internal_has_login_button_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00400000u;
  auto* p = login_button_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_login_button_color(std::string* login_button_color) {
  if (login_button_color != nullptr) {
    _has_bits_[0] |= 0x00400000u;
  } else {
    _has_bits_[0] &= ~0x00400000u;
  }
  login_button_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.login_button_color)
}

// optional string login_button_border_color = 32 [json_name = "loginButtonBorderColor"];
inline bool ConfigSaml::_internal_has_login_button_border_color() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool ConfigSaml::has_login_button_border_color() const {
  return _internal_has_login_button_border_color();
}
inline void ConfigSaml::clear_login_button_border_color() {
  login_button_border_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x00800000u;
}
inline const std::string& ConfigSaml::login_button_border_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.login_button_border_color)
  return _internal_login_button_border_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_login_button_border_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00800000u;
 login_button_border_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.login_button_border_color)
}
inline std::string* ConfigSaml::mutable_login_button_border_color() {
  std::string* _s = _internal_mutable_login_button_border_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.login_button_border_color)
  return _s;
}
inline const std::string& ConfigSaml::_internal_login_button_border_color() const {
  return login_button_border_color_.Get();
}
inline void ConfigSaml::_internal_set_login_button_border_color(const std::string& value) {
  _has_bits_[0] |= 0x00800000u;
  login_button_border_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_login_button_border_color() {
  _has_bits_[0] |= 0x00800000u;
  return login_button_border_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_login_button_border_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.login_button_border_color)
  if (!_internal_has_login_button_border_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00800000u;
  auto* p = login_button_border_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_border_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_border_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_login_button_border_color(std::string* login_button_border_color) {
  if (login_button_border_color != nullptr) {
    _has_bits_[0] |= 0x00800000u;
  } else {
    _has_bits_[0] &= ~0x00800000u;
  }
  login_button_border_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_border_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_border_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_border_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.login_button_border_color)
}

// optional string login_button_text_color = 33 [json_name = "loginButtonTextColor"];
inline bool ConfigSaml::_internal_has_login_button_text_color() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool ConfigSaml::has_login_button_text_color() const {
  return _internal_has_login_button_text_color();
}
inline void ConfigSaml::clear_login_button_text_color() {
  login_button_text_color_.ClearToEmpty();
  _has_bits_[0] &= ~0x01000000u;
}
inline const std::string& ConfigSaml::login_button_text_color() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigSaml.login_button_text_color)
  return _internal_login_button_text_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigSaml::set_login_button_text_color(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x01000000u;
 login_button_text_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigSaml.login_button_text_color)
}
inline std::string* ConfigSaml::mutable_login_button_text_color() {
  std::string* _s = _internal_mutable_login_button_text_color();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigSaml.login_button_text_color)
  return _s;
}
inline const std::string& ConfigSaml::_internal_login_button_text_color() const {
  return login_button_text_color_.Get();
}
inline void ConfigSaml::_internal_set_login_button_text_color(const std::string& value) {
  _has_bits_[0] |= 0x01000000u;
  login_button_text_color_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigSaml::_internal_mutable_login_button_text_color() {
  _has_bits_[0] |= 0x01000000u;
  return login_button_text_color_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigSaml::release_login_button_text_color() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigSaml.login_button_text_color)
  if (!_internal_has_login_button_text_color()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x01000000u;
  auto* p = login_button_text_color_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigSaml::set_allocated_login_button_text_color(std::string* login_button_text_color) {
  if (login_button_text_color != nullptr) {
    _has_bits_[0] |= 0x01000000u;
  } else {
    _has_bits_[0] &= ~0x01000000u;
  }
  login_button_text_color_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), login_button_text_color,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (login_button_text_color_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    login_button_text_color_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigSaml.login_button_text_color)
}

// -------------------------------------------------------------------

// ConfigNativeApp

// repeated string app_custom_url_schemes = 1 [json_name = "appCustomUrlSchemes"];
inline int ConfigNativeApp::_internal_app_custom_url_schemes_size() const {
  return app_custom_url_schemes_.size();
}
inline int ConfigNativeApp::app_custom_url_schemes_size() const {
  return _internal_app_custom_url_schemes_size();
}
inline void ConfigNativeApp::clear_app_custom_url_schemes() {
  app_custom_url_schemes_.Clear();
}
inline std::string* ConfigNativeApp::add_app_custom_url_schemes() {
  std::string* _s = _internal_add_app_custom_url_schemes();
  // @@protoc_insertion_point(field_add_mutable:common.v1.ConfigNativeApp.app_custom_url_schemes)
  return _s;
}
inline const std::string& ConfigNativeApp::_internal_app_custom_url_schemes(int index) const {
  return app_custom_url_schemes_.Get(index);
}
inline const std::string& ConfigNativeApp::app_custom_url_schemes(int index) const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.app_custom_url_schemes)
  return _internal_app_custom_url_schemes(index);
}
inline std::string* ConfigNativeApp::mutable_app_custom_url_schemes(int index) {
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigNativeApp.app_custom_url_schemes)
  return app_custom_url_schemes_.Mutable(index);
}
inline void ConfigNativeApp::set_app_custom_url_schemes(int index, const std::string& value) {
  app_custom_url_schemes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline void ConfigNativeApp::set_app_custom_url_schemes(int index, std::string&& value) {
  app_custom_url_schemes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline void ConfigNativeApp::set_app_custom_url_schemes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  app_custom_url_schemes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline void ConfigNativeApp::set_app_custom_url_schemes(int index, const char* value, size_t size) {
  app_custom_url_schemes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline std::string* ConfigNativeApp::_internal_add_app_custom_url_schemes() {
  return app_custom_url_schemes_.Add();
}
inline void ConfigNativeApp::add_app_custom_url_schemes(const std::string& value) {
  app_custom_url_schemes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline void ConfigNativeApp::add_app_custom_url_schemes(std::string&& value) {
  app_custom_url_schemes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline void ConfigNativeApp::add_app_custom_url_schemes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  app_custom_url_schemes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline void ConfigNativeApp::add_app_custom_url_schemes(const char* value, size_t size) {
  app_custom_url_schemes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:common.v1.ConfigNativeApp.app_custom_url_schemes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ConfigNativeApp::app_custom_url_schemes() const {
  // @@protoc_insertion_point(field_list:common.v1.ConfigNativeApp.app_custom_url_schemes)
  return app_custom_url_schemes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ConfigNativeApp::mutable_app_custom_url_schemes() {
  // @@protoc_insertion_point(field_mutable_list:common.v1.ConfigNativeApp.app_custom_url_schemes)
  return &app_custom_url_schemes_;
}

// optional string app_download_link = 2 [json_name = "appDownloadLink"];
inline bool ConfigNativeApp::_internal_has_app_download_link() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_app_download_link() const {
  return _internal_has_app_download_link();
}
inline void ConfigNativeApp::clear_app_download_link() {
  app_download_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigNativeApp::app_download_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.app_download_link)
  return _internal_app_download_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigNativeApp::set_app_download_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 app_download_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.app_download_link)
}
inline std::string* ConfigNativeApp::mutable_app_download_link() {
  std::string* _s = _internal_mutable_app_download_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigNativeApp.app_download_link)
  return _s;
}
inline const std::string& ConfigNativeApp::_internal_app_download_link() const {
  return app_download_link_.Get();
}
inline void ConfigNativeApp::_internal_set_app_download_link(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  app_download_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigNativeApp::_internal_mutable_app_download_link() {
  _has_bits_[0] |= 0x00000001u;
  return app_download_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigNativeApp::release_app_download_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigNativeApp.app_download_link)
  if (!_internal_has_app_download_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = app_download_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_download_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_download_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigNativeApp::set_allocated_app_download_link(std::string* app_download_link) {
  if (app_download_link != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  app_download_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app_download_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_download_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_download_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigNativeApp.app_download_link)
}

// optional string android_app_download_link = 3 [json_name = "androidAppDownloadLink"];
inline bool ConfigNativeApp::_internal_has_android_app_download_link() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_android_app_download_link() const {
  return _internal_has_android_app_download_link();
}
inline void ConfigNativeApp::clear_android_app_download_link() {
  android_app_download_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigNativeApp::android_app_download_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.android_app_download_link)
  return _internal_android_app_download_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigNativeApp::set_android_app_download_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 android_app_download_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.android_app_download_link)
}
inline std::string* ConfigNativeApp::mutable_android_app_download_link() {
  std::string* _s = _internal_mutable_android_app_download_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigNativeApp.android_app_download_link)
  return _s;
}
inline const std::string& ConfigNativeApp::_internal_android_app_download_link() const {
  return android_app_download_link_.Get();
}
inline void ConfigNativeApp::_internal_set_android_app_download_link(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  android_app_download_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigNativeApp::_internal_mutable_android_app_download_link() {
  _has_bits_[0] |= 0x00000002u;
  return android_app_download_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigNativeApp::release_android_app_download_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigNativeApp.android_app_download_link)
  if (!_internal_has_android_app_download_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = android_app_download_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (android_app_download_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    android_app_download_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigNativeApp::set_allocated_android_app_download_link(std::string* android_app_download_link) {
  if (android_app_download_link != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  android_app_download_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), android_app_download_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (android_app_download_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    android_app_download_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigNativeApp.android_app_download_link)
}

// optional string ios_app_download_link = 4 [json_name = "iosAppDownloadLink"];
inline bool ConfigNativeApp::_internal_has_ios_app_download_link() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_ios_app_download_link() const {
  return _internal_has_ios_app_download_link();
}
inline void ConfigNativeApp::clear_ios_app_download_link() {
  ios_app_download_link_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigNativeApp::ios_app_download_link() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.ios_app_download_link)
  return _internal_ios_app_download_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigNativeApp::set_ios_app_download_link(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 ios_app_download_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.ios_app_download_link)
}
inline std::string* ConfigNativeApp::mutable_ios_app_download_link() {
  std::string* _s = _internal_mutable_ios_app_download_link();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigNativeApp.ios_app_download_link)
  return _s;
}
inline const std::string& ConfigNativeApp::_internal_ios_app_download_link() const {
  return ios_app_download_link_.Get();
}
inline void ConfigNativeApp::_internal_set_ios_app_download_link(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ios_app_download_link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigNativeApp::_internal_mutable_ios_app_download_link() {
  _has_bits_[0] |= 0x00000004u;
  return ios_app_download_link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigNativeApp::release_ios_app_download_link() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigNativeApp.ios_app_download_link)
  if (!_internal_has_ios_app_download_link()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = ios_app_download_link_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ios_app_download_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ios_app_download_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigNativeApp::set_allocated_ios_app_download_link(std::string* ios_app_download_link) {
  if (ios_app_download_link != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ios_app_download_link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ios_app_download_link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ios_app_download_link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ios_app_download_link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigNativeApp.ios_app_download_link)
}

// optional bool mobile_external_browser = 5 [json_name = "mobileExternalBrowser"];
inline bool ConfigNativeApp::_internal_has_mobile_external_browser() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_mobile_external_browser() const {
  return _internal_has_mobile_external_browser();
}
inline void ConfigNativeApp::clear_mobile_external_browser() {
  mobile_external_browser_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigNativeApp::_internal_mobile_external_browser() const {
  return mobile_external_browser_;
}
inline bool ConfigNativeApp::mobile_external_browser() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.mobile_external_browser)
  return _internal_mobile_external_browser();
}
inline void ConfigNativeApp::_internal_set_mobile_external_browser(bool value) {
  _has_bits_[0] |= 0x00000008u;
  mobile_external_browser_ = value;
}
inline void ConfigNativeApp::set_mobile_external_browser(bool value) {
  _internal_set_mobile_external_browser(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.mobile_external_browser)
}

// optional bool mobile_enable_biometrics = 6 [json_name = "mobileEnableBiometrics"];
inline bool ConfigNativeApp::_internal_has_mobile_enable_biometrics() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_mobile_enable_biometrics() const {
  return _internal_has_mobile_enable_biometrics();
}
inline void ConfigNativeApp::clear_mobile_enable_biometrics() {
  mobile_enable_biometrics_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigNativeApp::_internal_mobile_enable_biometrics() const {
  return mobile_enable_biometrics_;
}
inline bool ConfigNativeApp::mobile_enable_biometrics() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.mobile_enable_biometrics)
  return _internal_mobile_enable_biometrics();
}
inline void ConfigNativeApp::_internal_set_mobile_enable_biometrics(bool value) {
  _has_bits_[0] |= 0x00000010u;
  mobile_enable_biometrics_ = value;
}
inline void ConfigNativeApp::set_mobile_enable_biometrics(bool value) {
  _internal_set_mobile_enable_biometrics(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.mobile_enable_biometrics)
}

// optional bool mobile_prevent_screen_capture = 7 [json_name = "mobilePreventScreenCapture"];
inline bool ConfigNativeApp::_internal_has_mobile_prevent_screen_capture() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_mobile_prevent_screen_capture() const {
  return _internal_has_mobile_prevent_screen_capture();
}
inline void ConfigNativeApp::clear_mobile_prevent_screen_capture() {
  mobile_prevent_screen_capture_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigNativeApp::_internal_mobile_prevent_screen_capture() const {
  return mobile_prevent_screen_capture_;
}
inline bool ConfigNativeApp::mobile_prevent_screen_capture() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.mobile_prevent_screen_capture)
  return _internal_mobile_prevent_screen_capture();
}
inline void ConfigNativeApp::_internal_set_mobile_prevent_screen_capture(bool value) {
  _has_bits_[0] |= 0x00000020u;
  mobile_prevent_screen_capture_ = value;
}
inline void ConfigNativeApp::set_mobile_prevent_screen_capture(bool value) {
  _internal_set_mobile_prevent_screen_capture(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.mobile_prevent_screen_capture)
}

// optional bool mobile_jailbreak_protection = 8 [json_name = "mobileJailbreakProtection"];
inline bool ConfigNativeApp::_internal_has_mobile_jailbreak_protection() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigNativeApp::has_mobile_jailbreak_protection() const {
  return _internal_has_mobile_jailbreak_protection();
}
inline void ConfigNativeApp::clear_mobile_jailbreak_protection() {
  mobile_jailbreak_protection_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigNativeApp::_internal_mobile_jailbreak_protection() const {
  return mobile_jailbreak_protection_;
}
inline bool ConfigNativeApp::mobile_jailbreak_protection() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigNativeApp.mobile_jailbreak_protection)
  return _internal_mobile_jailbreak_protection();
}
inline void ConfigNativeApp::_internal_set_mobile_jailbreak_protection(bool value) {
  _has_bits_[0] |= 0x00000040u;
  mobile_jailbreak_protection_ = value;
}
inline void ConfigNativeApp::set_mobile_jailbreak_protection(bool value) {
  _internal_set_mobile_jailbreak_protection(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigNativeApp.mobile_jailbreak_protection)
}

// -------------------------------------------------------------------

// ConfigMeilisearch

// optional string server_url = 1 [json_name = "server_url"];
inline bool ConfigMeilisearch::_internal_has_server_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_server_url() const {
  return _internal_has_server_url();
}
inline void ConfigMeilisearch::clear_server_url() {
  server_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigMeilisearch::server_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.server_url)
  return _internal_server_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigMeilisearch::set_server_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.server_url)
}
inline std::string* ConfigMeilisearch::mutable_server_url() {
  std::string* _s = _internal_mutable_server_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMeilisearch.server_url)
  return _s;
}
inline const std::string& ConfigMeilisearch::_internal_server_url() const {
  return server_url_.Get();
}
inline void ConfigMeilisearch::_internal_set_server_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigMeilisearch::_internal_mutable_server_url() {
  _has_bits_[0] |= 0x00000001u;
  return server_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigMeilisearch::release_server_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigMeilisearch.server_url)
  if (!_internal_has_server_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigMeilisearch::set_allocated_server_url(std::string* server_url) {
  if (server_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigMeilisearch.server_url)
}

// optional string master_key = 2 [json_name = "masterKey"];
inline bool ConfigMeilisearch::_internal_has_master_key() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_master_key() const {
  return _internal_has_master_key();
}
inline void ConfigMeilisearch::clear_master_key() {
  master_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigMeilisearch::master_key() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.master_key)
  return _internal_master_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigMeilisearch::set_master_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 master_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.master_key)
}
inline std::string* ConfigMeilisearch::mutable_master_key() {
  std::string* _s = _internal_mutable_master_key();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMeilisearch.master_key)
  return _s;
}
inline const std::string& ConfigMeilisearch::_internal_master_key() const {
  return master_key_.Get();
}
inline void ConfigMeilisearch::_internal_set_master_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  master_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigMeilisearch::_internal_mutable_master_key() {
  _has_bits_[0] |= 0x00000002u;
  return master_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigMeilisearch::release_master_key() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigMeilisearch.master_key)
  if (!_internal_has_master_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = master_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (master_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    master_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigMeilisearch::set_allocated_master_key(std::string* master_key) {
  if (master_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  master_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), master_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (master_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    master_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigMeilisearch.master_key)
}

// optional bool enable_indexing = 3 [json_name = "enableIndexing"];
inline bool ConfigMeilisearch::_internal_has_enable_indexing() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_enable_indexing() const {
  return _internal_has_enable_indexing();
}
inline void ConfigMeilisearch::clear_enable_indexing() {
  enable_indexing_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigMeilisearch::_internal_enable_indexing() const {
  return enable_indexing_;
}
inline bool ConfigMeilisearch::enable_indexing() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.enable_indexing)
  return _internal_enable_indexing();
}
inline void ConfigMeilisearch::_internal_set_enable_indexing(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_indexing_ = value;
}
inline void ConfigMeilisearch::set_enable_indexing(bool value) {
  _internal_set_enable_indexing(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.enable_indexing)
}

// optional bool enable_searching = 4 [json_name = "enableSearching"];
inline bool ConfigMeilisearch::_internal_has_enable_searching() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_enable_searching() const {
  return _internal_has_enable_searching();
}
inline void ConfigMeilisearch::clear_enable_searching() {
  enable_searching_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ConfigMeilisearch::_internal_enable_searching() const {
  return enable_searching_;
}
inline bool ConfigMeilisearch::enable_searching() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.enable_searching)
  return _internal_enable_searching();
}
inline void ConfigMeilisearch::_internal_set_enable_searching(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_searching_ = value;
}
inline void ConfigMeilisearch::set_enable_searching(bool value) {
  _internal_set_enable_searching(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.enable_searching)
}

// optional bool enable_autocomplete = 5 [json_name = "enableAutocomplete"];
inline bool ConfigMeilisearch::_internal_has_enable_autocomplete() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_enable_autocomplete() const {
  return _internal_has_enable_autocomplete();
}
inline void ConfigMeilisearch::clear_enable_autocomplete() {
  enable_autocomplete_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ConfigMeilisearch::_internal_enable_autocomplete() const {
  return enable_autocomplete_;
}
inline bool ConfigMeilisearch::enable_autocomplete() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.enable_autocomplete)
  return _internal_enable_autocomplete();
}
inline void ConfigMeilisearch::_internal_set_enable_autocomplete(bool value) {
  _has_bits_[0] |= 0x00000020u;
  enable_autocomplete_ = value;
}
inline void ConfigMeilisearch::set_enable_autocomplete(bool value) {
  _internal_set_enable_autocomplete(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.enable_autocomplete)
}

// optional int32 batch_size = 6 [json_name = "batchSize"];
inline bool ConfigMeilisearch::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void ConfigMeilisearch::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ConfigMeilisearch::_internal_batch_size() const {
  return batch_size_;
}
inline int32_t ConfigMeilisearch::batch_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.batch_size)
  return _internal_batch_size();
}
inline void ConfigMeilisearch::_internal_set_batch_size(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  batch_size_ = value;
}
inline void ConfigMeilisearch::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.batch_size)
}

// optional int32 request_timeout_seconds = 7 [json_name = "requestTimeoutSeconds"];
inline bool ConfigMeilisearch::_internal_has_request_timeout_seconds() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_request_timeout_seconds() const {
  return _internal_has_request_timeout_seconds();
}
inline void ConfigMeilisearch::clear_request_timeout_seconds() {
  request_timeout_seconds_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ConfigMeilisearch::_internal_request_timeout_seconds() const {
  return request_timeout_seconds_;
}
inline int32_t ConfigMeilisearch::request_timeout_seconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.request_timeout_seconds)
  return _internal_request_timeout_seconds();
}
inline void ConfigMeilisearch::_internal_set_request_timeout_seconds(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  request_timeout_seconds_ = value;
}
inline void ConfigMeilisearch::set_request_timeout_seconds(int32_t value) {
  _internal_set_request_timeout_seconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.request_timeout_seconds)
}

// optional string index_prefix = 8 [json_name = "indexPrefix"];
inline bool ConfigMeilisearch::_internal_has_index_prefix() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_index_prefix() const {
  return _internal_has_index_prefix();
}
inline void ConfigMeilisearch::clear_index_prefix() {
  index_prefix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigMeilisearch::index_prefix() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.index_prefix)
  return _internal_index_prefix();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigMeilisearch::set_index_prefix(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 index_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.index_prefix)
}
inline std::string* ConfigMeilisearch::mutable_index_prefix() {
  std::string* _s = _internal_mutable_index_prefix();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigMeilisearch.index_prefix)
  return _s;
}
inline const std::string& ConfigMeilisearch::_internal_index_prefix() const {
  return index_prefix_.Get();
}
inline void ConfigMeilisearch::_internal_set_index_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  index_prefix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigMeilisearch::_internal_mutable_index_prefix() {
  _has_bits_[0] |= 0x00000004u;
  return index_prefix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigMeilisearch::release_index_prefix() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigMeilisearch.index_prefix)
  if (!_internal_has_index_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = index_prefix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigMeilisearch::set_allocated_index_prefix(std::string* index_prefix) {
  if (index_prefix != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_prefix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_prefix,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_prefix_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_prefix_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigMeilisearch.index_prefix)
}

// optional int32 search_cutoff_ms = 9 [json_name = "searchCutoffMs"];
inline bool ConfigMeilisearch::_internal_has_search_cutoff_ms() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_search_cutoff_ms() const {
  return _internal_has_search_cutoff_ms();
}
inline void ConfigMeilisearch::clear_search_cutoff_ms() {
  search_cutoff_ms_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ConfigMeilisearch::_internal_search_cutoff_ms() const {
  return search_cutoff_ms_;
}
inline int32_t ConfigMeilisearch::search_cutoff_ms() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.search_cutoff_ms)
  return _internal_search_cutoff_ms();
}
inline void ConfigMeilisearch::_internal_set_search_cutoff_ms(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  search_cutoff_ms_ = value;
}
inline void ConfigMeilisearch::set_search_cutoff_ms(int32_t value) {
  _internal_set_search_cutoff_ms(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.search_cutoff_ms)
}

// optional bool enable_typo_tolerance = 10 [json_name = "enableTypoTolerance"];
inline bool ConfigMeilisearch::_internal_has_enable_typo_tolerance() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigMeilisearch::has_enable_typo_tolerance() const {
  return _internal_has_enable_typo_tolerance();
}
inline void ConfigMeilisearch::clear_enable_typo_tolerance() {
  enable_typo_tolerance_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ConfigMeilisearch::_internal_enable_typo_tolerance() const {
  return enable_typo_tolerance_;
}
inline bool ConfigMeilisearch::enable_typo_tolerance() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigMeilisearch.enable_typo_tolerance)
  return _internal_enable_typo_tolerance();
}
inline void ConfigMeilisearch::_internal_set_enable_typo_tolerance(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enable_typo_tolerance_ = value;
}
inline void ConfigMeilisearch::set_enable_typo_tolerance(bool value) {
  _internal_set_enable_typo_tolerance(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigMeilisearch.enable_typo_tolerance)
}

// -------------------------------------------------------------------

// ConfigBleve

// optional string index_dir = 1 [json_name = "indexDir"];
inline bool ConfigBleve::_internal_has_index_dir() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigBleve::has_index_dir() const {
  return _internal_has_index_dir();
}
inline void ConfigBleve::clear_index_dir() {
  index_dir_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigBleve::index_dir() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigBleve.index_dir)
  return _internal_index_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigBleve::set_index_dir(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 index_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigBleve.index_dir)
}
inline std::string* ConfigBleve::mutable_index_dir() {
  std::string* _s = _internal_mutable_index_dir();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigBleve.index_dir)
  return _s;
}
inline const std::string& ConfigBleve::_internal_index_dir() const {
  return index_dir_.Get();
}
inline void ConfigBleve::_internal_set_index_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  index_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigBleve::_internal_mutable_index_dir() {
  _has_bits_[0] |= 0x00000001u;
  return index_dir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigBleve::release_index_dir() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigBleve.index_dir)
  if (!_internal_has_index_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = index_dir_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_dir_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_dir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigBleve::set_allocated_index_dir(std::string* index_dir) {
  if (index_dir != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  index_dir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_dir,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_dir_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_dir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigBleve.index_dir)
}

// optional bool enable_indexing = 2 [json_name = "enableIndexing"];
inline bool ConfigBleve::_internal_has_enable_indexing() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigBleve::has_enable_indexing() const {
  return _internal_has_enable_indexing();
}
inline void ConfigBleve::clear_enable_indexing() {
  enable_indexing_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ConfigBleve::_internal_enable_indexing() const {
  return enable_indexing_;
}
inline bool ConfigBleve::enable_indexing() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigBleve.enable_indexing)
  return _internal_enable_indexing();
}
inline void ConfigBleve::_internal_set_enable_indexing(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_indexing_ = value;
}
inline void ConfigBleve::set_enable_indexing(bool value) {
  _internal_set_enable_indexing(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigBleve.enable_indexing)
}

// optional bool enable_searching = 3 [json_name = "enableSearching"];
inline bool ConfigBleve::_internal_has_enable_searching() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigBleve::has_enable_searching() const {
  return _internal_has_enable_searching();
}
inline void ConfigBleve::clear_enable_searching() {
  enable_searching_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConfigBleve::_internal_enable_searching() const {
  return enable_searching_;
}
inline bool ConfigBleve::enable_searching() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigBleve.enable_searching)
  return _internal_enable_searching();
}
inline void ConfigBleve::_internal_set_enable_searching(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_searching_ = value;
}
inline void ConfigBleve::set_enable_searching(bool value) {
  _internal_set_enable_searching(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigBleve.enable_searching)
}

// optional bool enable_autocomplete = 4 [json_name = "enableAutocomplete"];
inline bool ConfigBleve::_internal_has_enable_autocomplete() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigBleve::has_enable_autocomplete() const {
  return _internal_has_enable_autocomplete();
}
inline void ConfigBleve::clear_enable_autocomplete() {
  enable_autocomplete_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigBleve::_internal_enable_autocomplete() const {
  return enable_autocomplete_;
}
inline bool ConfigBleve::enable_autocomplete() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigBleve.enable_autocomplete)
  return _internal_enable_autocomplete();
}
inline void ConfigBleve::_internal_set_enable_autocomplete(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_autocomplete_ = value;
}
inline void ConfigBleve::set_enable_autocomplete(bool value) {
  _internal_set_enable_autocomplete(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigBleve.enable_autocomplete)
}

// optional int32 bulk_indexing_time_window_seconds = 5 [json_name = "bulkIndexingTimeWindowSeconds"];
inline bool ConfigBleve::_internal_has_bulk_indexing_time_window_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigBleve::has_bulk_indexing_time_window_seconds() const {
  return _internal_has_bulk_indexing_time_window_seconds();
}
inline void ConfigBleve::clear_bulk_indexing_time_window_seconds() {
  bulk_indexing_time_window_seconds_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ConfigBleve::_internal_bulk_indexing_time_window_seconds() const {
  return bulk_indexing_time_window_seconds_;
}
inline int32_t ConfigBleve::bulk_indexing_time_window_seconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigBleve.bulk_indexing_time_window_seconds)
  return _internal_bulk_indexing_time_window_seconds();
}
inline void ConfigBleve::_internal_set_bulk_indexing_time_window_seconds(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  bulk_indexing_time_window_seconds_ = value;
}
inline void ConfigBleve::set_bulk_indexing_time_window_seconds(int32_t value) {
  _internal_set_bulk_indexing_time_window_seconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigBleve.bulk_indexing_time_window_seconds)
}

// optional int32 batch_size = 6 [json_name = "batchSize"];
inline bool ConfigBleve::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigBleve::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void ConfigBleve::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ConfigBleve::_internal_batch_size() const {
  return batch_size_;
}
inline int32_t ConfigBleve::batch_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigBleve.batch_size)
  return _internal_batch_size();
}
inline void ConfigBleve::_internal_set_batch_size(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  batch_size_ = value;
}
inline void ConfigBleve::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigBleve.batch_size)
}

// -------------------------------------------------------------------

// ConfigDataRetention

// optional bool enable_message_deletion = 1 [json_name = "enableMessageDeletion"];
inline bool ConfigDataRetention::_internal_has_enable_message_deletion() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_enable_message_deletion() const {
  return _internal_has_enable_message_deletion();
}
inline void ConfigDataRetention::clear_enable_message_deletion() {
  enable_message_deletion_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ConfigDataRetention::_internal_enable_message_deletion() const {
  return enable_message_deletion_;
}
inline bool ConfigDataRetention::enable_message_deletion() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.enable_message_deletion)
  return _internal_enable_message_deletion();
}
inline void ConfigDataRetention::_internal_set_enable_message_deletion(bool value) {
  _has_bits_[0] |= 0x00000002u;
  enable_message_deletion_ = value;
}
inline void ConfigDataRetention::set_enable_message_deletion(bool value) {
  _internal_set_enable_message_deletion(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.enable_message_deletion)
}

// optional bool enable_file_deletion = 2 [json_name = "enableFileDeletion"];
inline bool ConfigDataRetention::_internal_has_enable_file_deletion() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_enable_file_deletion() const {
  return _internal_has_enable_file_deletion();
}
inline void ConfigDataRetention::clear_enable_file_deletion() {
  enable_file_deletion_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ConfigDataRetention::_internal_enable_file_deletion() const {
  return enable_file_deletion_;
}
inline bool ConfigDataRetention::enable_file_deletion() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.enable_file_deletion)
  return _internal_enable_file_deletion();
}
inline void ConfigDataRetention::_internal_set_enable_file_deletion(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_file_deletion_ = value;
}
inline void ConfigDataRetention::set_enable_file_deletion(bool value) {
  _internal_set_enable_file_deletion(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.enable_file_deletion)
}

// optional bool enable_boards_deletion = 3 [json_name = "enableBoardsDeletion"];
inline bool ConfigDataRetention::_internal_has_enable_boards_deletion() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_enable_boards_deletion() const {
  return _internal_has_enable_boards_deletion();
}
inline void ConfigDataRetention::clear_enable_boards_deletion() {
  enable_boards_deletion_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigDataRetention::_internal_enable_boards_deletion() const {
  return enable_boards_deletion_;
}
inline bool ConfigDataRetention::enable_boards_deletion() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.enable_boards_deletion)
  return _internal_enable_boards_deletion();
}
inline void ConfigDataRetention::_internal_set_enable_boards_deletion(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_boards_deletion_ = value;
}
inline void ConfigDataRetention::set_enable_boards_deletion(bool value) {
  _internal_set_enable_boards_deletion(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.enable_boards_deletion)
}

// optional int32 message_retention_hours = 4 [json_name = "messageRetentionHours"];
inline bool ConfigDataRetention::_internal_has_message_retention_hours() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_message_retention_hours() const {
  return _internal_has_message_retention_hours();
}
inline void ConfigDataRetention::clear_message_retention_hours() {
  message_retention_hours_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t ConfigDataRetention::_internal_message_retention_hours() const {
  return message_retention_hours_;
}
inline int32_t ConfigDataRetention::message_retention_hours() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.message_retention_hours)
  return _internal_message_retention_hours();
}
inline void ConfigDataRetention::_internal_set_message_retention_hours(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  message_retention_hours_ = value;
}
inline void ConfigDataRetention::set_message_retention_hours(int32_t value) {
  _internal_set_message_retention_hours(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.message_retention_hours)
}

// optional int32 file_retention_hours = 5 [json_name = "fileRetentionHours"];
inline bool ConfigDataRetention::_internal_has_file_retention_hours() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_file_retention_hours() const {
  return _internal_has_file_retention_hours();
}
inline void ConfigDataRetention::clear_file_retention_hours() {
  file_retention_hours_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t ConfigDataRetention::_internal_file_retention_hours() const {
  return file_retention_hours_;
}
inline int32_t ConfigDataRetention::file_retention_hours() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.file_retention_hours)
  return _internal_file_retention_hours();
}
inline void ConfigDataRetention::_internal_set_file_retention_hours(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  file_retention_hours_ = value;
}
inline void ConfigDataRetention::set_file_retention_hours(int32_t value) {
  _internal_set_file_retention_hours(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.file_retention_hours)
}

// optional int32 boards_retention_days = 6 [json_name = "boardsRetentionDays"];
inline bool ConfigDataRetention::_internal_has_boards_retention_days() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_boards_retention_days() const {
  return _internal_has_boards_retention_days();
}
inline void ConfigDataRetention::clear_boards_retention_days() {
  boards_retention_days_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t ConfigDataRetention::_internal_boards_retention_days() const {
  return boards_retention_days_;
}
inline int32_t ConfigDataRetention::boards_retention_days() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.boards_retention_days)
  return _internal_boards_retention_days();
}
inline void ConfigDataRetention::_internal_set_boards_retention_days(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  boards_retention_days_ = value;
}
inline void ConfigDataRetention::set_boards_retention_days(int32_t value) {
  _internal_set_boards_retention_days(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.boards_retention_days)
}

// optional string deletion_job_start_time = 7 [json_name = "deletionJobStartTime"];
inline bool ConfigDataRetention::_internal_has_deletion_job_start_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_deletion_job_start_time() const {
  return _internal_has_deletion_job_start_time();
}
inline void ConfigDataRetention::clear_deletion_job_start_time() {
  deletion_job_start_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigDataRetention::deletion_job_start_time() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.deletion_job_start_time)
  return _internal_deletion_job_start_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigDataRetention::set_deletion_job_start_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 deletion_job_start_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.deletion_job_start_time)
}
inline std::string* ConfigDataRetention::mutable_deletion_job_start_time() {
  std::string* _s = _internal_mutable_deletion_job_start_time();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigDataRetention.deletion_job_start_time)
  return _s;
}
inline const std::string& ConfigDataRetention::_internal_deletion_job_start_time() const {
  return deletion_job_start_time_.Get();
}
inline void ConfigDataRetention::_internal_set_deletion_job_start_time(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  deletion_job_start_time_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigDataRetention::_internal_mutable_deletion_job_start_time() {
  _has_bits_[0] |= 0x00000001u;
  return deletion_job_start_time_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigDataRetention::release_deletion_job_start_time() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigDataRetention.deletion_job_start_time)
  if (!_internal_has_deletion_job_start_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = deletion_job_start_time_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deletion_job_start_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deletion_job_start_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigDataRetention::set_allocated_deletion_job_start_time(std::string* deletion_job_start_time) {
  if (deletion_job_start_time != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  deletion_job_start_time_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), deletion_job_start_time,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (deletion_job_start_time_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    deletion_job_start_time_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigDataRetention.deletion_job_start_time)
}

// optional int32 batch_size = 8 [json_name = "batchSize"];
inline bool ConfigDataRetention::_internal_has_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_batch_size() const {
  return _internal_has_batch_size();
}
inline void ConfigDataRetention::clear_batch_size() {
  batch_size_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t ConfigDataRetention::_internal_batch_size() const {
  return batch_size_;
}
inline int32_t ConfigDataRetention::batch_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.batch_size)
  return _internal_batch_size();
}
inline void ConfigDataRetention::_internal_set_batch_size(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  batch_size_ = value;
}
inline void ConfigDataRetention::set_batch_size(int32_t value) {
  _internal_set_batch_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.batch_size)
}

// optional int32 time_between_batches_milliseconds = 9 [json_name = "timeBetweenBatchesMilliseconds"];
inline bool ConfigDataRetention::_internal_has_time_between_batches_milliseconds() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_time_between_batches_milliseconds() const {
  return _internal_has_time_between_batches_milliseconds();
}
inline void ConfigDataRetention::clear_time_between_batches_milliseconds() {
  time_between_batches_milliseconds_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t ConfigDataRetention::_internal_time_between_batches_milliseconds() const {
  return time_between_batches_milliseconds_;
}
inline int32_t ConfigDataRetention::time_between_batches_milliseconds() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.time_between_batches_milliseconds)
  return _internal_time_between_batches_milliseconds();
}
inline void ConfigDataRetention::_internal_set_time_between_batches_milliseconds(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  time_between_batches_milliseconds_ = value;
}
inline void ConfigDataRetention::set_time_between_batches_milliseconds(int32_t value) {
  _internal_set_time_between_batches_milliseconds(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.time_between_batches_milliseconds)
}

// optional int32 retention_ids_batch_size = 10 [json_name = "retentionIdsBatchSize"];
inline bool ConfigDataRetention::_internal_has_retention_ids_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ConfigDataRetention::has_retention_ids_batch_size() const {
  return _internal_has_retention_ids_batch_size();
}
inline void ConfigDataRetention::clear_retention_ids_batch_size() {
  retention_ids_batch_size_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t ConfigDataRetention::_internal_retention_ids_batch_size() const {
  return retention_ids_batch_size_;
}
inline int32_t ConfigDataRetention::retention_ids_batch_size() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigDataRetention.retention_ids_batch_size)
  return _internal_retention_ids_batch_size();
}
inline void ConfigDataRetention::_internal_set_retention_ids_batch_size(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  retention_ids_batch_size_ = value;
}
inline void ConfigDataRetention::set_retention_ids_batch_size(int32_t value) {
  _internal_set_retention_ids_batch_size(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigDataRetention.retention_ids_batch_size)
}

// -------------------------------------------------------------------

// ConfigImageProxy

// optional bool enable = 1 [json_name = "enable"];
inline bool ConfigImageProxy::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ConfigImageProxy::has_enable() const {
  return _internal_has_enable();
}
inline void ConfigImageProxy::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ConfigImageProxy::_internal_enable() const {
  return enable_;
}
inline bool ConfigImageProxy::enable() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigImageProxy.enable)
  return _internal_enable();
}
inline void ConfigImageProxy::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_ = value;
}
inline void ConfigImageProxy::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:common.v1.ConfigImageProxy.enable)
}

// optional string image_proxy_type = 2 [json_name = "imageProxyType"];
inline bool ConfigImageProxy::_internal_has_image_proxy_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ConfigImageProxy::has_image_proxy_type() const {
  return _internal_has_image_proxy_type();
}
inline void ConfigImageProxy::clear_image_proxy_type() {
  image_proxy_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ConfigImageProxy::image_proxy_type() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigImageProxy.image_proxy_type)
  return _internal_image_proxy_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigImageProxy::set_image_proxy_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 image_proxy_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigImageProxy.image_proxy_type)
}
inline std::string* ConfigImageProxy::mutable_image_proxy_type() {
  std::string* _s = _internal_mutable_image_proxy_type();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigImageProxy.image_proxy_type)
  return _s;
}
inline const std::string& ConfigImageProxy::_internal_image_proxy_type() const {
  return image_proxy_type_.Get();
}
inline void ConfigImageProxy::_internal_set_image_proxy_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_proxy_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigImageProxy::_internal_mutable_image_proxy_type() {
  _has_bits_[0] |= 0x00000001u;
  return image_proxy_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigImageProxy::release_image_proxy_type() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigImageProxy.image_proxy_type)
  if (!_internal_has_image_proxy_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = image_proxy_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_proxy_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_proxy_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigImageProxy::set_allocated_image_proxy_type(std::string* image_proxy_type) {
  if (image_proxy_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_proxy_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_proxy_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_proxy_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_proxy_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigImageProxy.image_proxy_type)
}

// optional string remote_image_proxy_url = 3 [json_name = "remoteImageProxyUrl"];
inline bool ConfigImageProxy::_internal_has_remote_image_proxy_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ConfigImageProxy::has_remote_image_proxy_url() const {
  return _internal_has_remote_image_proxy_url();
}
inline void ConfigImageProxy::clear_remote_image_proxy_url() {
  remote_image_proxy_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ConfigImageProxy::remote_image_proxy_url() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigImageProxy.remote_image_proxy_url)
  return _internal_remote_image_proxy_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigImageProxy::set_remote_image_proxy_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 remote_image_proxy_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigImageProxy.remote_image_proxy_url)
}
inline std::string* ConfigImageProxy::mutable_remote_image_proxy_url() {
  std::string* _s = _internal_mutable_remote_image_proxy_url();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigImageProxy.remote_image_proxy_url)
  return _s;
}
inline const std::string& ConfigImageProxy::_internal_remote_image_proxy_url() const {
  return remote_image_proxy_url_.Get();
}
inline void ConfigImageProxy::_internal_set_remote_image_proxy_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  remote_image_proxy_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigImageProxy::_internal_mutable_remote_image_proxy_url() {
  _has_bits_[0] |= 0x00000002u;
  return remote_image_proxy_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigImageProxy::release_remote_image_proxy_url() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigImageProxy.remote_image_proxy_url)
  if (!_internal_has_remote_image_proxy_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = remote_image_proxy_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_image_proxy_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_image_proxy_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigImageProxy::set_allocated_remote_image_proxy_url(std::string* remote_image_proxy_url) {
  if (remote_image_proxy_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  remote_image_proxy_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_image_proxy_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_image_proxy_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_image_proxy_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigImageProxy.remote_image_proxy_url)
}

// optional string remote_image_proxy_options = 4 [json_name = "remoteImageProxyOptions"];
inline bool ConfigImageProxy::_internal_has_remote_image_proxy_options() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ConfigImageProxy::has_remote_image_proxy_options() const {
  return _internal_has_remote_image_proxy_options();
}
inline void ConfigImageProxy::clear_remote_image_proxy_options() {
  remote_image_proxy_options_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ConfigImageProxy::remote_image_proxy_options() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigImageProxy.remote_image_proxy_options)
  return _internal_remote_image_proxy_options();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigImageProxy::set_remote_image_proxy_options(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 remote_image_proxy_options_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigImageProxy.remote_image_proxy_options)
}
inline std::string* ConfigImageProxy::mutable_remote_image_proxy_options() {
  std::string* _s = _internal_mutable_remote_image_proxy_options();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigImageProxy.remote_image_proxy_options)
  return _s;
}
inline const std::string& ConfigImageProxy::_internal_remote_image_proxy_options() const {
  return remote_image_proxy_options_.Get();
}
inline void ConfigImageProxy::_internal_set_remote_image_proxy_options(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  remote_image_proxy_options_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigImageProxy::_internal_mutable_remote_image_proxy_options() {
  _has_bits_[0] |= 0x00000004u;
  return remote_image_proxy_options_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigImageProxy::release_remote_image_proxy_options() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigImageProxy.remote_image_proxy_options)
  if (!_internal_has_remote_image_proxy_options()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = remote_image_proxy_options_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_image_proxy_options_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_image_proxy_options_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ConfigImageProxy::set_allocated_remote_image_proxy_options(std::string* remote_image_proxy_options) {
  if (remote_image_proxy_options != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  remote_image_proxy_options_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_image_proxy_options,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_image_proxy_options_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_image_proxy_options_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigImageProxy.remote_image_proxy_options)
}

// -------------------------------------------------------------------

// Config

// .common.v1.ConfigMain main = 1 [json_name = "main"];
inline bool Config::_internal_has_main() const {
  return this != internal_default_instance() && main_ != nullptr;
}
inline bool Config::has_main() const {
  return _internal_has_main();
}
inline void Config::clear_main() {
  if (GetArenaForAllocation() == nullptr && main_ != nullptr) {
    delete main_;
  }
  main_ = nullptr;
}
inline const ::common::v1::ConfigMain& Config::_internal_main() const {
  const ::common::v1::ConfigMain* p = main_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigMain&>(
      ::common::v1::_ConfigMain_default_instance_);
}
inline const ::common::v1::ConfigMain& Config::main() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.main)
  return _internal_main();
}
inline void Config::unsafe_arena_set_allocated_main(
    ::common::v1::ConfigMain* main) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(main_);
  }
  main_ = main;
  if (main) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.main)
}
inline ::common::v1::ConfigMain* Config::release_main() {
  
  ::common::v1::ConfigMain* temp = main_;
  main_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigMain* Config::unsafe_arena_release_main() {
  // @@protoc_insertion_point(field_release:common.v1.Config.main)
  
  ::common::v1::ConfigMain* temp = main_;
  main_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigMain* Config::_internal_mutable_main() {
  
  if (main_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigMain>(GetArenaForAllocation());
    main_ = p;
  }
  return main_;
}
inline ::common::v1::ConfigMain* Config::mutable_main() {
  ::common::v1::ConfigMain* _msg = _internal_mutable_main();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.main)
  return _msg;
}
inline void Config::set_allocated_main(::common::v1::ConfigMain* main) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete main_;
  }
  if (main) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigMain>::GetOwningArena(main);
    if (message_arena != submessage_arena) {
      main = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main, submessage_arena);
    }
    
  } else {
    
  }
  main_ = main;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.main)
}

// .common.v1.ConfigServices services = 2 [json_name = "services"];
inline bool Config::_internal_has_services() const {
  return this != internal_default_instance() && services_ != nullptr;
}
inline bool Config::has_services() const {
  return _internal_has_services();
}
inline void Config::clear_services() {
  if (GetArenaForAllocation() == nullptr && services_ != nullptr) {
    delete services_;
  }
  services_ = nullptr;
}
inline const ::common::v1::ConfigServices& Config::_internal_services() const {
  const ::common::v1::ConfigServices* p = services_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigServices&>(
      ::common::v1::_ConfigServices_default_instance_);
}
inline const ::common::v1::ConfigServices& Config::services() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.services)
  return _internal_services();
}
inline void Config::unsafe_arena_set_allocated_services(
    ::common::v1::ConfigServices* services) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(services_);
  }
  services_ = services;
  if (services) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.services)
}
inline ::common::v1::ConfigServices* Config::release_services() {
  
  ::common::v1::ConfigServices* temp = services_;
  services_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigServices* Config::unsafe_arena_release_services() {
  // @@protoc_insertion_point(field_release:common.v1.Config.services)
  
  ::common::v1::ConfigServices* temp = services_;
  services_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigServices* Config::_internal_mutable_services() {
  
  if (services_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigServices>(GetArenaForAllocation());
    services_ = p;
  }
  return services_;
}
inline ::common::v1::ConfigServices* Config::mutable_services() {
  ::common::v1::ConfigServices* _msg = _internal_mutable_services();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.services)
  return _msg;
}
inline void Config::set_allocated_services(::common::v1::ConfigServices* services) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete services_;
  }
  if (services) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigServices>::GetOwningArena(services);
    if (message_arena != submessage_arena) {
      services = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, services, submessage_arena);
    }
    
  } else {
    
  }
  services_ = services;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.services)
}

// .common.v1.ConfigSecurity security = 3 [json_name = "security"];
inline bool Config::_internal_has_security() const {
  return this != internal_default_instance() && security_ != nullptr;
}
inline bool Config::has_security() const {
  return _internal_has_security();
}
inline void Config::clear_security() {
  if (GetArenaForAllocation() == nullptr && security_ != nullptr) {
    delete security_;
  }
  security_ = nullptr;
}
inline const ::common::v1::ConfigSecurity& Config::_internal_security() const {
  const ::common::v1::ConfigSecurity* p = security_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigSecurity&>(
      ::common::v1::_ConfigSecurity_default_instance_);
}
inline const ::common::v1::ConfigSecurity& Config::security() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.security)
  return _internal_security();
}
inline void Config::unsafe_arena_set_allocated_security(
    ::common::v1::ConfigSecurity* security) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(security_);
  }
  security_ = security;
  if (security) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.security)
}
inline ::common::v1::ConfigSecurity* Config::release_security() {
  
  ::common::v1::ConfigSecurity* temp = security_;
  security_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigSecurity* Config::unsafe_arena_release_security() {
  // @@protoc_insertion_point(field_release:common.v1.Config.security)
  
  ::common::v1::ConfigSecurity* temp = security_;
  security_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigSecurity* Config::_internal_mutable_security() {
  
  if (security_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigSecurity>(GetArenaForAllocation());
    security_ = p;
  }
  return security_;
}
inline ::common::v1::ConfigSecurity* Config::mutable_security() {
  ::common::v1::ConfigSecurity* _msg = _internal_mutable_security();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.security)
  return _msg;
}
inline void Config::set_allocated_security(::common::v1::ConfigSecurity* security) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete security_;
  }
  if (security) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigSecurity>::GetOwningArena(security);
    if (message_arena != submessage_arena) {
      security = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, security, submessage_arena);
    }
    
  } else {
    
  }
  security_ = security;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.security)
}

// .common.v1.CacheConfig cache = 4 [json_name = "cache"];
inline bool Config::_internal_has_cache() const {
  return this != internal_default_instance() && cache_ != nullptr;
}
inline bool Config::has_cache() const {
  return _internal_has_cache();
}
inline void Config::clear_cache() {
  if (GetArenaForAllocation() == nullptr && cache_ != nullptr) {
    delete cache_;
  }
  cache_ = nullptr;
}
inline const ::common::v1::CacheConfig& Config::_internal_cache() const {
  const ::common::v1::CacheConfig* p = cache_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::CacheConfig&>(
      ::common::v1::_CacheConfig_default_instance_);
}
inline const ::common::v1::CacheConfig& Config::cache() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.cache)
  return _internal_cache();
}
inline void Config::unsafe_arena_set_allocated_cache(
    ::common::v1::CacheConfig* cache) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cache_);
  }
  cache_ = cache;
  if (cache) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.cache)
}
inline ::common::v1::CacheConfig* Config::release_cache() {
  
  ::common::v1::CacheConfig* temp = cache_;
  cache_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::CacheConfig* Config::unsafe_arena_release_cache() {
  // @@protoc_insertion_point(field_release:common.v1.Config.cache)
  
  ::common::v1::CacheConfig* temp = cache_;
  cache_ = nullptr;
  return temp;
}
inline ::common::v1::CacheConfig* Config::_internal_mutable_cache() {
  
  if (cache_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::CacheConfig>(GetArenaForAllocation());
    cache_ = p;
  }
  return cache_;
}
inline ::common::v1::CacheConfig* Config::mutable_cache() {
  ::common::v1::CacheConfig* _msg = _internal_mutable_cache();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.cache)
  return _msg;
}
inline void Config::set_allocated_cache(::common::v1::CacheConfig* cache) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cache_;
  }
  if (cache) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::CacheConfig>::GetOwningArena(cache);
    if (message_arena != submessage_arena) {
      cache = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache, submessage_arena);
    }
    
  } else {
    
  }
  cache_ = cache;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.cache)
}

// .common.v1.ConfigMetrics metrics = 5 [json_name = "metrics"];
inline bool Config::_internal_has_metrics() const {
  return this != internal_default_instance() && metrics_ != nullptr;
}
inline bool Config::has_metrics() const {
  return _internal_has_metrics();
}
inline void Config::clear_metrics() {
  if (GetArenaForAllocation() == nullptr && metrics_ != nullptr) {
    delete metrics_;
  }
  metrics_ = nullptr;
}
inline const ::common::v1::ConfigMetrics& Config::_internal_metrics() const {
  const ::common::v1::ConfigMetrics* p = metrics_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigMetrics&>(
      ::common::v1::_ConfigMetrics_default_instance_);
}
inline const ::common::v1::ConfigMetrics& Config::metrics() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.metrics)
  return _internal_metrics();
}
inline void Config::unsafe_arena_set_allocated_metrics(
    ::common::v1::ConfigMetrics* metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(metrics_);
  }
  metrics_ = metrics;
  if (metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.metrics)
}
inline ::common::v1::ConfigMetrics* Config::release_metrics() {
  
  ::common::v1::ConfigMetrics* temp = metrics_;
  metrics_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigMetrics* Config::unsafe_arena_release_metrics() {
  // @@protoc_insertion_point(field_release:common.v1.Config.metrics)
  
  ::common::v1::ConfigMetrics* temp = metrics_;
  metrics_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigMetrics* Config::_internal_mutable_metrics() {
  
  if (metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigMetrics>(GetArenaForAllocation());
    metrics_ = p;
  }
  return metrics_;
}
inline ::common::v1::ConfigMetrics* Config::mutable_metrics() {
  ::common::v1::ConfigMetrics* _msg = _internal_mutable_metrics();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.metrics)
  return _msg;
}
inline void Config::set_allocated_metrics(::common::v1::ConfigMetrics* metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete metrics_;
  }
  if (metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigMetrics>::GetOwningArena(metrics);
    if (message_arena != submessage_arena) {
      metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metrics, submessage_arena);
    }
    
  } else {
    
  }
  metrics_ = metrics;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.metrics)
}

// .common.v1.ConfigSSO sso = 6 [json_name = "sso"];
inline bool Config::_internal_has_sso() const {
  return this != internal_default_instance() && sso_ != nullptr;
}
inline bool Config::has_sso() const {
  return _internal_has_sso();
}
inline void Config::clear_sso() {
  if (GetArenaForAllocation() == nullptr && sso_ != nullptr) {
    delete sso_;
  }
  sso_ = nullptr;
}
inline const ::common::v1::ConfigSSO& Config::_internal_sso() const {
  const ::common::v1::ConfigSSO* p = sso_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigSSO&>(
      ::common::v1::_ConfigSSO_default_instance_);
}
inline const ::common::v1::ConfigSSO& Config::sso() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.sso)
  return _internal_sso();
}
inline void Config::unsafe_arena_set_allocated_sso(
    ::common::v1::ConfigSSO* sso) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sso_);
  }
  sso_ = sso;
  if (sso) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.sso)
}
inline ::common::v1::ConfigSSO* Config::release_sso() {
  
  ::common::v1::ConfigSSO* temp = sso_;
  sso_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigSSO* Config::unsafe_arena_release_sso() {
  // @@protoc_insertion_point(field_release:common.v1.Config.sso)
  
  ::common::v1::ConfigSSO* temp = sso_;
  sso_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigSSO* Config::_internal_mutable_sso() {
  
  if (sso_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigSSO>(GetArenaForAllocation());
    sso_ = p;
  }
  return sso_;
}
inline ::common::v1::ConfigSSO* Config::mutable_sso() {
  ::common::v1::ConfigSSO* _msg = _internal_mutable_sso();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.sso)
  return _msg;
}
inline void Config::set_allocated_sso(::common::v1::ConfigSSO* sso) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sso_;
  }
  if (sso) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigSSO>::GetOwningArena(sso);
    if (message_arena != submessage_arena) {
      sso = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sso, submessage_arena);
    }
    
  } else {
    
  }
  sso_ = sso;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.sso)
}

// .common.v1.ConfigSql sql = 7 [json_name = "sql"];
inline bool Config::_internal_has_sql() const {
  return this != internal_default_instance() && sql_ != nullptr;
}
inline bool Config::has_sql() const {
  return _internal_has_sql();
}
inline void Config::clear_sql() {
  if (GetArenaForAllocation() == nullptr && sql_ != nullptr) {
    delete sql_;
  }
  sql_ = nullptr;
}
inline const ::common::v1::ConfigSql& Config::_internal_sql() const {
  const ::common::v1::ConfigSql* p = sql_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigSql&>(
      ::common::v1::_ConfigSql_default_instance_);
}
inline const ::common::v1::ConfigSql& Config::sql() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.sql)
  return _internal_sql();
}
inline void Config::unsafe_arena_set_allocated_sql(
    ::common::v1::ConfigSql* sql) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sql_);
  }
  sql_ = sql;
  if (sql) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.sql)
}
inline ::common::v1::ConfigSql* Config::release_sql() {
  
  ::common::v1::ConfigSql* temp = sql_;
  sql_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigSql* Config::unsafe_arena_release_sql() {
  // @@protoc_insertion_point(field_release:common.v1.Config.sql)
  
  ::common::v1::ConfigSql* temp = sql_;
  sql_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigSql* Config::_internal_mutable_sql() {
  
  if (sql_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigSql>(GetArenaForAllocation());
    sql_ = p;
  }
  return sql_;
}
inline ::common::v1::ConfigSql* Config::mutable_sql() {
  ::common::v1::ConfigSql* _msg = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.sql)
  return _msg;
}
inline void Config::set_allocated_sql(::common::v1::ConfigSql* sql) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sql_;
  }
  if (sql) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigSql>::GetOwningArena(sql);
    if (message_arena != submessage_arena) {
      sql = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sql, submessage_arena);
    }
    
  } else {
    
  }
  sql_ = sql;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.sql)
}

// .common.v1.ConfigPassword password = 8 [json_name = "password"];
inline bool Config::_internal_has_password() const {
  return this != internal_default_instance() && password_ != nullptr;
}
inline bool Config::has_password() const {
  return _internal_has_password();
}
inline void Config::clear_password() {
  if (GetArenaForAllocation() == nullptr && password_ != nullptr) {
    delete password_;
  }
  password_ = nullptr;
}
inline const ::common::v1::ConfigPassword& Config::_internal_password() const {
  const ::common::v1::ConfigPassword* p = password_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigPassword&>(
      ::common::v1::_ConfigPassword_default_instance_);
}
inline const ::common::v1::ConfigPassword& Config::password() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.password)
  return _internal_password();
}
inline void Config::unsafe_arena_set_allocated_password(
    ::common::v1::ConfigPassword* password) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(password_);
  }
  password_ = password;
  if (password) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.password)
}
inline ::common::v1::ConfigPassword* Config::release_password() {
  
  ::common::v1::ConfigPassword* temp = password_;
  password_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigPassword* Config::unsafe_arena_release_password() {
  // @@protoc_insertion_point(field_release:common.v1.Config.password)
  
  ::common::v1::ConfigPassword* temp = password_;
  password_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigPassword* Config::_internal_mutable_password() {
  
  if (password_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigPassword>(GetArenaForAllocation());
    password_ = p;
  }
  return password_;
}
inline ::common::v1::ConfigPassword* Config::mutable_password() {
  ::common::v1::ConfigPassword* _msg = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.password)
  return _msg;
}
inline void Config::set_allocated_password(::common::v1::ConfigPassword* password) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete password_;
  }
  if (password) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigPassword>::GetOwningArena(password);
    if (message_arena != submessage_arena) {
      password = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, password, submessage_arena);
    }
    
  } else {
    
  }
  password_ = password;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.password)
}

// .common.v1.ConfigFile file = 9 [json_name = "file"];
inline bool Config::_internal_has_file() const {
  return this != internal_default_instance() && file_ != nullptr;
}
inline bool Config::has_file() const {
  return _internal_has_file();
}
inline void Config::clear_file() {
  if (GetArenaForAllocation() == nullptr && file_ != nullptr) {
    delete file_;
  }
  file_ = nullptr;
}
inline const ::common::v1::ConfigFile& Config::_internal_file() const {
  const ::common::v1::ConfigFile* p = file_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigFile&>(
      ::common::v1::_ConfigFile_default_instance_);
}
inline const ::common::v1::ConfigFile& Config::file() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.file)
  return _internal_file();
}
inline void Config::unsafe_arena_set_allocated_file(
    ::common::v1::ConfigFile* file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_);
  }
  file_ = file;
  if (file) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.file)
}
inline ::common::v1::ConfigFile* Config::release_file() {
  
  ::common::v1::ConfigFile* temp = file_;
  file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigFile* Config::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_release:common.v1.Config.file)
  
  ::common::v1::ConfigFile* temp = file_;
  file_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigFile* Config::_internal_mutable_file() {
  
  if (file_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigFile>(GetArenaForAllocation());
    file_ = p;
  }
  return file_;
}
inline ::common::v1::ConfigFile* Config::mutable_file() {
  ::common::v1::ConfigFile* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.file)
  return _msg;
}
inline void Config::set_allocated_file(::common::v1::ConfigFile* file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete file_;
  }
  if (file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigFile>::GetOwningArena(file);
    if (message_arena != submessage_arena) {
      file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.file)
}

// .common.v1.ConfigEmail email = 10 [json_name = "email"];
inline bool Config::_internal_has_email() const {
  return this != internal_default_instance() && email_ != nullptr;
}
inline bool Config::has_email() const {
  return _internal_has_email();
}
inline void Config::clear_email() {
  if (GetArenaForAllocation() == nullptr && email_ != nullptr) {
    delete email_;
  }
  email_ = nullptr;
}
inline const ::common::v1::ConfigEmail& Config::_internal_email() const {
  const ::common::v1::ConfigEmail* p = email_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigEmail&>(
      ::common::v1::_ConfigEmail_default_instance_);
}
inline const ::common::v1::ConfigEmail& Config::email() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.email)
  return _internal_email();
}
inline void Config::unsafe_arena_set_allocated_email(
    ::common::v1::ConfigEmail* email) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(email_);
  }
  email_ = email;
  if (email) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.email)
}
inline ::common::v1::ConfigEmail* Config::release_email() {
  
  ::common::v1::ConfigEmail* temp = email_;
  email_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigEmail* Config::unsafe_arena_release_email() {
  // @@protoc_insertion_point(field_release:common.v1.Config.email)
  
  ::common::v1::ConfigEmail* temp = email_;
  email_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigEmail* Config::_internal_mutable_email() {
  
  if (email_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigEmail>(GetArenaForAllocation());
    email_ = p;
  }
  return email_;
}
inline ::common::v1::ConfigEmail* Config::mutable_email() {
  ::common::v1::ConfigEmail* _msg = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.email)
  return _msg;
}
inline void Config::set_allocated_email(::common::v1::ConfigEmail* email) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete email_;
  }
  if (email) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigEmail>::GetOwningArena(email);
    if (message_arena != submessage_arena) {
      email = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, email, submessage_arena);
    }
    
  } else {
    
  }
  email_ = email;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.email)
}

// .common.v1.ConfigRateLimit rate_limit = 11 [json_name = "rateLimit"];
inline bool Config::_internal_has_rate_limit() const {
  return this != internal_default_instance() && rate_limit_ != nullptr;
}
inline bool Config::has_rate_limit() const {
  return _internal_has_rate_limit();
}
inline void Config::clear_rate_limit() {
  if (GetArenaForAllocation() == nullptr && rate_limit_ != nullptr) {
    delete rate_limit_;
  }
  rate_limit_ = nullptr;
}
inline const ::common::v1::ConfigRateLimit& Config::_internal_rate_limit() const {
  const ::common::v1::ConfigRateLimit* p = rate_limit_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigRateLimit&>(
      ::common::v1::_ConfigRateLimit_default_instance_);
}
inline const ::common::v1::ConfigRateLimit& Config::rate_limit() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.rate_limit)
  return _internal_rate_limit();
}
inline void Config::unsafe_arena_set_allocated_rate_limit(
    ::common::v1::ConfigRateLimit* rate_limit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rate_limit_);
  }
  rate_limit_ = rate_limit;
  if (rate_limit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.rate_limit)
}
inline ::common::v1::ConfigRateLimit* Config::release_rate_limit() {
  
  ::common::v1::ConfigRateLimit* temp = rate_limit_;
  rate_limit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigRateLimit* Config::unsafe_arena_release_rate_limit() {
  // @@protoc_insertion_point(field_release:common.v1.Config.rate_limit)
  
  ::common::v1::ConfigRateLimit* temp = rate_limit_;
  rate_limit_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigRateLimit* Config::_internal_mutable_rate_limit() {
  
  if (rate_limit_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigRateLimit>(GetArenaForAllocation());
    rate_limit_ = p;
  }
  return rate_limit_;
}
inline ::common::v1::ConfigRateLimit* Config::mutable_rate_limit() {
  ::common::v1::ConfigRateLimit* _msg = _internal_mutable_rate_limit();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.rate_limit)
  return _msg;
}
inline void Config::set_allocated_rate_limit(::common::v1::ConfigRateLimit* rate_limit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rate_limit_;
  }
  if (rate_limit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigRateLimit>::GetOwningArena(rate_limit);
    if (message_arena != submessage_arena) {
      rate_limit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rate_limit, submessage_arena);
    }
    
  } else {
    
  }
  rate_limit_ = rate_limit;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.rate_limit)
}

// .common.v1.ConfigPrivacy privacy = 12 [json_name = "privacy"];
inline bool Config::_internal_has_privacy() const {
  return this != internal_default_instance() && privacy_ != nullptr;
}
inline bool Config::has_privacy() const {
  return _internal_has_privacy();
}
inline void Config::clear_privacy() {
  if (GetArenaForAllocation() == nullptr && privacy_ != nullptr) {
    delete privacy_;
  }
  privacy_ = nullptr;
}
inline const ::common::v1::ConfigPrivacy& Config::_internal_privacy() const {
  const ::common::v1::ConfigPrivacy* p = privacy_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigPrivacy&>(
      ::common::v1::_ConfigPrivacy_default_instance_);
}
inline const ::common::v1::ConfigPrivacy& Config::privacy() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.privacy)
  return _internal_privacy();
}
inline void Config::unsafe_arena_set_allocated_privacy(
    ::common::v1::ConfigPrivacy* privacy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(privacy_);
  }
  privacy_ = privacy;
  if (privacy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.privacy)
}
inline ::common::v1::ConfigPrivacy* Config::release_privacy() {
  
  ::common::v1::ConfigPrivacy* temp = privacy_;
  privacy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigPrivacy* Config::unsafe_arena_release_privacy() {
  // @@protoc_insertion_point(field_release:common.v1.Config.privacy)
  
  ::common::v1::ConfigPrivacy* temp = privacy_;
  privacy_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigPrivacy* Config::_internal_mutable_privacy() {
  
  if (privacy_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigPrivacy>(GetArenaForAllocation());
    privacy_ = p;
  }
  return privacy_;
}
inline ::common::v1::ConfigPrivacy* Config::mutable_privacy() {
  ::common::v1::ConfigPrivacy* _msg = _internal_mutable_privacy();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.privacy)
  return _msg;
}
inline void Config::set_allocated_privacy(::common::v1::ConfigPrivacy* privacy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete privacy_;
  }
  if (privacy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigPrivacy>::GetOwningArena(privacy);
    if (message_arena != submessage_arena) {
      privacy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, privacy, submessage_arena);
    }
    
  } else {
    
  }
  privacy_ = privacy;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.privacy)
}

// .common.v1.ConfigSupport support = 13 [json_name = "support"];
inline bool Config::_internal_has_support() const {
  return this != internal_default_instance() && support_ != nullptr;
}
inline bool Config::has_support() const {
  return _internal_has_support();
}
inline void Config::clear_support() {
  if (GetArenaForAllocation() == nullptr && support_ != nullptr) {
    delete support_;
  }
  support_ = nullptr;
}
inline const ::common::v1::ConfigSupport& Config::_internal_support() const {
  const ::common::v1::ConfigSupport* p = support_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigSupport&>(
      ::common::v1::_ConfigSupport_default_instance_);
}
inline const ::common::v1::ConfigSupport& Config::support() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.support)
  return _internal_support();
}
inline void Config::unsafe_arena_set_allocated_support(
    ::common::v1::ConfigSupport* support) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(support_);
  }
  support_ = support;
  if (support) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.support)
}
inline ::common::v1::ConfigSupport* Config::release_support() {
  
  ::common::v1::ConfigSupport* temp = support_;
  support_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigSupport* Config::unsafe_arena_release_support() {
  // @@protoc_insertion_point(field_release:common.v1.Config.support)
  
  ::common::v1::ConfigSupport* temp = support_;
  support_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigSupport* Config::_internal_mutable_support() {
  
  if (support_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigSupport>(GetArenaForAllocation());
    support_ = p;
  }
  return support_;
}
inline ::common::v1::ConfigSupport* Config::mutable_support() {
  ::common::v1::ConfigSupport* _msg = _internal_mutable_support();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.support)
  return _msg;
}
inline void Config::set_allocated_support(::common::v1::ConfigSupport* support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete support_;
  }
  if (support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigSupport>::GetOwningArena(support);
    if (message_arena != submessage_arena) {
      support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, support, submessage_arena);
    }
    
  } else {
    
  }
  support_ = support;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.support)
}

// .common.v1.ConfigLocalization localization = 14 [json_name = "localization"];
inline bool Config::_internal_has_localization() const {
  return this != internal_default_instance() && localization_ != nullptr;
}
inline bool Config::has_localization() const {
  return _internal_has_localization();
}
inline void Config::clear_localization() {
  if (GetArenaForAllocation() == nullptr && localization_ != nullptr) {
    delete localization_;
  }
  localization_ = nullptr;
}
inline const ::common::v1::ConfigLocalization& Config::_internal_localization() const {
  const ::common::v1::ConfigLocalization* p = localization_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigLocalization&>(
      ::common::v1::_ConfigLocalization_default_instance_);
}
inline const ::common::v1::ConfigLocalization& Config::localization() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.localization)
  return _internal_localization();
}
inline void Config::unsafe_arena_set_allocated_localization(
    ::common::v1::ConfigLocalization* localization) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(localization_);
  }
  localization_ = localization;
  if (localization) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.localization)
}
inline ::common::v1::ConfigLocalization* Config::release_localization() {
  
  ::common::v1::ConfigLocalization* temp = localization_;
  localization_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigLocalization* Config::unsafe_arena_release_localization() {
  // @@protoc_insertion_point(field_release:common.v1.Config.localization)
  
  ::common::v1::ConfigLocalization* temp = localization_;
  localization_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigLocalization* Config::_internal_mutable_localization() {
  
  if (localization_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigLocalization>(GetArenaForAllocation());
    localization_ = p;
  }
  return localization_;
}
inline ::common::v1::ConfigLocalization* Config::mutable_localization() {
  ::common::v1::ConfigLocalization* _msg = _internal_mutable_localization();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.localization)
  return _msg;
}
inline void Config::set_allocated_localization(::common::v1::ConfigLocalization* localization) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete localization_;
  }
  if (localization) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigLocalization>::GetOwningArena(localization);
    if (message_arena != submessage_arena) {
      localization = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, localization, submessage_arena);
    }
    
  } else {
    
  }
  localization_ = localization;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.localization)
}

// .common.v1.ConfigLdap ldap = 15 [json_name = "ldap"];
inline bool Config::_internal_has_ldap() const {
  return this != internal_default_instance() && ldap_ != nullptr;
}
inline bool Config::has_ldap() const {
  return _internal_has_ldap();
}
inline void Config::clear_ldap() {
  if (GetArenaForAllocation() == nullptr && ldap_ != nullptr) {
    delete ldap_;
  }
  ldap_ = nullptr;
}
inline const ::common::v1::ConfigLdap& Config::_internal_ldap() const {
  const ::common::v1::ConfigLdap* p = ldap_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigLdap&>(
      ::common::v1::_ConfigLdap_default_instance_);
}
inline const ::common::v1::ConfigLdap& Config::ldap() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.ldap)
  return _internal_ldap();
}
inline void Config::unsafe_arena_set_allocated_ldap(
    ::common::v1::ConfigLdap* ldap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ldap_);
  }
  ldap_ = ldap;
  if (ldap) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.ldap)
}
inline ::common::v1::ConfigLdap* Config::release_ldap() {
  
  ::common::v1::ConfigLdap* temp = ldap_;
  ldap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigLdap* Config::unsafe_arena_release_ldap() {
  // @@protoc_insertion_point(field_release:common.v1.Config.ldap)
  
  ::common::v1::ConfigLdap* temp = ldap_;
  ldap_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigLdap* Config::_internal_mutable_ldap() {
  
  if (ldap_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigLdap>(GetArenaForAllocation());
    ldap_ = p;
  }
  return ldap_;
}
inline ::common::v1::ConfigLdap* Config::mutable_ldap() {
  ::common::v1::ConfigLdap* _msg = _internal_mutable_ldap();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.ldap)
  return _msg;
}
inline void Config::set_allocated_ldap(::common::v1::ConfigLdap* ldap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ldap_;
  }
  if (ldap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigLdap>::GetOwningArena(ldap);
    if (message_arena != submessage_arena) {
      ldap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ldap, submessage_arena);
    }
    
  } else {
    
  }
  ldap_ = ldap;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.ldap)
}

// .common.v1.ConfigSaml saml = 16 [json_name = "saml"];
inline bool Config::_internal_has_saml() const {
  return this != internal_default_instance() && saml_ != nullptr;
}
inline bool Config::has_saml() const {
  return _internal_has_saml();
}
inline void Config::clear_saml() {
  if (GetArenaForAllocation() == nullptr && saml_ != nullptr) {
    delete saml_;
  }
  saml_ = nullptr;
}
inline const ::common::v1::ConfigSaml& Config::_internal_saml() const {
  const ::common::v1::ConfigSaml* p = saml_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigSaml&>(
      ::common::v1::_ConfigSaml_default_instance_);
}
inline const ::common::v1::ConfigSaml& Config::saml() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.saml)
  return _internal_saml();
}
inline void Config::unsafe_arena_set_allocated_saml(
    ::common::v1::ConfigSaml* saml) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(saml_);
  }
  saml_ = saml;
  if (saml) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.saml)
}
inline ::common::v1::ConfigSaml* Config::release_saml() {
  
  ::common::v1::ConfigSaml* temp = saml_;
  saml_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigSaml* Config::unsafe_arena_release_saml() {
  // @@protoc_insertion_point(field_release:common.v1.Config.saml)
  
  ::common::v1::ConfigSaml* temp = saml_;
  saml_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigSaml* Config::_internal_mutable_saml() {
  
  if (saml_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigSaml>(GetArenaForAllocation());
    saml_ = p;
  }
  return saml_;
}
inline ::common::v1::ConfigSaml* Config::mutable_saml() {
  ::common::v1::ConfigSaml* _msg = _internal_mutable_saml();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.saml)
  return _msg;
}
inline void Config::set_allocated_saml(::common::v1::ConfigSaml* saml) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete saml_;
  }
  if (saml) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigSaml>::GetOwningArena(saml);
    if (message_arena != submessage_arena) {
      saml = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, saml, submessage_arena);
    }
    
  } else {
    
  }
  saml_ = saml;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.saml)
}

// .common.v1.ConfigNativeApp native_app = 17 [json_name = "nativeApp"];
inline bool Config::_internal_has_native_app() const {
  return this != internal_default_instance() && native_app_ != nullptr;
}
inline bool Config::has_native_app() const {
  return _internal_has_native_app();
}
inline void Config::clear_native_app() {
  if (GetArenaForAllocation() == nullptr && native_app_ != nullptr) {
    delete native_app_;
  }
  native_app_ = nullptr;
}
inline const ::common::v1::ConfigNativeApp& Config::_internal_native_app() const {
  const ::common::v1::ConfigNativeApp* p = native_app_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigNativeApp&>(
      ::common::v1::_ConfigNativeApp_default_instance_);
}
inline const ::common::v1::ConfigNativeApp& Config::native_app() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.native_app)
  return _internal_native_app();
}
inline void Config::unsafe_arena_set_allocated_native_app(
    ::common::v1::ConfigNativeApp* native_app) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(native_app_);
  }
  native_app_ = native_app;
  if (native_app) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.native_app)
}
inline ::common::v1::ConfigNativeApp* Config::release_native_app() {
  
  ::common::v1::ConfigNativeApp* temp = native_app_;
  native_app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigNativeApp* Config::unsafe_arena_release_native_app() {
  // @@protoc_insertion_point(field_release:common.v1.Config.native_app)
  
  ::common::v1::ConfigNativeApp* temp = native_app_;
  native_app_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigNativeApp* Config::_internal_mutable_native_app() {
  
  if (native_app_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigNativeApp>(GetArenaForAllocation());
    native_app_ = p;
  }
  return native_app_;
}
inline ::common::v1::ConfigNativeApp* Config::mutable_native_app() {
  ::common::v1::ConfigNativeApp* _msg = _internal_mutable_native_app();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.native_app)
  return _msg;
}
inline void Config::set_allocated_native_app(::common::v1::ConfigNativeApp* native_app) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete native_app_;
  }
  if (native_app) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigNativeApp>::GetOwningArena(native_app);
    if (message_arena != submessage_arena) {
      native_app = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, native_app, submessage_arena);
    }
    
  } else {
    
  }
  native_app_ = native_app;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.native_app)
}

// .common.v1.ConfigMeilisearch meilisearch = 18 [json_name = "meilisearch"];
inline bool Config::_internal_has_meilisearch() const {
  return this != internal_default_instance() && meilisearch_ != nullptr;
}
inline bool Config::has_meilisearch() const {
  return _internal_has_meilisearch();
}
inline void Config::clear_meilisearch() {
  if (GetArenaForAllocation() == nullptr && meilisearch_ != nullptr) {
    delete meilisearch_;
  }
  meilisearch_ = nullptr;
}
inline const ::common::v1::ConfigMeilisearch& Config::_internal_meilisearch() const {
  const ::common::v1::ConfigMeilisearch* p = meilisearch_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigMeilisearch&>(
      ::common::v1::_ConfigMeilisearch_default_instance_);
}
inline const ::common::v1::ConfigMeilisearch& Config::meilisearch() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.meilisearch)
  return _internal_meilisearch();
}
inline void Config::unsafe_arena_set_allocated_meilisearch(
    ::common::v1::ConfigMeilisearch* meilisearch) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(meilisearch_);
  }
  meilisearch_ = meilisearch;
  if (meilisearch) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.meilisearch)
}
inline ::common::v1::ConfigMeilisearch* Config::release_meilisearch() {
  
  ::common::v1::ConfigMeilisearch* temp = meilisearch_;
  meilisearch_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigMeilisearch* Config::unsafe_arena_release_meilisearch() {
  // @@protoc_insertion_point(field_release:common.v1.Config.meilisearch)
  
  ::common::v1::ConfigMeilisearch* temp = meilisearch_;
  meilisearch_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigMeilisearch* Config::_internal_mutable_meilisearch() {
  
  if (meilisearch_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigMeilisearch>(GetArenaForAllocation());
    meilisearch_ = p;
  }
  return meilisearch_;
}
inline ::common::v1::ConfigMeilisearch* Config::mutable_meilisearch() {
  ::common::v1::ConfigMeilisearch* _msg = _internal_mutable_meilisearch();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.meilisearch)
  return _msg;
}
inline void Config::set_allocated_meilisearch(::common::v1::ConfigMeilisearch* meilisearch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete meilisearch_;
  }
  if (meilisearch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigMeilisearch>::GetOwningArena(meilisearch);
    if (message_arena != submessage_arena) {
      meilisearch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, meilisearch, submessage_arena);
    }
    
  } else {
    
  }
  meilisearch_ = meilisearch;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.meilisearch)
}

// .common.v1.ConfigBleve bleve = 19 [json_name = "bleve"];
inline bool Config::_internal_has_bleve() const {
  return this != internal_default_instance() && bleve_ != nullptr;
}
inline bool Config::has_bleve() const {
  return _internal_has_bleve();
}
inline void Config::clear_bleve() {
  if (GetArenaForAllocation() == nullptr && bleve_ != nullptr) {
    delete bleve_;
  }
  bleve_ = nullptr;
}
inline const ::common::v1::ConfigBleve& Config::_internal_bleve() const {
  const ::common::v1::ConfigBleve* p = bleve_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigBleve&>(
      ::common::v1::_ConfigBleve_default_instance_);
}
inline const ::common::v1::ConfigBleve& Config::bleve() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.bleve)
  return _internal_bleve();
}
inline void Config::unsafe_arena_set_allocated_bleve(
    ::common::v1::ConfigBleve* bleve) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bleve_);
  }
  bleve_ = bleve;
  if (bleve) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.bleve)
}
inline ::common::v1::ConfigBleve* Config::release_bleve() {
  
  ::common::v1::ConfigBleve* temp = bleve_;
  bleve_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigBleve* Config::unsafe_arena_release_bleve() {
  // @@protoc_insertion_point(field_release:common.v1.Config.bleve)
  
  ::common::v1::ConfigBleve* temp = bleve_;
  bleve_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigBleve* Config::_internal_mutable_bleve() {
  
  if (bleve_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigBleve>(GetArenaForAllocation());
    bleve_ = p;
  }
  return bleve_;
}
inline ::common::v1::ConfigBleve* Config::mutable_bleve() {
  ::common::v1::ConfigBleve* _msg = _internal_mutable_bleve();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.bleve)
  return _msg;
}
inline void Config::set_allocated_bleve(::common::v1::ConfigBleve* bleve) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bleve_;
  }
  if (bleve) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigBleve>::GetOwningArena(bleve);
    if (message_arena != submessage_arena) {
      bleve = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bleve, submessage_arena);
    }
    
  } else {
    
  }
  bleve_ = bleve;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.bleve)
}

// .common.v1.ConfigDataRetention data_retention = 20 [json_name = "dataRetention"];
inline bool Config::_internal_has_data_retention() const {
  return this != internal_default_instance() && data_retention_ != nullptr;
}
inline bool Config::has_data_retention() const {
  return _internal_has_data_retention();
}
inline void Config::clear_data_retention() {
  if (GetArenaForAllocation() == nullptr && data_retention_ != nullptr) {
    delete data_retention_;
  }
  data_retention_ = nullptr;
}
inline const ::common::v1::ConfigDataRetention& Config::_internal_data_retention() const {
  const ::common::v1::ConfigDataRetention* p = data_retention_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigDataRetention&>(
      ::common::v1::_ConfigDataRetention_default_instance_);
}
inline const ::common::v1::ConfigDataRetention& Config::data_retention() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.data_retention)
  return _internal_data_retention();
}
inline void Config::unsafe_arena_set_allocated_data_retention(
    ::common::v1::ConfigDataRetention* data_retention) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_retention_);
  }
  data_retention_ = data_retention;
  if (data_retention) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.data_retention)
}
inline ::common::v1::ConfigDataRetention* Config::release_data_retention() {
  
  ::common::v1::ConfigDataRetention* temp = data_retention_;
  data_retention_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigDataRetention* Config::unsafe_arena_release_data_retention() {
  // @@protoc_insertion_point(field_release:common.v1.Config.data_retention)
  
  ::common::v1::ConfigDataRetention* temp = data_retention_;
  data_retention_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigDataRetention* Config::_internal_mutable_data_retention() {
  
  if (data_retention_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigDataRetention>(GetArenaForAllocation());
    data_retention_ = p;
  }
  return data_retention_;
}
inline ::common::v1::ConfigDataRetention* Config::mutable_data_retention() {
  ::common::v1::ConfigDataRetention* _msg = _internal_mutable_data_retention();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.data_retention)
  return _msg;
}
inline void Config::set_allocated_data_retention(::common::v1::ConfigDataRetention* data_retention) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_retention_;
  }
  if (data_retention) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigDataRetention>::GetOwningArena(data_retention);
    if (message_arena != submessage_arena) {
      data_retention = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_retention, submessage_arena);
    }
    
  } else {
    
  }
  data_retention_ = data_retention;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.data_retention)
}

// .common.v1.ConfigImageProxy image_proxy = 21 [json_name = "imageProxy"];
inline bool Config::_internal_has_image_proxy() const {
  return this != internal_default_instance() && image_proxy_ != nullptr;
}
inline bool Config::has_image_proxy() const {
  return _internal_has_image_proxy();
}
inline void Config::clear_image_proxy() {
  if (GetArenaForAllocation() == nullptr && image_proxy_ != nullptr) {
    delete image_proxy_;
  }
  image_proxy_ = nullptr;
}
inline const ::common::v1::ConfigImageProxy& Config::_internal_image_proxy() const {
  const ::common::v1::ConfigImageProxy* p = image_proxy_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::ConfigImageProxy&>(
      ::common::v1::_ConfigImageProxy_default_instance_);
}
inline const ::common::v1::ConfigImageProxy& Config::image_proxy() const {
  // @@protoc_insertion_point(field_get:common.v1.Config.image_proxy)
  return _internal_image_proxy();
}
inline void Config::unsafe_arena_set_allocated_image_proxy(
    ::common::v1::ConfigImageProxy* image_proxy) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_proxy_);
  }
  image_proxy_ = image_proxy;
  if (image_proxy) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.Config.image_proxy)
}
inline ::common::v1::ConfigImageProxy* Config::release_image_proxy() {
  
  ::common::v1::ConfigImageProxy* temp = image_proxy_;
  image_proxy_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::ConfigImageProxy* Config::unsafe_arena_release_image_proxy() {
  // @@protoc_insertion_point(field_release:common.v1.Config.image_proxy)
  
  ::common::v1::ConfigImageProxy* temp = image_proxy_;
  image_proxy_ = nullptr;
  return temp;
}
inline ::common::v1::ConfigImageProxy* Config::_internal_mutable_image_proxy() {
  
  if (image_proxy_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::ConfigImageProxy>(GetArenaForAllocation());
    image_proxy_ = p;
  }
  return image_proxy_;
}
inline ::common::v1::ConfigImageProxy* Config::mutable_image_proxy() {
  ::common::v1::ConfigImageProxy* _msg = _internal_mutable_image_proxy();
  // @@protoc_insertion_point(field_mutable:common.v1.Config.image_proxy)
  return _msg;
}
inline void Config::set_allocated_image_proxy(::common::v1::ConfigImageProxy* image_proxy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_proxy_;
  }
  if (image_proxy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::ConfigImageProxy>::GetOwningArena(image_proxy);
    if (message_arena != submessage_arena) {
      image_proxy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image_proxy, submessage_arena);
    }
    
  } else {
    
  }
  image_proxy_ = image_proxy;
  // @@protoc_insertion_point(field_set_allocated:common.v1.Config.image_proxy)
}

// -------------------------------------------------------------------

// ConfigGetRequest

// -------------------------------------------------------------------

// ConfigGetResponse

// .common.v1.Config data = 1 [json_name = "data"];
inline bool ConfigGetResponse::_internal_has_data() const {
  return response_case() == kData;
}
inline bool ConfigGetResponse::has_data() const {
  return _internal_has_data();
}
inline void ConfigGetResponse::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void ConfigGetResponse::clear_data() {
  if (_internal_has_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete response_.data_;
    }
    clear_has_response();
  }
}
inline ::common::v1::Config* ConfigGetResponse::release_data() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigGetResponse.data)
  if (_internal_has_data()) {
    clear_has_response();
      ::common::v1::Config* temp = response_.data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::v1::Config& ConfigGetResponse::_internal_data() const {
  return _internal_has_data()
      ? *response_.data_
      : reinterpret_cast< ::common::v1::Config&>(::common::v1::_Config_default_instance_);
}
inline const ::common::v1::Config& ConfigGetResponse::data() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigGetResponse.data)
  return _internal_data();
}
inline ::common::v1::Config* ConfigGetResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.v1.ConfigGetResponse.data)
  if (_internal_has_data()) {
    clear_has_response();
    ::common::v1::Config* temp = response_.data_;
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConfigGetResponse::unsafe_arena_set_allocated_data(::common::v1::Config* data) {
  clear_response();
  if (data) {
    set_has_data();
    response_.data_ = data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigGetResponse.data)
}
inline ::common::v1::Config* ConfigGetResponse::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = CreateMaybeMessage< ::common::v1::Config >(GetArenaForAllocation());
  }
  return response_.data_;
}
inline ::common::v1::Config* ConfigGetResponse::mutable_data() {
  ::common::v1::Config* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigGetResponse.data)
  return _msg;
}

// .common.v1.AppError error = 2 [json_name = "error"];
inline bool ConfigGetResponse::_internal_has_error() const {
  return response_case() == kError;
}
inline bool ConfigGetResponse::has_error() const {
  return _internal_has_error();
}
inline void ConfigGetResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::common::v1::AppError* ConfigGetResponse::release_error() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigGetResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
      ::common::v1::AppError* temp = response_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::v1::AppError& ConfigGetResponse::_internal_error() const {
  return _internal_has_error()
      ? *response_.error_
      : reinterpret_cast< ::common::v1::AppError&>(::common::v1::_AppError_default_instance_);
}
inline const ::common::v1::AppError& ConfigGetResponse::error() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigGetResponse.error)
  return _internal_error();
}
inline ::common::v1::AppError* ConfigGetResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.v1.ConfigGetResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
    ::common::v1::AppError* temp = response_.error_;
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConfigGetResponse::unsafe_arena_set_allocated_error(::common::v1::AppError* error) {
  clear_response();
  if (error) {
    set_has_error();
    response_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigGetResponse.error)
}
inline ::common::v1::AppError* ConfigGetResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response();
    set_has_error();
    response_.error_ = CreateMaybeMessage< ::common::v1::AppError >(GetArenaForAllocation());
  }
  return response_.error_;
}
inline ::common::v1::AppError* ConfigGetResponse::mutable_error() {
  ::common::v1::AppError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigGetResponse.error)
  return _msg;
}

inline bool ConfigGetResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ConfigGetResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ConfigGetResponse::ResponseCase ConfigGetResponse::response_case() const {
  return ConfigGetResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConfigUpdateRequest

// .common.v1.Config config = 1 [json_name = "config"];
inline bool ConfigUpdateRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool ConfigUpdateRequest::has_config() const {
  return _internal_has_config();
}
inline void ConfigUpdateRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::common::v1::Config& ConfigUpdateRequest::_internal_config() const {
  const ::common::v1::Config* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::common::v1::Config&>(
      ::common::v1::_Config_default_instance_);
}
inline const ::common::v1::Config& ConfigUpdateRequest::config() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigUpdateRequest.config)
  return _internal_config();
}
inline void ConfigUpdateRequest::unsafe_arena_set_allocated_config(
    ::common::v1::Config* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigUpdateRequest.config)
}
inline ::common::v1::Config* ConfigUpdateRequest::release_config() {
  
  ::common::v1::Config* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::common::v1::Config* ConfigUpdateRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigUpdateRequest.config)
  
  ::common::v1::Config* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::common::v1::Config* ConfigUpdateRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::v1::Config>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::common::v1::Config* ConfigUpdateRequest::mutable_config() {
  ::common::v1::Config* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigUpdateRequest.config)
  return _msg;
}
inline void ConfigUpdateRequest::set_allocated_config(::common::v1::Config* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::common::v1::Config>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigUpdateRequest.config)
}

// -------------------------------------------------------------------

// ConfigUpdateResponse

// .common.v1.Config data = 1 [json_name = "data"];
inline bool ConfigUpdateResponse::_internal_has_data() const {
  return response_case() == kData;
}
inline bool ConfigUpdateResponse::has_data() const {
  return _internal_has_data();
}
inline void ConfigUpdateResponse::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void ConfigUpdateResponse::clear_data() {
  if (_internal_has_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete response_.data_;
    }
    clear_has_response();
  }
}
inline ::common::v1::Config* ConfigUpdateResponse::release_data() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigUpdateResponse.data)
  if (_internal_has_data()) {
    clear_has_response();
      ::common::v1::Config* temp = response_.data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::v1::Config& ConfigUpdateResponse::_internal_data() const {
  return _internal_has_data()
      ? *response_.data_
      : reinterpret_cast< ::common::v1::Config&>(::common::v1::_Config_default_instance_);
}
inline const ::common::v1::Config& ConfigUpdateResponse::data() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigUpdateResponse.data)
  return _internal_data();
}
inline ::common::v1::Config* ConfigUpdateResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.v1.ConfigUpdateResponse.data)
  if (_internal_has_data()) {
    clear_has_response();
    ::common::v1::Config* temp = response_.data_;
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConfigUpdateResponse::unsafe_arena_set_allocated_data(::common::v1::Config* data) {
  clear_response();
  if (data) {
    set_has_data();
    response_.data_ = data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigUpdateResponse.data)
}
inline ::common::v1::Config* ConfigUpdateResponse::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = CreateMaybeMessage< ::common::v1::Config >(GetArenaForAllocation());
  }
  return response_.data_;
}
inline ::common::v1::Config* ConfigUpdateResponse::mutable_data() {
  ::common::v1::Config* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigUpdateResponse.data)
  return _msg;
}

// .common.v1.AppError error = 2 [json_name = "error"];
inline bool ConfigUpdateResponse::_internal_has_error() const {
  return response_case() == kError;
}
inline bool ConfigUpdateResponse::has_error() const {
  return _internal_has_error();
}
inline void ConfigUpdateResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::common::v1::AppError* ConfigUpdateResponse::release_error() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigUpdateResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
      ::common::v1::AppError* temp = response_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::v1::AppError& ConfigUpdateResponse::_internal_error() const {
  return _internal_has_error()
      ? *response_.error_
      : reinterpret_cast< ::common::v1::AppError&>(::common::v1::_AppError_default_instance_);
}
inline const ::common::v1::AppError& ConfigUpdateResponse::error() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigUpdateResponse.error)
  return _internal_error();
}
inline ::common::v1::AppError* ConfigUpdateResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.v1.ConfigUpdateResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
    ::common::v1::AppError* temp = response_.error_;
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConfigUpdateResponse::unsafe_arena_set_allocated_error(::common::v1::AppError* error) {
  clear_response();
  if (error) {
    set_has_error();
    response_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigUpdateResponse.error)
}
inline ::common::v1::AppError* ConfigUpdateResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response();
    set_has_error();
    response_.error_ = CreateMaybeMessage< ::common::v1::AppError >(GetArenaForAllocation());
  }
  return response_.error_;
}
inline ::common::v1::AppError* ConfigUpdateResponse::mutable_error() {
  ::common::v1::AppError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigUpdateResponse.error)
  return _msg;
}

inline bool ConfigUpdateResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ConfigUpdateResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ConfigUpdateResponse::ResponseCase ConfigUpdateResponse::response_case() const {
  return ConfigUpdateResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConfigListenerResponse

// .common.v1.Config data = 1 [json_name = "data"];
inline bool ConfigListenerResponse::_internal_has_data() const {
  return response_case() == kData;
}
inline bool ConfigListenerResponse::has_data() const {
  return _internal_has_data();
}
inline void ConfigListenerResponse::set_has_data() {
  _oneof_case_[0] = kData;
}
inline void ConfigListenerResponse::clear_data() {
  if (_internal_has_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete response_.data_;
    }
    clear_has_response();
  }
}
inline ::common::v1::Config* ConfigListenerResponse::release_data() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigListenerResponse.data)
  if (_internal_has_data()) {
    clear_has_response();
      ::common::v1::Config* temp = response_.data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::v1::Config& ConfigListenerResponse::_internal_data() const {
  return _internal_has_data()
      ? *response_.data_
      : reinterpret_cast< ::common::v1::Config&>(::common::v1::_Config_default_instance_);
}
inline const ::common::v1::Config& ConfigListenerResponse::data() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigListenerResponse.data)
  return _internal_data();
}
inline ::common::v1::Config* ConfigListenerResponse::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.v1.ConfigListenerResponse.data)
  if (_internal_has_data()) {
    clear_has_response();
    ::common::v1::Config* temp = response_.data_;
    response_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConfigListenerResponse::unsafe_arena_set_allocated_data(::common::v1::Config* data) {
  clear_response();
  if (data) {
    set_has_data();
    response_.data_ = data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigListenerResponse.data)
}
inline ::common::v1::Config* ConfigListenerResponse::_internal_mutable_data() {
  if (!_internal_has_data()) {
    clear_response();
    set_has_data();
    response_.data_ = CreateMaybeMessage< ::common::v1::Config >(GetArenaForAllocation());
  }
  return response_.data_;
}
inline ::common::v1::Config* ConfigListenerResponse::mutable_data() {
  ::common::v1::Config* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigListenerResponse.data)
  return _msg;
}

// .common.v1.AppError error = 2 [json_name = "error"];
inline bool ConfigListenerResponse::_internal_has_error() const {
  return response_case() == kError;
}
inline bool ConfigListenerResponse::has_error() const {
  return _internal_has_error();
}
inline void ConfigListenerResponse::set_has_error() {
  _oneof_case_[0] = kError;
}
inline ::common::v1::AppError* ConfigListenerResponse::release_error() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigListenerResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
      ::common::v1::AppError* temp = response_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::common::v1::AppError& ConfigListenerResponse::_internal_error() const {
  return _internal_has_error()
      ? *response_.error_
      : reinterpret_cast< ::common::v1::AppError&>(::common::v1::_AppError_default_instance_);
}
inline const ::common::v1::AppError& ConfigListenerResponse::error() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigListenerResponse.error)
  return _internal_error();
}
inline ::common::v1::AppError* ConfigListenerResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:common.v1.ConfigListenerResponse.error)
  if (_internal_has_error()) {
    clear_has_response();
    ::common::v1::AppError* temp = response_.error_;
    response_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ConfigListenerResponse::unsafe_arena_set_allocated_error(::common::v1::AppError* error) {
  clear_response();
  if (error) {
    set_has_error();
    response_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:common.v1.ConfigListenerResponse.error)
}
inline ::common::v1::AppError* ConfigListenerResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_response();
    set_has_error();
    response_.error_ = CreateMaybeMessage< ::common::v1::AppError >(GetArenaForAllocation());
  }
  return response_.error_;
}
inline ::common::v1::AppError* ConfigListenerResponse::mutable_error() {
  ::common::v1::AppError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigListenerResponse.error)
  return _msg;
}

inline bool ConfigListenerResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void ConfigListenerResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline ConfigListenerResponse::ResponseCase ConfigListenerResponse::response_case() const {
  return ConfigListenerResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ConfigListenerRequest

// string client_id = 1 [json_name = "clientId"];
inline void ConfigListenerRequest::clear_client_id() {
  client_id_.ClearToEmpty();
}
inline const std::string& ConfigListenerRequest::client_id() const {
  // @@protoc_insertion_point(field_get:common.v1.ConfigListenerRequest.client_id)
  return _internal_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfigListenerRequest::set_client_id(ArgT0&& arg0, ArgT... args) {
 
 client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:common.v1.ConfigListenerRequest.client_id)
}
inline std::string* ConfigListenerRequest::mutable_client_id() {
  std::string* _s = _internal_mutable_client_id();
  // @@protoc_insertion_point(field_mutable:common.v1.ConfigListenerRequest.client_id)
  return _s;
}
inline const std::string& ConfigListenerRequest::_internal_client_id() const {
  return client_id_.Get();
}
inline void ConfigListenerRequest::_internal_set_client_id(const std::string& value) {
  
  client_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ConfigListenerRequest::_internal_mutable_client_id() {
  
  return client_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ConfigListenerRequest::release_client_id() {
  // @@protoc_insertion_point(field_release:common.v1.ConfigListenerRequest.client_id)
  return client_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ConfigListenerRequest::set_allocated_client_id(std::string* client_id) {
  if (client_id != nullptr) {
    
  } else {
    
  }
  client_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), client_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    client_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:common.v1.ConfigListenerRequest.client_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace common

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2fv1_2fconfig_2eproto
