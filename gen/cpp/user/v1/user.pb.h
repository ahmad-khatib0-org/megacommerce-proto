// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user/v1/user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_2fv1_2fuser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_2fv1_2fuser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2fv1_2fuser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2fv1_2fuser_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_2fv1_2fuser_2eproto;
namespace user {
namespace v1 {
class CreateSupplierRequest;
struct CreateSupplierRequestDefaultTypeInternal;
extern CreateSupplierRequestDefaultTypeInternal _CreateSupplierRequest_default_instance_;
class CreateSupplierResponse;
struct CreateSupplierResponseDefaultTypeInternal;
extern CreateSupplierResponseDefaultTypeInternal _CreateSupplierResponse_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class User_NotifyPropsEntry_DoNotUse;
struct User_NotifyPropsEntry_DoNotUseDefaultTypeInternal;
extern User_NotifyPropsEntry_DoNotUseDefaultTypeInternal _User_NotifyPropsEntry_DoNotUse_default_instance_;
class User_PropsEntry_DoNotUse;
struct User_PropsEntry_DoNotUseDefaultTypeInternal;
extern User_PropsEntry_DoNotUseDefaultTypeInternal _User_PropsEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace user
PROTOBUF_NAMESPACE_OPEN
template<> ::user::v1::CreateSupplierRequest* Arena::CreateMaybeMessage<::user::v1::CreateSupplierRequest>(Arena*);
template<> ::user::v1::CreateSupplierResponse* Arena::CreateMaybeMessage<::user::v1::CreateSupplierResponse>(Arena*);
template<> ::user::v1::User* Arena::CreateMaybeMessage<::user::v1::User>(Arena*);
template<> ::user::v1::User_NotifyPropsEntry_DoNotUse* Arena::CreateMaybeMessage<::user::v1::User_NotifyPropsEntry_DoNotUse>(Arena*);
template<> ::user::v1::User_PropsEntry_DoNotUse* Arena::CreateMaybeMessage<::user::v1::User_PropsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace user {
namespace v1 {

// ===================================================================

class User_PropsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<User_PropsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<User_PropsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  User_PropsEntry_DoNotUse();
  explicit constexpr User_PropsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit User_PropsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const User_PropsEntry_DoNotUse& other);
  static const User_PropsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const User_PropsEntry_DoNotUse*>(&_User_PropsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "user.v1.User.PropsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "user.v1.User.PropsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class User_NotifyPropsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<User_NotifyPropsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<User_NotifyPropsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  User_NotifyPropsEntry_DoNotUse();
  explicit constexpr User_NotifyPropsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit User_NotifyPropsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const User_NotifyPropsEntry_DoNotUse& other);
  static const User_NotifyPropsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const User_NotifyPropsEntry_DoNotUse*>(&_User_NotifyPropsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "user.v1.User.NotifyPropsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "user.v1.User.NotifyPropsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.v1.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.v1.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPropsFieldNumber = 14,
    kNotifyPropsFieldNumber = 15,
    kIdFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kFirstNameFieldNumber = 3,
    kNicknameFieldNumber = 4,
    kLastNameFieldNumber = 5,
    kEmailFieldNumber = 6,
    kUserTypeFieldNumber = 7,
    kMembershipFieldNumber = 8,
    kPasswordFieldNumber = 10,
    kAuthDataFieldNumber = 11,
    kAuthServiceFieldNumber = 12,
    kRolesFieldNumber = 13,
    kLocaleFieldNumber = 19,
    kMfaSecretFieldNumber = 21,
    kIsEmailVerifiedFieldNumber = 9,
    kMfaActiveFieldNumber = 20,
    kFailedAttemptsFieldNumber = 18,
    kLastPasswordUpdateFieldNumber = 16,
    kLastPictureUpdateFieldNumber = 17,
    kLastActivityAtFieldNumber = 22,
    kLastLoginFieldNumber = 23,
    kCreatedAtFieldNumber = 24,
    kUpdatedAtFieldNumber = 25,
    kDeletedAtFieldNumber = 26,
  };
  // map<string, string> props = 14 [json_name = "props"];
  int props_size() const;
  private:
  int _internal_props_size() const;
  public:
  void clear_props();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_props() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_props();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      props() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_props();

  // map<string, string> notify_props = 15 [json_name = "notifyProps"];
  int notify_props_size() const;
  private:
  int _internal_notify_props_size() const;
  public:
  void clear_notify_props();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_notify_props() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_notify_props();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      notify_props() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_notify_props();

  // optional string id = 1 [json_name = "id"];
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string username = 2 [json_name = "username"];
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string first_name = 3 [json_name = "firstName"];
  bool has_first_name() const;
  private:
  bool _internal_has_first_name() const;
  public:
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // optional string nickname = 4 [json_name = "nickname"];
  bool has_nickname() const;
  private:
  bool _internal_has_nickname() const;
  public:
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // optional string last_name = 5 [json_name = "lastName"];
  bool has_last_name() const;
  private:
  bool _internal_has_last_name() const;
  public:
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // optional string email = 6 [json_name = "email"];
  bool has_email() const;
  private:
  bool _internal_has_email() const;
  public:
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // optional string user_type = 7 [json_name = "userType"];
  bool has_user_type() const;
  private:
  bool _internal_has_user_type() const;
  public:
  void clear_user_type();
  const std::string& user_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_type();
  PROTOBUF_NODISCARD std::string* release_user_type();
  void set_allocated_user_type(std::string* user_type);
  private:
  const std::string& _internal_user_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_type(const std::string& value);
  std::string* _internal_mutable_user_type();
  public:

  // optional string membership = 8 [json_name = "membership"];
  bool has_membership() const;
  private:
  bool _internal_has_membership() const;
  public:
  void clear_membership();
  const std::string& membership() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_membership(ArgT0&& arg0, ArgT... args);
  std::string* mutable_membership();
  PROTOBUF_NODISCARD std::string* release_membership();
  void set_allocated_membership(std::string* membership);
  private:
  const std::string& _internal_membership() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_membership(const std::string& value);
  std::string* _internal_mutable_membership();
  public:

  // optional string password = 10 [json_name = "password"];
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string auth_data = 11 [json_name = "authData"];
  bool has_auth_data() const;
  private:
  bool _internal_has_auth_data() const;
  public:
  void clear_auth_data();
  const std::string& auth_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_data();
  PROTOBUF_NODISCARD std::string* release_auth_data();
  void set_allocated_auth_data(std::string* auth_data);
  private:
  const std::string& _internal_auth_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_data(const std::string& value);
  std::string* _internal_mutable_auth_data();
  public:

  // optional string auth_service = 12 [json_name = "authService"];
  bool has_auth_service() const;
  private:
  bool _internal_has_auth_service() const;
  public:
  void clear_auth_service();
  const std::string& auth_service() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_service(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_service();
  PROTOBUF_NODISCARD std::string* release_auth_service();
  void set_allocated_auth_service(std::string* auth_service);
  private:
  const std::string& _internal_auth_service() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_service(const std::string& value);
  std::string* _internal_mutable_auth_service();
  public:

  // optional string roles = 13 [json_name = "roles"];
  bool has_roles() const;
  private:
  bool _internal_has_roles() const;
  public:
  void clear_roles();
  const std::string& roles() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roles(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roles();
  PROTOBUF_NODISCARD std::string* release_roles();
  void set_allocated_roles(std::string* roles);
  private:
  const std::string& _internal_roles() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roles(const std::string& value);
  std::string* _internal_mutable_roles();
  public:

  // optional string locale = 19 [json_name = "locale"];
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional string mfa_secret = 21 [json_name = "mfaSecret"];
  bool has_mfa_secret() const;
  private:
  bool _internal_has_mfa_secret() const;
  public:
  void clear_mfa_secret();
  const std::string& mfa_secret() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mfa_secret(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mfa_secret();
  PROTOBUF_NODISCARD std::string* release_mfa_secret();
  void set_allocated_mfa_secret(std::string* mfa_secret);
  private:
  const std::string& _internal_mfa_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mfa_secret(const std::string& value);
  std::string* _internal_mutable_mfa_secret();
  public:

  // optional bool is_email_verified = 9 [json_name = "isEmailVerified"];
  bool has_is_email_verified() const;
  private:
  bool _internal_has_is_email_verified() const;
  public:
  void clear_is_email_verified();
  bool is_email_verified() const;
  void set_is_email_verified(bool value);
  private:
  bool _internal_is_email_verified() const;
  void _internal_set_is_email_verified(bool value);
  public:

  // optional bool mfa_active = 20 [json_name = "mfaActive"];
  bool has_mfa_active() const;
  private:
  bool _internal_has_mfa_active() const;
  public:
  void clear_mfa_active();
  bool mfa_active() const;
  void set_mfa_active(bool value);
  private:
  bool _internal_mfa_active() const;
  void _internal_set_mfa_active(bool value);
  public:

  // optional int32 failed_attempts = 18 [json_name = "failedAttempts"];
  bool has_failed_attempts() const;
  private:
  bool _internal_has_failed_attempts() const;
  public:
  void clear_failed_attempts();
  int32_t failed_attempts() const;
  void set_failed_attempts(int32_t value);
  private:
  int32_t _internal_failed_attempts() const;
  void _internal_set_failed_attempts(int32_t value);
  public:

  // optional int64 last_password_update = 16 [json_name = "lastPasswordUpdate"];
  bool has_last_password_update() const;
  private:
  bool _internal_has_last_password_update() const;
  public:
  void clear_last_password_update();
  int64_t last_password_update() const;
  void set_last_password_update(int64_t value);
  private:
  int64_t _internal_last_password_update() const;
  void _internal_set_last_password_update(int64_t value);
  public:

  // optional int64 last_picture_update = 17 [json_name = "lastPictureUpdate"];
  bool has_last_picture_update() const;
  private:
  bool _internal_has_last_picture_update() const;
  public:
  void clear_last_picture_update();
  int64_t last_picture_update() const;
  void set_last_picture_update(int64_t value);
  private:
  int64_t _internal_last_picture_update() const;
  void _internal_set_last_picture_update(int64_t value);
  public:

  // optional int64 last_activity_at = 22 [json_name = "lastActivityAt"];
  bool has_last_activity_at() const;
  private:
  bool _internal_has_last_activity_at() const;
  public:
  void clear_last_activity_at();
  int64_t last_activity_at() const;
  void set_last_activity_at(int64_t value);
  private:
  int64_t _internal_last_activity_at() const;
  void _internal_set_last_activity_at(int64_t value);
  public:

  // optional int64 last_login = 23 [json_name = "lastLogin"];
  bool has_last_login() const;
  private:
  bool _internal_has_last_login() const;
  public:
  void clear_last_login();
  int64_t last_login() const;
  void set_last_login(int64_t value);
  private:
  int64_t _internal_last_login() const;
  void _internal_set_last_login(int64_t value);
  public:

  // optional int64 created_at = 24 [json_name = "createdAt"];
  bool has_created_at() const;
  private:
  bool _internal_has_created_at() const;
  public:
  void clear_created_at();
  int64_t created_at() const;
  void set_created_at(int64_t value);
  private:
  int64_t _internal_created_at() const;
  void _internal_set_created_at(int64_t value);
  public:

  // optional int64 updated_at = 25 [json_name = "updatedAt"];
  bool has_updated_at() const;
  private:
  bool _internal_has_updated_at() const;
  public:
  void clear_updated_at();
  int64_t updated_at() const;
  void set_updated_at(int64_t value);
  private:
  int64_t _internal_updated_at() const;
  void _internal_set_updated_at(int64_t value);
  public:

  // optional int64 deleted_at = 26 [json_name = "deletedAt"];
  bool has_deleted_at() const;
  private:
  bool _internal_has_deleted_at() const;
  public:
  void clear_deleted_at();
  int64_t deleted_at() const;
  void set_deleted_at(int64_t value);
  private:
  int64_t _internal_deleted_at() const;
  void _internal_set_deleted_at(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:user.v1.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      User_PropsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> props_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      User_NotifyPropsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> notify_props_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr membership_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_service_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roles_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mfa_secret_;
  bool is_email_verified_;
  bool mfa_active_;
  int32_t failed_attempts_;
  int64_t last_password_update_;
  int64_t last_picture_update_;
  int64_t last_activity_at_;
  int64_t last_login_;
  int64_t created_at_;
  int64_t updated_at_;
  int64_t deleted_at_;
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateSupplierRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:user.v1.CreateSupplierRequest) */ {
 public:
  inline CreateSupplierRequest() : CreateSupplierRequest(nullptr) {}
  ~CreateSupplierRequest() override;
  explicit constexpr CreateSupplierRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSupplierRequest(const CreateSupplierRequest& from);
  CreateSupplierRequest(CreateSupplierRequest&& from) noexcept
    : CreateSupplierRequest() {
    *this = ::std::move(from);
  }

  inline CreateSupplierRequest& operator=(const CreateSupplierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSupplierRequest& operator=(CreateSupplierRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSupplierRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSupplierRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSupplierRequest*>(
               &_CreateSupplierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateSupplierRequest& a, CreateSupplierRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSupplierRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSupplierRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSupplierRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSupplierRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateSupplierRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateSupplierRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSupplierRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.v1.CreateSupplierRequest";
  }
  protected:
  explicit CreateSupplierRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kEmailFieldNumber = 2,
    kFirstNameFieldNumber = 3,
    kLastNameFieldNumber = 4,
    kPasswordFieldNumber = 5,
    kMembershipFieldNumber = 6,
  };
  // string username = 1 [json_name = "username"];
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string email = 2 [json_name = "email"];
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string first_name = 3 [json_name = "firstName"];
  void clear_first_name();
  const std::string& first_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_name();
  PROTOBUF_NODISCARD std::string* release_first_name();
  void set_allocated_first_name(std::string* first_name);
  private:
  const std::string& _internal_first_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_name(const std::string& value);
  std::string* _internal_mutable_first_name();
  public:

  // string last_name = 4 [json_name = "lastName"];
  void clear_last_name();
  const std::string& last_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_name();
  PROTOBUF_NODISCARD std::string* release_last_name();
  void set_allocated_last_name(std::string* last_name);
  private:
  const std::string& _internal_last_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_name(const std::string& value);
  std::string* _internal_mutable_last_name();
  public:

  // string password = 5 [json_name = "password"];
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string membership = 6 [json_name = "membership"];
  void clear_membership();
  const std::string& membership() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_membership(ArgT0&& arg0, ArgT... args);
  std::string* mutable_membership();
  PROTOBUF_NODISCARD std::string* release_membership();
  void set_allocated_membership(std::string* membership);
  private:
  const std::string& _internal_membership() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_membership(const std::string& value);
  std::string* _internal_mutable_membership();
  public:

  // @@protoc_insertion_point(class_scope:user.v1.CreateSupplierRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr membership_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// -------------------------------------------------------------------

class CreateSupplierResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:user.v1.CreateSupplierResponse) */ {
 public:
  inline CreateSupplierResponse() : CreateSupplierResponse(nullptr) {}
  explicit constexpr CreateSupplierResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateSupplierResponse(const CreateSupplierResponse& from);
  CreateSupplierResponse(CreateSupplierResponse&& from) noexcept
    : CreateSupplierResponse() {
    *this = ::std::move(from);
  }

  inline CreateSupplierResponse& operator=(const CreateSupplierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSupplierResponse& operator=(CreateSupplierResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateSupplierResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateSupplierResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSupplierResponse*>(
               &_CreateSupplierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateSupplierResponse& a, CreateSupplierResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSupplierResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSupplierResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateSupplierResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateSupplierResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateSupplierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateSupplierResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "user.v1.CreateSupplierResponse";
  }
  protected:
  explicit CreateSupplierResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:user.v1.CreateSupplierResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2fv1_2fuser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// User

// optional string id = 1 [json_name = "id"];
inline bool User::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool User::has_id() const {
  return _internal_has_id();
}
inline void User::clear_id() {
  id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& User::id() const {
  // @@protoc_insertion_point(field_get:user.v1.User.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.id)
}
inline std::string* User::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:user.v1.User.id)
  return _s;
}
inline const std::string& User::_internal_id() const {
  return id_.Get();
}
inline void User::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:user.v1.User.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.id)
}

// optional string username = 2 [json_name = "username"];
inline bool User::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool User::has_username() const {
  return _internal_has_username();
}
inline void User::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& User::username() const {
  // @@protoc_insertion_point(field_get:user.v1.User.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_username(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.username)
}
inline std::string* User::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:user.v1.User.username)
  return _s;
}
inline const std::string& User::_internal_username() const {
  return username_.Get();
}
inline void User::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_username() {
  // @@protoc_insertion_point(field_release:user.v1.User.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.username)
}

// optional string first_name = 3 [json_name = "firstName"];
inline bool User::_internal_has_first_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool User::has_first_name() const {
  return _internal_has_first_name();
}
inline void User::clear_first_name() {
  first_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& User::first_name() const {
  // @@protoc_insertion_point(field_get:user.v1.User.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_first_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.first_name)
}
inline std::string* User::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:user.v1.User.first_name)
  return _s;
}
inline const std::string& User::_internal_first_name() const {
  return first_name_.Get();
}
inline void User::_internal_set_first_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_first_name() {
  _has_bits_[0] |= 0x00000004u;
  return first_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_first_name() {
  // @@protoc_insertion_point(field_release:user.v1.User.first_name)
  if (!_internal_has_first_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = first_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  first_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.first_name)
}

// optional string nickname = 4 [json_name = "nickname"];
inline bool User::_internal_has_nickname() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool User::has_nickname() const {
  return _internal_has_nickname();
}
inline void User::clear_nickname() {
  nickname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& User::nickname() const {
  // @@protoc_insertion_point(field_get:user.v1.User.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_nickname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.nickname)
}
inline std::string* User::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:user.v1.User.nickname)
  return _s;
}
inline const std::string& User::_internal_nickname() const {
  return nickname_.Get();
}
inline void User::_internal_set_nickname(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_nickname() {
  _has_bits_[0] |= 0x00000008u;
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_nickname() {
  // @@protoc_insertion_point(field_release:user.v1.User.nickname)
  if (!_internal_has_nickname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = nickname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.nickname)
}

// optional string last_name = 5 [json_name = "lastName"];
inline bool User::_internal_has_last_name() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool User::has_last_name() const {
  return _internal_has_last_name();
}
inline void User::clear_last_name() {
  last_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& User::last_name() const {
  // @@protoc_insertion_point(field_get:user.v1.User.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_last_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.last_name)
}
inline std::string* User::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:user.v1.User.last_name)
  return _s;
}
inline const std::string& User::_internal_last_name() const {
  return last_name_.Get();
}
inline void User::_internal_set_last_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_last_name() {
  _has_bits_[0] |= 0x00000010u;
  return last_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_last_name() {
  // @@protoc_insertion_point(field_release:user.v1.User.last_name)
  if (!_internal_has_last_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = last_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  last_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.last_name)
}

// optional string email = 6 [json_name = "email"];
inline bool User::_internal_has_email() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool User::has_email() const {
  return _internal_has_email();
}
inline void User::clear_email() {
  email_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& User::email() const {
  // @@protoc_insertion_point(field_get:user.v1.User.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_email(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.email)
}
inline std::string* User::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:user.v1.User.email)
  return _s;
}
inline const std::string& User::_internal_email() const {
  return email_.Get();
}
inline void User::_internal_set_email(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_email() {
  _has_bits_[0] |= 0x00000020u;
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_email() {
  // @@protoc_insertion_point(field_release:user.v1.User.email)
  if (!_internal_has_email()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = email_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.email)
}

// optional string user_type = 7 [json_name = "userType"];
inline bool User::_internal_has_user_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool User::has_user_type() const {
  return _internal_has_user_type();
}
inline void User::clear_user_type() {
  user_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& User::user_type() const {
  // @@protoc_insertion_point(field_get:user.v1.User.user_type)
  return _internal_user_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 user_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.user_type)
}
inline std::string* User::mutable_user_type() {
  std::string* _s = _internal_mutable_user_type();
  // @@protoc_insertion_point(field_mutable:user.v1.User.user_type)
  return _s;
}
inline const std::string& User::_internal_user_type() const {
  return user_type_.Get();
}
inline void User::_internal_set_user_type(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  user_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_type() {
  _has_bits_[0] |= 0x00000040u;
  return user_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_user_type() {
  // @@protoc_insertion_point(field_release:user.v1.User.user_type)
  if (!_internal_has_user_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = user_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_user_type(std::string* user_type) {
  if (user_type != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  user_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.user_type)
}

// optional string membership = 8 [json_name = "membership"];
inline bool User::_internal_has_membership() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool User::has_membership() const {
  return _internal_has_membership();
}
inline void User::clear_membership() {
  membership_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& User::membership() const {
  // @@protoc_insertion_point(field_get:user.v1.User.membership)
  return _internal_membership();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_membership(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 membership_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.membership)
}
inline std::string* User::mutable_membership() {
  std::string* _s = _internal_mutable_membership();
  // @@protoc_insertion_point(field_mutable:user.v1.User.membership)
  return _s;
}
inline const std::string& User::_internal_membership() const {
  return membership_.Get();
}
inline void User::_internal_set_membership(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  membership_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_membership() {
  _has_bits_[0] |= 0x00000080u;
  return membership_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_membership() {
  // @@protoc_insertion_point(field_release:user.v1.User.membership)
  if (!_internal_has_membership()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = membership_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (membership_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    membership_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_membership(std::string* membership) {
  if (membership != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  membership_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), membership,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (membership_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    membership_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.membership)
}

// optional bool is_email_verified = 9 [json_name = "isEmailVerified"];
inline bool User::_internal_has_is_email_verified() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool User::has_is_email_verified() const {
  return _internal_has_is_email_verified();
}
inline void User::clear_is_email_verified() {
  is_email_verified_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool User::_internal_is_email_verified() const {
  return is_email_verified_;
}
inline bool User::is_email_verified() const {
  // @@protoc_insertion_point(field_get:user.v1.User.is_email_verified)
  return _internal_is_email_verified();
}
inline void User::_internal_set_is_email_verified(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_email_verified_ = value;
}
inline void User::set_is_email_verified(bool value) {
  _internal_set_is_email_verified(value);
  // @@protoc_insertion_point(field_set:user.v1.User.is_email_verified)
}

// optional string password = 10 [json_name = "password"];
inline bool User::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool User::has_password() const {
  return _internal_has_password();
}
inline void User::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& User::password() const {
  // @@protoc_insertion_point(field_get:user.v1.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.password)
}
inline std::string* User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:user.v1.User.password)
  return _s;
}
inline const std::string& User::_internal_password() const {
  return password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000100u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_password() {
  // @@protoc_insertion_point(field_release:user.v1.User.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.password)
}

// optional string auth_data = 11 [json_name = "authData"];
inline bool User::_internal_has_auth_data() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool User::has_auth_data() const {
  return _internal_has_auth_data();
}
inline void User::clear_auth_data() {
  auth_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& User::auth_data() const {
  // @@protoc_insertion_point(field_get:user.v1.User.auth_data)
  return _internal_auth_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_auth_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.auth_data)
}
inline std::string* User::mutable_auth_data() {
  std::string* _s = _internal_mutable_auth_data();
  // @@protoc_insertion_point(field_mutable:user.v1.User.auth_data)
  return _s;
}
inline const std::string& User::_internal_auth_data() const {
  return auth_data_.Get();
}
inline void User::_internal_set_auth_data(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  auth_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_auth_data() {
  _has_bits_[0] |= 0x00000200u;
  return auth_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_auth_data() {
  // @@protoc_insertion_point(field_release:user.v1.User.auth_data)
  if (!_internal_has_auth_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = auth_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_auth_data(std::string* auth_data) {
  if (auth_data != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  auth_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.auth_data)
}

// optional string auth_service = 12 [json_name = "authService"];
inline bool User::_internal_has_auth_service() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool User::has_auth_service() const {
  return _internal_has_auth_service();
}
inline void User::clear_auth_service() {
  auth_service_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& User::auth_service() const {
  // @@protoc_insertion_point(field_get:user.v1.User.auth_service)
  return _internal_auth_service();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_auth_service(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 auth_service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.auth_service)
}
inline std::string* User::mutable_auth_service() {
  std::string* _s = _internal_mutable_auth_service();
  // @@protoc_insertion_point(field_mutable:user.v1.User.auth_service)
  return _s;
}
inline const std::string& User::_internal_auth_service() const {
  return auth_service_.Get();
}
inline void User::_internal_set_auth_service(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  auth_service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_auth_service() {
  _has_bits_[0] |= 0x00000400u;
  return auth_service_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_auth_service() {
  // @@protoc_insertion_point(field_release:user.v1.User.auth_service)
  if (!_internal_has_auth_service()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = auth_service_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_service_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_auth_service(std::string* auth_service) {
  if (auth_service != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  auth_service_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_service,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_service_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.auth_service)
}

// optional string roles = 13 [json_name = "roles"];
inline bool User::_internal_has_roles() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool User::has_roles() const {
  return _internal_has_roles();
}
inline void User::clear_roles() {
  roles_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& User::roles() const {
  // @@protoc_insertion_point(field_get:user.v1.User.roles)
  return _internal_roles();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_roles(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 roles_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.roles)
}
inline std::string* User::mutable_roles() {
  std::string* _s = _internal_mutable_roles();
  // @@protoc_insertion_point(field_mutable:user.v1.User.roles)
  return _s;
}
inline const std::string& User::_internal_roles() const {
  return roles_.Get();
}
inline void User::_internal_set_roles(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  roles_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_roles() {
  _has_bits_[0] |= 0x00000800u;
  return roles_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_roles() {
  // @@protoc_insertion_point(field_release:user.v1.User.roles)
  if (!_internal_has_roles()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = roles_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roles_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roles_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_roles(std::string* roles) {
  if (roles != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  roles_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), roles,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roles_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    roles_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.roles)
}

// map<string, string> props = 14 [json_name = "props"];
inline int User::_internal_props_size() const {
  return props_.size();
}
inline int User::props_size() const {
  return _internal_props_size();
}
inline void User::clear_props() {
  props_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
User::_internal_props() const {
  return props_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
User::props() const {
  // @@protoc_insertion_point(field_map:user.v1.User.props)
  return _internal_props();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
User::_internal_mutable_props() {
  return props_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
User::mutable_props() {
  // @@protoc_insertion_point(field_mutable_map:user.v1.User.props)
  return _internal_mutable_props();
}

// map<string, string> notify_props = 15 [json_name = "notifyProps"];
inline int User::_internal_notify_props_size() const {
  return notify_props_.size();
}
inline int User::notify_props_size() const {
  return _internal_notify_props_size();
}
inline void User::clear_notify_props() {
  notify_props_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
User::_internal_notify_props() const {
  return notify_props_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
User::notify_props() const {
  // @@protoc_insertion_point(field_map:user.v1.User.notify_props)
  return _internal_notify_props();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
User::_internal_mutable_notify_props() {
  return notify_props_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
User::mutable_notify_props() {
  // @@protoc_insertion_point(field_mutable_map:user.v1.User.notify_props)
  return _internal_mutable_notify_props();
}

// optional int64 last_password_update = 16 [json_name = "lastPasswordUpdate"];
inline bool User::_internal_has_last_password_update() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool User::has_last_password_update() const {
  return _internal_has_last_password_update();
}
inline void User::clear_last_password_update() {
  last_password_update_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline int64_t User::_internal_last_password_update() const {
  return last_password_update_;
}
inline int64_t User::last_password_update() const {
  // @@protoc_insertion_point(field_get:user.v1.User.last_password_update)
  return _internal_last_password_update();
}
inline void User::_internal_set_last_password_update(int64_t value) {
  _has_bits_[0] |= 0x00020000u;
  last_password_update_ = value;
}
inline void User::set_last_password_update(int64_t value) {
  _internal_set_last_password_update(value);
  // @@protoc_insertion_point(field_set:user.v1.User.last_password_update)
}

// optional int64 last_picture_update = 17 [json_name = "lastPictureUpdate"];
inline bool User::_internal_has_last_picture_update() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool User::has_last_picture_update() const {
  return _internal_has_last_picture_update();
}
inline void User::clear_last_picture_update() {
  last_picture_update_ = int64_t{0};
  _has_bits_[0] &= ~0x00040000u;
}
inline int64_t User::_internal_last_picture_update() const {
  return last_picture_update_;
}
inline int64_t User::last_picture_update() const {
  // @@protoc_insertion_point(field_get:user.v1.User.last_picture_update)
  return _internal_last_picture_update();
}
inline void User::_internal_set_last_picture_update(int64_t value) {
  _has_bits_[0] |= 0x00040000u;
  last_picture_update_ = value;
}
inline void User::set_last_picture_update(int64_t value) {
  _internal_set_last_picture_update(value);
  // @@protoc_insertion_point(field_set:user.v1.User.last_picture_update)
}

// optional int32 failed_attempts = 18 [json_name = "failedAttempts"];
inline bool User::_internal_has_failed_attempts() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool User::has_failed_attempts() const {
  return _internal_has_failed_attempts();
}
inline void User::clear_failed_attempts() {
  failed_attempts_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline int32_t User::_internal_failed_attempts() const {
  return failed_attempts_;
}
inline int32_t User::failed_attempts() const {
  // @@protoc_insertion_point(field_get:user.v1.User.failed_attempts)
  return _internal_failed_attempts();
}
inline void User::_internal_set_failed_attempts(int32_t value) {
  _has_bits_[0] |= 0x00010000u;
  failed_attempts_ = value;
}
inline void User::set_failed_attempts(int32_t value) {
  _internal_set_failed_attempts(value);
  // @@protoc_insertion_point(field_set:user.v1.User.failed_attempts)
}

// optional string locale = 19 [json_name = "locale"];
inline bool User::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool User::has_locale() const {
  return _internal_has_locale();
}
inline void User::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& User::locale() const {
  // @@protoc_insertion_point(field_get:user.v1.User.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.locale)
}
inline std::string* User::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:user.v1.User.locale)
  return _s;
}
inline const std::string& User::_internal_locale() const {
  return locale_.Get();
}
inline void User::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00001000u;
  return locale_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_locale() {
  // @@protoc_insertion_point(field_release:user.v1.User.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = locale_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  locale_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locale,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.locale)
}

// optional bool mfa_active = 20 [json_name = "mfaActive"];
inline bool User::_internal_has_mfa_active() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool User::has_mfa_active() const {
  return _internal_has_mfa_active();
}
inline void User::clear_mfa_active() {
  mfa_active_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool User::_internal_mfa_active() const {
  return mfa_active_;
}
inline bool User::mfa_active() const {
  // @@protoc_insertion_point(field_get:user.v1.User.mfa_active)
  return _internal_mfa_active();
}
inline void User::_internal_set_mfa_active(bool value) {
  _has_bits_[0] |= 0x00008000u;
  mfa_active_ = value;
}
inline void User::set_mfa_active(bool value) {
  _internal_set_mfa_active(value);
  // @@protoc_insertion_point(field_set:user.v1.User.mfa_active)
}

// optional string mfa_secret = 21 [json_name = "mfaSecret"];
inline bool User::_internal_has_mfa_secret() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool User::has_mfa_secret() const {
  return _internal_has_mfa_secret();
}
inline void User::clear_mfa_secret() {
  mfa_secret_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& User::mfa_secret() const {
  // @@protoc_insertion_point(field_get:user.v1.User.mfa_secret)
  return _internal_mfa_secret();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_mfa_secret(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 mfa_secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.User.mfa_secret)
}
inline std::string* User::mutable_mfa_secret() {
  std::string* _s = _internal_mutable_mfa_secret();
  // @@protoc_insertion_point(field_mutable:user.v1.User.mfa_secret)
  return _s;
}
inline const std::string& User::_internal_mfa_secret() const {
  return mfa_secret_.Get();
}
inline void User::_internal_set_mfa_secret(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  mfa_secret_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_mfa_secret() {
  _has_bits_[0] |= 0x00002000u;
  return mfa_secret_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_mfa_secret() {
  // @@protoc_insertion_point(field_release:user.v1.User.mfa_secret)
  if (!_internal_has_mfa_secret()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = mfa_secret_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mfa_secret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mfa_secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void User::set_allocated_mfa_secret(std::string* mfa_secret) {
  if (mfa_secret != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  mfa_secret_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mfa_secret,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mfa_secret_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    mfa_secret_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.User.mfa_secret)
}

// optional int64 last_activity_at = 22 [json_name = "lastActivityAt"];
inline bool User::_internal_has_last_activity_at() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool User::has_last_activity_at() const {
  return _internal_has_last_activity_at();
}
inline void User::clear_last_activity_at() {
  last_activity_at_ = int64_t{0};
  _has_bits_[0] &= ~0x00080000u;
}
inline int64_t User::_internal_last_activity_at() const {
  return last_activity_at_;
}
inline int64_t User::last_activity_at() const {
  // @@protoc_insertion_point(field_get:user.v1.User.last_activity_at)
  return _internal_last_activity_at();
}
inline void User::_internal_set_last_activity_at(int64_t value) {
  _has_bits_[0] |= 0x00080000u;
  last_activity_at_ = value;
}
inline void User::set_last_activity_at(int64_t value) {
  _internal_set_last_activity_at(value);
  // @@protoc_insertion_point(field_set:user.v1.User.last_activity_at)
}

// optional int64 last_login = 23 [json_name = "lastLogin"];
inline bool User::_internal_has_last_login() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool User::has_last_login() const {
  return _internal_has_last_login();
}
inline void User::clear_last_login() {
  last_login_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline int64_t User::_internal_last_login() const {
  return last_login_;
}
inline int64_t User::last_login() const {
  // @@protoc_insertion_point(field_get:user.v1.User.last_login)
  return _internal_last_login();
}
inline void User::_internal_set_last_login(int64_t value) {
  _has_bits_[0] |= 0x00100000u;
  last_login_ = value;
}
inline void User::set_last_login(int64_t value) {
  _internal_set_last_login(value);
  // @@protoc_insertion_point(field_set:user.v1.User.last_login)
}

// optional int64 created_at = 24 [json_name = "createdAt"];
inline bool User::_internal_has_created_at() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool User::has_created_at() const {
  return _internal_has_created_at();
}
inline void User::clear_created_at() {
  created_at_ = int64_t{0};
  _has_bits_[0] &= ~0x00200000u;
}
inline int64_t User::_internal_created_at() const {
  return created_at_;
}
inline int64_t User::created_at() const {
  // @@protoc_insertion_point(field_get:user.v1.User.created_at)
  return _internal_created_at();
}
inline void User::_internal_set_created_at(int64_t value) {
  _has_bits_[0] |= 0x00200000u;
  created_at_ = value;
}
inline void User::set_created_at(int64_t value) {
  _internal_set_created_at(value);
  // @@protoc_insertion_point(field_set:user.v1.User.created_at)
}

// optional int64 updated_at = 25 [json_name = "updatedAt"];
inline bool User::_internal_has_updated_at() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool User::has_updated_at() const {
  return _internal_has_updated_at();
}
inline void User::clear_updated_at() {
  updated_at_ = int64_t{0};
  _has_bits_[0] &= ~0x00400000u;
}
inline int64_t User::_internal_updated_at() const {
  return updated_at_;
}
inline int64_t User::updated_at() const {
  // @@protoc_insertion_point(field_get:user.v1.User.updated_at)
  return _internal_updated_at();
}
inline void User::_internal_set_updated_at(int64_t value) {
  _has_bits_[0] |= 0x00400000u;
  updated_at_ = value;
}
inline void User::set_updated_at(int64_t value) {
  _internal_set_updated_at(value);
  // @@protoc_insertion_point(field_set:user.v1.User.updated_at)
}

// optional int64 deleted_at = 26 [json_name = "deletedAt"];
inline bool User::_internal_has_deleted_at() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool User::has_deleted_at() const {
  return _internal_has_deleted_at();
}
inline void User::clear_deleted_at() {
  deleted_at_ = int64_t{0};
  _has_bits_[0] &= ~0x00800000u;
}
inline int64_t User::_internal_deleted_at() const {
  return deleted_at_;
}
inline int64_t User::deleted_at() const {
  // @@protoc_insertion_point(field_get:user.v1.User.deleted_at)
  return _internal_deleted_at();
}
inline void User::_internal_set_deleted_at(int64_t value) {
  _has_bits_[0] |= 0x00800000u;
  deleted_at_ = value;
}
inline void User::set_deleted_at(int64_t value) {
  _internal_set_deleted_at(value);
  // @@protoc_insertion_point(field_set:user.v1.User.deleted_at)
}

// -------------------------------------------------------------------

// CreateSupplierRequest

// string username = 1 [json_name = "username"];
inline void CreateSupplierRequest::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& CreateSupplierRequest::username() const {
  // @@protoc_insertion_point(field_get:user.v1.CreateSupplierRequest.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSupplierRequest::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.CreateSupplierRequest.username)
}
inline std::string* CreateSupplierRequest::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:user.v1.CreateSupplierRequest.username)
  return _s;
}
inline const std::string& CreateSupplierRequest::_internal_username() const {
  return username_.Get();
}
inline void CreateSupplierRequest::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::release_username() {
  // @@protoc_insertion_point(field_release:user.v1.CreateSupplierRequest.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSupplierRequest::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.CreateSupplierRequest.username)
}

// string email = 2 [json_name = "email"];
inline void CreateSupplierRequest::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& CreateSupplierRequest::email() const {
  // @@protoc_insertion_point(field_get:user.v1.CreateSupplierRequest.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSupplierRequest::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.CreateSupplierRequest.email)
}
inline std::string* CreateSupplierRequest::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:user.v1.CreateSupplierRequest.email)
  return _s;
}
inline const std::string& CreateSupplierRequest::_internal_email() const {
  return email_.Get();
}
inline void CreateSupplierRequest::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::release_email() {
  // @@protoc_insertion_point(field_release:user.v1.CreateSupplierRequest.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSupplierRequest::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.CreateSupplierRequest.email)
}

// string first_name = 3 [json_name = "firstName"];
inline void CreateSupplierRequest::clear_first_name() {
  first_name_.ClearToEmpty();
}
inline const std::string& CreateSupplierRequest::first_name() const {
  // @@protoc_insertion_point(field_get:user.v1.CreateSupplierRequest.first_name)
  return _internal_first_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSupplierRequest::set_first_name(ArgT0&& arg0, ArgT... args) {
 
 first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.CreateSupplierRequest.first_name)
}
inline std::string* CreateSupplierRequest::mutable_first_name() {
  std::string* _s = _internal_mutable_first_name();
  // @@protoc_insertion_point(field_mutable:user.v1.CreateSupplierRequest.first_name)
  return _s;
}
inline const std::string& CreateSupplierRequest::_internal_first_name() const {
  return first_name_.Get();
}
inline void CreateSupplierRequest::_internal_set_first_name(const std::string& value) {
  
  first_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::_internal_mutable_first_name() {
  
  return first_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::release_first_name() {
  // @@protoc_insertion_point(field_release:user.v1.CreateSupplierRequest.first_name)
  return first_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSupplierRequest::set_allocated_first_name(std::string* first_name) {
  if (first_name != nullptr) {
    
  } else {
    
  }
  first_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    first_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.CreateSupplierRequest.first_name)
}

// string last_name = 4 [json_name = "lastName"];
inline void CreateSupplierRequest::clear_last_name() {
  last_name_.ClearToEmpty();
}
inline const std::string& CreateSupplierRequest::last_name() const {
  // @@protoc_insertion_point(field_get:user.v1.CreateSupplierRequest.last_name)
  return _internal_last_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSupplierRequest::set_last_name(ArgT0&& arg0, ArgT... args) {
 
 last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.CreateSupplierRequest.last_name)
}
inline std::string* CreateSupplierRequest::mutable_last_name() {
  std::string* _s = _internal_mutable_last_name();
  // @@protoc_insertion_point(field_mutable:user.v1.CreateSupplierRequest.last_name)
  return _s;
}
inline const std::string& CreateSupplierRequest::_internal_last_name() const {
  return last_name_.Get();
}
inline void CreateSupplierRequest::_internal_set_last_name(const std::string& value) {
  
  last_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::_internal_mutable_last_name() {
  
  return last_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::release_last_name() {
  // @@protoc_insertion_point(field_release:user.v1.CreateSupplierRequest.last_name)
  return last_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSupplierRequest::set_allocated_last_name(std::string* last_name) {
  if (last_name != nullptr) {
    
  } else {
    
  }
  last_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), last_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    last_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.CreateSupplierRequest.last_name)
}

// string password = 5 [json_name = "password"];
inline void CreateSupplierRequest::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& CreateSupplierRequest::password() const {
  // @@protoc_insertion_point(field_get:user.v1.CreateSupplierRequest.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSupplierRequest::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.CreateSupplierRequest.password)
}
inline std::string* CreateSupplierRequest::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:user.v1.CreateSupplierRequest.password)
  return _s;
}
inline const std::string& CreateSupplierRequest::_internal_password() const {
  return password_.Get();
}
inline void CreateSupplierRequest::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::release_password() {
  // @@protoc_insertion_point(field_release:user.v1.CreateSupplierRequest.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSupplierRequest::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.CreateSupplierRequest.password)
}

// string membership = 6 [json_name = "membership"];
inline void CreateSupplierRequest::clear_membership() {
  membership_.ClearToEmpty();
}
inline const std::string& CreateSupplierRequest::membership() const {
  // @@protoc_insertion_point(field_get:user.v1.CreateSupplierRequest.membership)
  return _internal_membership();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateSupplierRequest::set_membership(ArgT0&& arg0, ArgT... args) {
 
 membership_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:user.v1.CreateSupplierRequest.membership)
}
inline std::string* CreateSupplierRequest::mutable_membership() {
  std::string* _s = _internal_mutable_membership();
  // @@protoc_insertion_point(field_mutable:user.v1.CreateSupplierRequest.membership)
  return _s;
}
inline const std::string& CreateSupplierRequest::_internal_membership() const {
  return membership_.Get();
}
inline void CreateSupplierRequest::_internal_set_membership(const std::string& value) {
  
  membership_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::_internal_mutable_membership() {
  
  return membership_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateSupplierRequest::release_membership() {
  // @@protoc_insertion_point(field_release:user.v1.CreateSupplierRequest.membership)
  return membership_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateSupplierRequest::set_allocated_membership(std::string* membership) {
  if (membership != nullptr) {
    
  } else {
    
  }
  membership_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), membership,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (membership_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    membership_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:user.v1.CreateSupplierRequest.membership)
}

// -------------------------------------------------------------------

// CreateSupplierResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace user

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_2fv1_2fuser_2eproto
