// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: uploader/v1/config.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Enum of available Storage implementations.
type AvailableDataStorages int32

const (
	AvailableDataStorages_FILE_STORAGE AvailableDataStorages = 0
	AvailableDataStorages_HYBRID_S3    AvailableDataStorages = 1
	AvailableDataStorages_S3           AvailableDataStorages = 2
)

// Enum value maps for AvailableDataStorages.
var (
	AvailableDataStorages_name = map[int32]string{
		0: "FILE_STORAGE",
		1: "HYBRID_S3",
		2: "S3",
	}
	AvailableDataStorages_value = map[string]int32{
		"FILE_STORAGE": 0,
		"HYBRID_S3":    1,
		"S3":           2,
	}
)

func (x AvailableDataStorages) Enum() *AvailableDataStorages {
	p := new(AvailableDataStorages)
	*p = x
	return p
}

func (x AvailableDataStorages) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AvailableDataStorages) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[0].Descriptor()
}

func (AvailableDataStorages) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[0]
}

func (x AvailableDataStorages) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AvailableDataStorages.Descriptor instead.
func (AvailableDataStorages) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{0}
}

type AvailableInfoStorages int32

const (
	AvailableInfoStorages_FILES AvailableInfoStorages = 0
	AvailableInfoStorages_REDIS AvailableInfoStorages = 1
)

// Enum value maps for AvailableInfoStorages.
var (
	AvailableInfoStorages_name = map[int32]string{
		0: "FILES",
		1: "REDIS",
	}
	AvailableInfoStorages_value = map[string]int32{
		"FILES": 0,
		"REDIS": 1,
	}
)

func (x AvailableInfoStorages) Enum() *AvailableInfoStorages {
	p := new(AvailableInfoStorages)
	*p = x
	return p
}

func (x AvailableInfoStorages) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AvailableInfoStorages) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[1].Descriptor()
}

func (AvailableInfoStorages) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[1]
}

func (x AvailableInfoStorages) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AvailableInfoStorages.Descriptor instead.
func (AvailableInfoStorages) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{1}
}

type Format int32

const (
	Format_DEFAULT Format = 0
	Format_TUSD    Format = 1
	Format_V2      Format = 2
)

// Enum value maps for Format.
var (
	Format_name = map[int32]string{
		0: "DEFAULT",
		1: "TUSD",
		2: "V2",
	}
	Format_value = map[string]int32{
		"DEFAULT": 0,
		"TUSD":    1,
		"V2":      2,
	}
)

func (x Format) Enum() *Format {
	p := new(Format)
	*p = x
	return p
}

func (x Format) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Format) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[2].Descriptor()
}

func (Format) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[2]
}

func (x Format) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Format.Descriptor instead.
func (Format) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{2}
}

// Hooks for notifications.
type Hook int32

const (
	Hook_PRE_CREATE     Hook = 0
	Hook_POST_CREATE    Hook = 1
	Hook_POST_RECEIVE   Hook = 2
	Hook_PRE_TERMINATE  Hook = 3
	Hook_POST_TERMINATE Hook = 4
	Hook_POST_FINISH    Hook = 5
)

// Enum value maps for Hook.
var (
	Hook_name = map[int32]string{
		0: "PRE_CREATE",
		1: "POST_CREATE",
		2: "POST_RECEIVE",
		3: "PRE_TERMINATE",
		4: "POST_TERMINATE",
		5: "POST_FINISH",
	}
	Hook_value = map[string]int32{
		"PRE_CREATE":     0,
		"POST_CREATE":    1,
		"POST_RECEIVE":   2,
		"PRE_TERMINATE":  3,
		"POST_TERMINATE": 4,
		"POST_FINISH":    5,
	}
)

func (x Hook) Enum() *Hook {
	p := new(Hook)
	*p = x
	return p
}

func (x Hook) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Hook) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[3].Descriptor()
}

func (Hook) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[3]
}

func (x Hook) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Hook.Descriptor instead.
func (Hook) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{3}
}

// Extensions for TUS protocol.
type Extensions int32

const (
	Extensions_GETTING               Extensions = 0
	Extensions_CREATION              Extensions = 1
	Extensions_TERMINATION           Extensions = 2
	Extensions_CREATION_WITH_UPLOAD  Extensions = 3
	Extensions_CREATION_DEFER_LENGTH Extensions = 4
	Extensions_CONCATENATION         Extensions = 5
	Extensions_CHECKSUM              Extensions = 6
)

// Enum value maps for Extensions.
var (
	Extensions_name = map[int32]string{
		0: "GETTING",
		1: "CREATION",
		2: "TERMINATION",
		3: "CREATION_WITH_UPLOAD",
		4: "CREATION_DEFER_LENGTH",
		5: "CONCATENATION",
		6: "CHECKSUM",
	}
	Extensions_value = map[string]int32{
		"GETTING":               0,
		"CREATION":              1,
		"TERMINATION":           2,
		"CREATION_WITH_UPLOAD":  3,
		"CREATION_DEFER_LENGTH": 4,
		"CONCATENATION":         5,
		"CHECKSUM":              6,
	}
)

func (x Extensions) Enum() *Extensions {
	p := new(Extensions)
	*p = x
	return p
}

func (x Extensions) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Extensions) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[4].Descriptor()
}

func (Extensions) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[4]
}

func (x Extensions) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Extensions.Descriptor instead.
func (Extensions) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{4}
}

type ExtraKafkaOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Opts          map[string]string      `protobuf:"bytes,1,rep,name=opts,proto3" json:"opts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExtraKafkaOptions) Reset() {
	*x = ExtraKafkaOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExtraKafkaOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExtraKafkaOptions) ProtoMessage() {}

func (x *ExtraKafkaOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExtraKafkaOptions.ProtoReflect.Descriptor instead.
func (*ExtraKafkaOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{0}
}

func (x *ExtraKafkaOptions) GetOpts() map[string]string {
	if x != nil {
		return x.Opts
	}
	return nil
}

type DataStorageOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Storages are used to store uploads.
	Storage AvailableDataStorages `protobuf:"varint,1,opt,name=storage,proto3,enum=uploader.v1.AvailableDataStorages" json:"storage,omitempty"`
	// / This directory is used to store files for all *`file_storage` storages.
	DataDir string `protobuf:"bytes,2,opt,name=data_dir,json=dataDir,proto3" json:"data_dir,omitempty"`
	// / Storage directory structure.
	// / This template shows inner directory structure. You can use following variables:
	// / day, month, year or even environment variables.
	// / Example: "/year/month/day/env[HOSTNAME]/".
	DirStructure string `protobuf:"bytes,3,opt,name=dir_structure,json=dirStructure,proto3" json:"dir_structure,omitempty"`
	// / Forces fsync call after writing chunk to filesystem. This parameter can help you
	// /  when working with Network file systems. It guarantees that everything is written
	// /  on disk correctly.
	// /
	// / In most cases this parameter is redundant.
	ForceFsync bool `protobuf:"varint,4,opt,name=force_fsync,json=forceFsync,proto3" json:"force_fsync,omitempty"`
	// / S3 bucket to upload files to.
	// / This parameter is required fo s3-based storages.
	S3Bucket *string `protobuf:"bytes,5,opt,name=s3_bucket,json=s3Bucket,proto3,oneof" json:"s3_bucket,omitempty"`
	// / S3 region.
	// /
	// / This parameter is required fo s3-based storages.
	S3Region *string `protobuf:"bytes,6,opt,name=s3_region,json=s3Region,proto3,oneof" json:"s3_region,omitempty"`
	// / S3 access key.
	// /
	// / This parameter is required fo s3-based storages.
	S3AccessKey *string `protobuf:"bytes,7,opt,name=s3_access_key,json=s3AccessKey,proto3,oneof" json:"s3_access_key,omitempty"`
	// / S3 access key path.
	// /
	// / This parameter is used fo s3-based storages.
	// / path to file that has s3-access-key inside.
	S3AccessKeyPath *string `protobuf:"bytes,8,opt,name=s3_access_key_path,json=s3AccessKeyPath,proto3,oneof" json:"s3_access_key_path,omitempty"`
	// / S3 secret key.
	// /
	// / This parameter is required fo s3-based storages.
	S3SecretKey *string `protobuf:"bytes,9,opt,name=s3_secret_key,json=s3SecretKey,proto3,oneof" json:"s3_secret_key,omitempty"`
	// / S3 secret key path.
	// /
	// / This parameter is required fo s3-based storages.
	// / path to file that has s3-secret-key inside.
	S3SecretKeyPath *string `protobuf:"bytes,10,opt,name=s3_secret_key_path,json=s3SecretKeyPath,proto3,oneof" json:"s3_secret_key_path,omitempty"`
	// / S3 URL.
	// /
	// / This parameter is required fo s3-based storages.
	S3Url *string `protobuf:"bytes,11,opt,name=s3_url,json=s3Url,proto3,oneof" json:"s3_url,omitempty"`
	// / S3 force path style.
	// /
	// / This parameter is required fo s3-based storages.
	S3ForcePathStyle bool `protobuf:"varint,12,opt,name=s3_force_path_style,json=s3ForcePathStyle,proto3" json:"s3_force_path_style,omitempty"`
	// / S3 security token.
	// /
	// / This parameter is required fo s3-based storages.
	S3SecurityToken *string `protobuf:"bytes,13,opt,name=s3_security_token,json=s3SecurityToken,proto3,oneof" json:"s3_security_token,omitempty"`
	// / S3 session token.
	// /
	// / This parameter is required fo s3-based storages.
	S3SessionToken *string `protobuf:"bytes,14,opt,name=s3_session_token,json=s3SessionToken,proto3,oneof" json:"s3_session_token,omitempty"`
	// / S3 profile.
	// /
	// / This parameter is required fo s3-based storages.
	S3Profile *string `protobuf:"bytes,15,opt,name=s3_profile,json=s3Profile,proto3,oneof" json:"s3_profile,omitempty"`
	// / Additional S3 headers.
	// / These headers are passed to every request to s3.
	// / Useful for configuring ACLs.
	// /
	// / This parameter is required fo s3-based storages.
	S3Headers *string `protobuf:"bytes,16,opt,name=s3_headers,json=s3Headers,proto3,oneof" json:"s3_headers,omitempty"`
	// / Number of concurrent downloads of partial files from S3.
	// / When performing concatenation, Rustus downloads all partial
	// / files from S3 and concatenates them into a single file.
	// /
	// / This parameter controls the number of concurrent downloads.
	S3ConcatConcurrentDownloads uint32 `protobuf:"varint,17,opt,name=s3_concat_concurrent_downloads,json=s3ConcatConcurrentDownloads,proto3" json:"s3_concat_concurrent_downloads,omitempty"` // usize is represented as uint32
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *DataStorageOptions) Reset() {
	*x = DataStorageOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataStorageOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataStorageOptions) ProtoMessage() {}

func (x *DataStorageOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataStorageOptions.ProtoReflect.Descriptor instead.
func (*DataStorageOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{1}
}

func (x *DataStorageOptions) GetStorage() AvailableDataStorages {
	if x != nil {
		return x.Storage
	}
	return AvailableDataStorages_FILE_STORAGE
}

func (x *DataStorageOptions) GetDataDir() string {
	if x != nil {
		return x.DataDir
	}
	return ""
}

func (x *DataStorageOptions) GetDirStructure() string {
	if x != nil {
		return x.DirStructure
	}
	return ""
}

func (x *DataStorageOptions) GetForceFsync() bool {
	if x != nil {
		return x.ForceFsync
	}
	return false
}

func (x *DataStorageOptions) GetS3Bucket() string {
	if x != nil && x.S3Bucket != nil {
		return *x.S3Bucket
	}
	return ""
}

func (x *DataStorageOptions) GetS3Region() string {
	if x != nil && x.S3Region != nil {
		return *x.S3Region
	}
	return ""
}

func (x *DataStorageOptions) GetS3AccessKey() string {
	if x != nil && x.S3AccessKey != nil {
		return *x.S3AccessKey
	}
	return ""
}

func (x *DataStorageOptions) GetS3AccessKeyPath() string {
	if x != nil && x.S3AccessKeyPath != nil {
		return *x.S3AccessKeyPath
	}
	return ""
}

func (x *DataStorageOptions) GetS3SecretKey() string {
	if x != nil && x.S3SecretKey != nil {
		return *x.S3SecretKey
	}
	return ""
}

func (x *DataStorageOptions) GetS3SecretKeyPath() string {
	if x != nil && x.S3SecretKeyPath != nil {
		return *x.S3SecretKeyPath
	}
	return ""
}

func (x *DataStorageOptions) GetS3Url() string {
	if x != nil && x.S3Url != nil {
		return *x.S3Url
	}
	return ""
}

func (x *DataStorageOptions) GetS3ForcePathStyle() bool {
	if x != nil {
		return x.S3ForcePathStyle
	}
	return false
}

func (x *DataStorageOptions) GetS3SecurityToken() string {
	if x != nil && x.S3SecurityToken != nil {
		return *x.S3SecurityToken
	}
	return ""
}

func (x *DataStorageOptions) GetS3SessionToken() string {
	if x != nil && x.S3SessionToken != nil {
		return *x.S3SessionToken
	}
	return ""
}

func (x *DataStorageOptions) GetS3Profile() string {
	if x != nil && x.S3Profile != nil {
		return *x.S3Profile
	}
	return ""
}

func (x *DataStorageOptions) GetS3Headers() string {
	if x != nil && x.S3Headers != nil {
		return *x.S3Headers
	}
	return ""
}

func (x *DataStorageOptions) GetS3ConcatConcurrentDownloads() uint32 {
	if x != nil {
		return x.S3ConcatConcurrentDownloads
	}
	return 0
}

type InfoStoreOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Type of info storage.
	// /
	// / Info storages are used to store information about uploads.
	// /
	// / This information is used in HEAD requests.
	InfoStorage AvailableInfoStorages `protobuf:"varint,1,opt,name=info_storage,json=infoStorage,proto3,enum=uploader.v1.AvailableInfoStorages" json:"info_storage,omitempty"`
	// / Rustus info directory
	// /
	// / This directory is used to store .info files for `file_info_storage`.
	InfoDir string `protobuf:"bytes,2,opt,name=info_dir,json=infoDir,proto3" json:"info_dir,omitempty"`
	// / Connection string for remote info storages.
	// /
	// / This connection string is used for storages which require connection.
	// / Examples of such storages are `Postgres`, `MySQL` or `Redis`.
	// /
	// / Value must include all connection details.
	InfoDbDsn           *string `protobuf:"bytes,3,opt,name=info_db_dsn,json=infoDbDsn,proto3,oneof" json:"info_db_dsn,omitempty"`
	RedisInfoExpiration *uint32 `protobuf:"varint,4,opt,name=redis_info_expiration,json=redisInfoExpiration,proto3,oneof" json:"redis_info_expiration,omitempty"` // usize is represented as uint32
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *InfoStoreOptions) Reset() {
	*x = InfoStoreOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InfoStoreOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InfoStoreOptions) ProtoMessage() {}

func (x *InfoStoreOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InfoStoreOptions.ProtoReflect.Descriptor instead.
func (*InfoStoreOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{2}
}

func (x *InfoStoreOptions) GetInfoStorage() AvailableInfoStorages {
	if x != nil {
		return x.InfoStorage
	}
	return AvailableInfoStorages_FILES
}

func (x *InfoStoreOptions) GetInfoDir() string {
	if x != nil {
		return x.InfoDir
	}
	return ""
}

func (x *InfoStoreOptions) GetInfoDbDsn() string {
	if x != nil && x.InfoDbDsn != nil {
		return *x.InfoDbDsn
	}
	return ""
}

func (x *InfoStoreOptions) GetRedisInfoExpiration() uint32 {
	if x != nil && x.RedisInfoExpiration != nil {
		return *x.RedisInfoExpiration
	}
	return 0
}

type AMQPHooksOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Url for AMQP server.
	Url *string `protobuf:"bytes,1,opt,name=url,proto3,oneof" json:"url,omitempty"`
	// / Rustus will create exchange if enabled.
	DeclareExchange bool `protobuf:"varint,2,opt,name=declare_exchange,json=declareExchange,proto3" json:"declare_exchange,omitempty"`
	// / Rustus will create all queues for communication and bind them
	// / to exchange if enabled.
	DeclareQueues bool `protobuf:"varint,3,opt,name=declare_queues,json=declareQueues,proto3" json:"declare_queues,omitempty"`
	// / Durability type of exchange.
	DurableExchange bool `protobuf:"varint,4,opt,name=durable_exchange,json=durableExchange,proto3" json:"durable_exchange,omitempty"`
	// / Durability type of queues.
	DurableQueues bool `protobuf:"varint,5,opt,name=durable_queues,json=durableQueues,proto3" json:"durable_queues,omitempty"`
	// / Adds celery specific headers.
	Celery bool `protobuf:"varint,6,opt,name=celery,proto3" json:"celery,omitempty"`
	// / Name of amqp exchange.
	Exchange string `protobuf:"bytes,7,opt,name=exchange,proto3" json:"exchange,omitempty"`
	// / Exchange kind.
	ExchangeKind string `protobuf:"bytes,8,opt,name=exchange_kind,json=exchangeKind,proto3" json:"exchange_kind,omitempty"`
	// / Routing key to use when sending message to an exchange.
	RoutingKey *string `protobuf:"bytes,9,opt,name=routing_key,json=routingKey,proto3,oneof" json:"routing_key,omitempty"`
	// / Prefix for all AMQP queues.
	QueuesPrefix string `protobuf:"bytes,10,opt,name=queues_prefix,json=queuesPrefix,proto3" json:"queues_prefix,omitempty"`
	// / Maximum number of connections for `RabbitMQ`.
	ConnectionPoolSize uint64 `protobuf:"varint,11,opt,name=connection_pool_size,json=connectionPoolSize,proto3" json:"connection_pool_size,omitempty"`
	// / Maximum number of opened channels for each connection.
	ChannelPoolSize uint64 `protobuf:"varint,12,opt,name=channel_pool_size,json=channelPoolSize,proto3" json:"channel_pool_size,omitempty"`
	// / After this amount of time the connection will be dropped.
	IdleConnectionTimeout *uint64 `protobuf:"varint,13,opt,name=idle_connection_timeout,json=idleConnectionTimeout,proto3,oneof" json:"idle_connection_timeout,omitempty"`
	// / After this amount of time in seconds, the channel will be closed.
	IdleChannelsTimeout *uint64 `protobuf:"varint,14,opt,name=idle_channels_timeout,json=idleChannelsTimeout,proto3,oneof" json:"idle_channels_timeout,omitempty"`
	// / Declares all objects with auto-delete property set.
	AutoDelete    bool `protobuf:"varint,15,opt,name=auto_delete,json=autoDelete,proto3" json:"auto_delete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AMQPHooksOptions) Reset() {
	*x = AMQPHooksOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AMQPHooksOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AMQPHooksOptions) ProtoMessage() {}

func (x *AMQPHooksOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AMQPHooksOptions.ProtoReflect.Descriptor instead.
func (*AMQPHooksOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{3}
}

func (x *AMQPHooksOptions) GetUrl() string {
	if x != nil && x.Url != nil {
		return *x.Url
	}
	return ""
}

func (x *AMQPHooksOptions) GetDeclareExchange() bool {
	if x != nil {
		return x.DeclareExchange
	}
	return false
}

func (x *AMQPHooksOptions) GetDeclareQueues() bool {
	if x != nil {
		return x.DeclareQueues
	}
	return false
}

func (x *AMQPHooksOptions) GetDurableExchange() bool {
	if x != nil {
		return x.DurableExchange
	}
	return false
}

func (x *AMQPHooksOptions) GetDurableQueues() bool {
	if x != nil {
		return x.DurableQueues
	}
	return false
}

func (x *AMQPHooksOptions) GetCelery() bool {
	if x != nil {
		return x.Celery
	}
	return false
}

func (x *AMQPHooksOptions) GetExchange() string {
	if x != nil {
		return x.Exchange
	}
	return ""
}

func (x *AMQPHooksOptions) GetExchangeKind() string {
	if x != nil {
		return x.ExchangeKind
	}
	return ""
}

func (x *AMQPHooksOptions) GetRoutingKey() string {
	if x != nil && x.RoutingKey != nil {
		return *x.RoutingKey
	}
	return ""
}

func (x *AMQPHooksOptions) GetQueuesPrefix() string {
	if x != nil {
		return x.QueuesPrefix
	}
	return ""
}

func (x *AMQPHooksOptions) GetConnectionPoolSize() uint64 {
	if x != nil {
		return x.ConnectionPoolSize
	}
	return 0
}

func (x *AMQPHooksOptions) GetChannelPoolSize() uint64 {
	if x != nil {
		return x.ChannelPoolSize
	}
	return 0
}

func (x *AMQPHooksOptions) GetIdleConnectionTimeout() uint64 {
	if x != nil && x.IdleConnectionTimeout != nil {
		return *x.IdleConnectionTimeout
	}
	return 0
}

func (x *AMQPHooksOptions) GetIdleChannelsTimeout() uint64 {
	if x != nil && x.IdleChannelsTimeout != nil {
		return *x.IdleChannelsTimeout
	}
	return 0
}

func (x *AMQPHooksOptions) GetAutoDelete() bool {
	if x != nil {
		return x.AutoDelete
	}
	return false
}

type KafkaHookOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Kafka urls.
	// / List of brokers to connect to in the format `host:port`.
	// / If you have multiple brokers, separate them with commas.
	// / Corresponds to `bootstrap.servers` in Kafka configuration.
	Urls *string `protobuf:"bytes,1,opt,name=urls,proto3,oneof" json:"urls,omitempty"`
	// / Kafka producer client.id.
	ClientId *string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3,oneof" json:"client_id,omitempty"`
	// / Kafka topic. If specified, all events will be sent to this topic.
	Topic *string `protobuf:"bytes,3,opt,name=topic,proto3,oneof" json:"topic,omitempty"`
	// / Kafka topic prefix. In case if specifeid, prefix will be added to all topics
	// / and all events will be sent to different topics.
	Prefix *string `protobuf:"bytes,4,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
	// / Kafka required acks.
	// / This parameter is used to configure how many replicas
	// / must acknowledge the message.
	// /
	// / Corresponds to `request.required.acks` in Kafka configuration.
	// / Possible values are:
	// / * -1 - all replicas must acknowledge the message;
	// / * 0 - no replicas must acknowledge the message;
	// / * ...1000 - number of replicas that must acknowledge the message.
	RequiredAcks *string `protobuf:"bytes,5,opt,name=required_acks,json=requiredAcks,proto3,oneof" json:"required_acks,omitempty"`
	// / Compression codec.
	// / This parameter is used to compress messages before sending them to Kafka.
	// / Possible values are:
	// / * none - no compression;
	// / * gzip - gzip compression;
	// / * snappy - snappy compression.
	// / * lz4 - lz4 compression.
	// / * zstd - zstd compression.
	// /
	// / Corresponds to `compression.codec` in Kafka configuration.
	Compression *string `protobuf:"bytes,6,opt,name=compression,proto3,oneof" json:"compression,omitempty"`
	// / Kafka idle timeout in seconds.
	// / After this amount of time in seconds, the connection will be dropped.
	// / Corresponds to `connections.max.idle.ms` in Kafka configuration.
	IdleTimeout *uint64 `protobuf:"varint,7,opt,name=idle_timeout,json=idleTimeout,proto3,oneof" json:"idle_timeout,omitempty"`
	// / Kafka send timeout in seconds.
	// / After this amount of time in seconds, the message will be dropped.
	SendTimeout *uint64 `protobuf:"varint,8,opt,name=send_timeout,json=sendTimeout,proto3,oneof" json:"send_timeout,omitempty"`
	// / Extra options for Kafka.
	// / This parameter is used to pass additional options to Kafka.
	// / All options must be in the format `key=value`, separated by semicolon.
	// / Example: `key1=value1;key2=value2`.
	// /
	// / You can find all available options at
	// / <https://github.com/confluentinc/librdkafka/blob/master/CONFIGURATION.md>.
	ExtraKafkaOpts *ExtraKafkaOptions `protobuf:"bytes,9,opt,name=extra_kafka_opts,json=extraKafkaOpts,proto3,oneof" json:"extra_kafka_opts,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *KafkaHookOptions) Reset() {
	*x = KafkaHookOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaHookOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaHookOptions) ProtoMessage() {}

func (x *KafkaHookOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaHookOptions.ProtoReflect.Descriptor instead.
func (*KafkaHookOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{4}
}

func (x *KafkaHookOptions) GetUrls() string {
	if x != nil && x.Urls != nil {
		return *x.Urls
	}
	return ""
}

func (x *KafkaHookOptions) GetClientId() string {
	if x != nil && x.ClientId != nil {
		return *x.ClientId
	}
	return ""
}

func (x *KafkaHookOptions) GetTopic() string {
	if x != nil && x.Topic != nil {
		return *x.Topic
	}
	return ""
}

func (x *KafkaHookOptions) GetPrefix() string {
	if x != nil && x.Prefix != nil {
		return *x.Prefix
	}
	return ""
}

func (x *KafkaHookOptions) GetRequiredAcks() string {
	if x != nil && x.RequiredAcks != nil {
		return *x.RequiredAcks
	}
	return ""
}

func (x *KafkaHookOptions) GetCompression() string {
	if x != nil && x.Compression != nil {
		return *x.Compression
	}
	return ""
}

func (x *KafkaHookOptions) GetIdleTimeout() uint64 {
	if x != nil && x.IdleTimeout != nil {
		return *x.IdleTimeout
	}
	return 0
}

func (x *KafkaHookOptions) GetSendTimeout() uint64 {
	if x != nil && x.SendTimeout != nil {
		return *x.SendTimeout
	}
	return 0
}

func (x *KafkaHookOptions) GetExtraKafkaOpts() *ExtraKafkaOptions {
	if x != nil {
		return x.ExtraKafkaOpts
	}
	return nil
}

type NatsHookOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / List of URLs to connect to NATS. Commas are used as delimiters.
	Urls []string `protobuf:"bytes,1,rep,name=urls,proto3" json:"urls,omitempty"`
	// / NATS subject to send messages to. If not specified, hook name will be used.
	Subject *string `protobuf:"bytes,2,opt,name=subject,proto3,oneof" json:"subject,omitempty"`
	// / NATS prefix for all subjects. Will be added to all subjects separated by a dot.
	Prefix *string `protobuf:"bytes,3,opt,name=prefix,proto3,oneof" json:"prefix,omitempty"`
	// / Wait for replies from NATS.
	// / If enabled, Rustus will use request-reply pattern and
	// / wait for replies from NATS.
	// /
	// / In that case any reply should respond with "OK" or empty body, otherwise
	// / Rustus will treat it as an error.
	WaitForReplies bool `protobuf:"varint,4,opt,name=wait_for_replies,json=waitForReplies,proto3" json:"wait_for_replies,omitempty"`
	// / NATS user to connect to the server.
	Username *string `protobuf:"bytes,5,opt,name=username,proto3,oneof" json:"username,omitempty"`
	// / NATS password to connect to the server.
	Password *string `protobuf:"bytes,6,opt,name=password,proto3,oneof" json:"password,omitempty"`
	// / NATS token to connect to the server.
	Token         *string `protobuf:"bytes,7,opt,name=token,proto3,oneof" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NatsHookOptions) Reset() {
	*x = NatsHookOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NatsHookOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NatsHookOptions) ProtoMessage() {}

func (x *NatsHookOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NatsHookOptions.ProtoReflect.Descriptor instead.
func (*NatsHookOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{5}
}

func (x *NatsHookOptions) GetUrls() []string {
	if x != nil {
		return x.Urls
	}
	return nil
}

func (x *NatsHookOptions) GetSubject() string {
	if x != nil && x.Subject != nil {
		return *x.Subject
	}
	return ""
}

func (x *NatsHookOptions) GetPrefix() string {
	if x != nil && x.Prefix != nil {
		return *x.Prefix
	}
	return ""
}

func (x *NatsHookOptions) GetWaitForReplies() bool {
	if x != nil {
		return x.WaitForReplies
	}
	return false
}

func (x *NatsHookOptions) GetUsername() string {
	if x != nil && x.Username != nil {
		return *x.Username
	}
	return ""
}

func (x *NatsHookOptions) GetPassword() string {
	if x != nil && x.Password != nil {
		return *x.Password
	}
	return ""
}

func (x *NatsHookOptions) GetToken() string {
	if x != nil && x.Token != nil {
		return *x.Token
	}
	return ""
}

type NotificationsOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Notifications format.
	// /
	// / This format will be used in all messages about hooks.
	HooksFormat Format `protobuf:"varint,1,opt,name=hooks_format,json=hooksFormat,proto3,enum=uploader.v1.Format" json:"hooks_format,omitempty"`
	// / Enabled hooks for notifications.
	Hooks []Hook `protobuf:"varint,2,rep,packed,name=hooks,proto3,enum=uploader.v1.Hook" json:"hooks,omitempty"`
	// / Use this option if you use rustus
	// / behind any proxy. Like Nginx or Traefik.
	BehindProxy bool `protobuf:"varint,3,opt,name=behind_proxy,json=behindProxy,proto3" json:"behind_proxy,omitempty"`
	// / List of URLS to send webhooks to.
	HooksHttpUrls []string `protobuf:"bytes,4,rep,name=hooks_http_urls,json=hooksHttpUrls,proto3" json:"hooks_http_urls,omitempty"`
	// / Timeout for all HTTP requests in seconds.
	HttpHookTimeout *uint64 `protobuf:"varint,5,opt,name=http_hook_timeout,json=httpHookTimeout,proto3,oneof" json:"http_hook_timeout,omitempty"`
	// List of headers to forward from client.
	HooksHttpProxyHeaders []string `protobuf:"bytes,6,rep,name=hooks_http_proxy_headers,json=hooksHttpProxyHeaders,proto3" json:"hooks_http_proxy_headers,omitempty"`
	// / Directory for executable hook files.
	// / This parameter is used to call executables from dir.
	HooksDir *string `protobuf:"bytes,7,opt,name=hooks_dir,json=hooksDir,proto3,oneof" json:"hooks_dir,omitempty"`
	// / Executable file which must be called for notifying about upload status.
	HooksFile     *string           `protobuf:"bytes,8,opt,name=hooks_file,json=hooksFile,proto3,oneof" json:"hooks_file,omitempty"`
	AmqpHookOpts  *AMQPHooksOptions `protobuf:"bytes,9,opt,name=amqp_hook_opts,json=amqpHookOpts,proto3" json:"amqp_hook_opts,omitempty"`
	KafkaHookOpts *KafkaHookOptions `protobuf:"bytes,10,opt,name=kafka_hook_opts,json=kafkaHookOpts,proto3" json:"kafka_hook_opts,omitempty"`
	NatsHookOpts  *NatsHookOptions  `protobuf:"bytes,11,opt,name=nats_hook_opts,json=natsHookOpts,proto3" json:"nats_hook_opts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NotificationsOptions) Reset() {
	*x = NotificationsOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NotificationsOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NotificationsOptions) ProtoMessage() {}

func (x *NotificationsOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NotificationsOptions.ProtoReflect.Descriptor instead.
func (*NotificationsOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{6}
}

func (x *NotificationsOptions) GetHooksFormat() Format {
	if x != nil {
		return x.HooksFormat
	}
	return Format_DEFAULT
}

func (x *NotificationsOptions) GetHooks() []Hook {
	if x != nil {
		return x.Hooks
	}
	return nil
}

func (x *NotificationsOptions) GetBehindProxy() bool {
	if x != nil {
		return x.BehindProxy
	}
	return false
}

func (x *NotificationsOptions) GetHooksHttpUrls() []string {
	if x != nil {
		return x.HooksHttpUrls
	}
	return nil
}

func (x *NotificationsOptions) GetHttpHookTimeout() uint64 {
	if x != nil && x.HttpHookTimeout != nil {
		return *x.HttpHookTimeout
	}
	return 0
}

func (x *NotificationsOptions) GetHooksHttpProxyHeaders() []string {
	if x != nil {
		return x.HooksHttpProxyHeaders
	}
	return nil
}

func (x *NotificationsOptions) GetHooksDir() string {
	if x != nil && x.HooksDir != nil {
		return *x.HooksDir
	}
	return ""
}

func (x *NotificationsOptions) GetHooksFile() string {
	if x != nil && x.HooksFile != nil {
		return *x.HooksFile
	}
	return ""
}

func (x *NotificationsOptions) GetAmqpHookOpts() *AMQPHooksOptions {
	if x != nil {
		return x.AmqpHookOpts
	}
	return nil
}

func (x *NotificationsOptions) GetKafkaHookOpts() *KafkaHookOptions {
	if x != nil {
		return x.KafkaHookOpts
	}
	return nil
}

func (x *NotificationsOptions) GetNatsHookOpts() *NatsHookOptions {
	if x != nil {
		return x.NatsHookOpts
	}
	return nil
}

type SentryOptions struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Dsn           *string                `protobuf:"bytes,1,opt,name=dsn,proto3,oneof" json:"dsn,omitempty"`
	SampleRate    float32                `protobuf:"fixed32,2,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"` // f32 is represented as float
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SentryOptions) Reset() {
	*x = SentryOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SentryOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SentryOptions) ProtoMessage() {}

func (x *SentryOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SentryOptions.ProtoReflect.Descriptor instead.
func (*SentryOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{7}
}

func (x *SentryOptions) GetDsn() string {
	if x != nil && x.Dsn != nil {
		return *x.Dsn
	}
	return ""
}

func (x *SentryOptions) GetSampleRate() float32 {
	if x != nil {
		return x.SampleRate
	}
	return 0
}

// / Tus protocol implementation.
// /
// / This program is a web-server that implements protocol for resumable uploads.
// /
// / You can read more about protocol [here](https://tus.io/).
type RustusConf struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Rustus server host
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// / Rustus server port
	Port                   uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	DisableHealthAccessLog bool   `protobuf:"varint,3,opt,name=disable_health_access_log,json=disableHealthAccessLog,proto3" json:"disable_health_access_log,omitempty"`
	// / Rustus base API url
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// / Allowed hosts for CORS protocol.
	// /
	// / By default all hosts are allowed.
	Cors []string `protobuf:"bytes,5,rep,name=cors,proto3" json:"cors,omitempty"`
	// / Maximum payload size.
	// /
	// / This limit used to reduce amount of consumed memory.
	MaxBodySize uint32 `protobuf:"varint,6,opt,name=max_body_size,json=maxBodySize,proto3" json:"max_body_size,omitempty"`
	// / Rustus maximum log level
	LogLevel string `protobuf:"bytes,7,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`
	// / Number of actix workers default value = number of cpu cores.
	Workers *uint32 `protobuf:"varint,8,opt,name=workers,proto3,oneof" json:"workers,omitempty"`
	// / Enabled extensions for TUS protocol.
	TusExtensions []Extensions `protobuf:"varint,9,rep,packed,name=tus_extensions,json=tusExtensions,proto3,enum=uploader.v1.Extensions" json:"tus_extensions,omitempty"`
	// / Enabling this parameter Will allow creation of empty files
	// / when Upload-Length header equals to 0.
	AllowEmpty bool `protobuf:"varint,10,opt,name=allow_empty,json=allowEmpty,proto3" json:"allow_empty,omitempty"`
	// / Remove part files after concatenation is done.
	// / By default rustus does nothing with part files after concatenation.
	// /
	// / This parameter is only needed if concatenation extension is enabled.
	RemoveParts bool `protobuf:"varint,11,opt,name=remove_parts,json=removeParts,proto3" json:"remove_parts,omitempty"`
	// / Maximum size of file that can be uploaded.
	// /
	// / If not set, file size is unlimited.
	MaxFileSize      *uint32               `protobuf:"varint,12,opt,name=max_file_size,json=maxFileSize,proto3,oneof" json:"max_file_size,omitempty"`
	StorageOpts      *DataStorageOptions   `protobuf:"bytes,13,opt,name=storage_opts,json=storageOpts,proto3" json:"storage_opts,omitempty"`
	InfoStorageOpts  *InfoStoreOptions     `protobuf:"bytes,14,opt,name=info_storage_opts,json=infoStorageOpts,proto3" json:"info_storage_opts,omitempty"`
	NotificationOpts *NotificationsOptions `protobuf:"bytes,15,opt,name=notification_opts,json=notificationOpts,proto3" json:"notification_opts,omitempty"`
	SentryOpts       *SentryOptions        `protobuf:"bytes,16,opt,name=sentry_opts,json=sentryOpts,proto3" json:"sentry_opts,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RustusConf) Reset() {
	*x = RustusConf{}
	mi := &file_uploader_v1_config_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RustusConf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RustusConf) ProtoMessage() {}

func (x *RustusConf) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RustusConf.ProtoReflect.Descriptor instead.
func (*RustusConf) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{8}
}

func (x *RustusConf) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *RustusConf) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *RustusConf) GetDisableHealthAccessLog() bool {
	if x != nil {
		return x.DisableHealthAccessLog
	}
	return false
}

func (x *RustusConf) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *RustusConf) GetCors() []string {
	if x != nil {
		return x.Cors
	}
	return nil
}

func (x *RustusConf) GetMaxBodySize() uint32 {
	if x != nil {
		return x.MaxBodySize
	}
	return 0
}

func (x *RustusConf) GetLogLevel() string {
	if x != nil {
		return x.LogLevel
	}
	return ""
}

func (x *RustusConf) GetWorkers() uint32 {
	if x != nil && x.Workers != nil {
		return *x.Workers
	}
	return 0
}

func (x *RustusConf) GetTusExtensions() []Extensions {
	if x != nil {
		return x.TusExtensions
	}
	return nil
}

func (x *RustusConf) GetAllowEmpty() bool {
	if x != nil {
		return x.AllowEmpty
	}
	return false
}

func (x *RustusConf) GetRemoveParts() bool {
	if x != nil {
		return x.RemoveParts
	}
	return false
}

func (x *RustusConf) GetMaxFileSize() uint32 {
	if x != nil && x.MaxFileSize != nil {
		return *x.MaxFileSize
	}
	return 0
}

func (x *RustusConf) GetStorageOpts() *DataStorageOptions {
	if x != nil {
		return x.StorageOpts
	}
	return nil
}

func (x *RustusConf) GetInfoStorageOpts() *InfoStoreOptions {
	if x != nil {
		return x.InfoStorageOpts
	}
	return nil
}

func (x *RustusConf) GetNotificationOpts() *NotificationsOptions {
	if x != nil {
		return x.NotificationOpts
	}
	return nil
}

func (x *RustusConf) GetSentryOpts() *SentryOptions {
	if x != nil {
		return x.SentryOpts
	}
	return nil
}

var File_uploader_v1_config_proto protoreflect.FileDescriptor

const file_uploader_v1_config_proto_rawDesc = "" +
	"\n" +
	"\x18uploader/v1/config.proto\x12\vuploader.v1\"\x8a\x01\n" +
	"\x11ExtraKafkaOptions\x12<\n" +
	"\x04opts\x18\x01 \x03(\v2(.uploader.v1.ExtraKafkaOptions.OptsEntryR\x04opts\x1a7\n" +
	"\tOptsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xa7\a\n" +
	"\x12DataStorageOptions\x12<\n" +
	"\astorage\x18\x01 \x01(\x0e2\".uploader.v1.AvailableDataStoragesR\astorage\x12\x19\n" +
	"\bdata_dir\x18\x02 \x01(\tR\adataDir\x12#\n" +
	"\rdir_structure\x18\x03 \x01(\tR\fdirStructure\x12\x1f\n" +
	"\vforce_fsync\x18\x04 \x01(\bR\n" +
	"forceFsync\x12 \n" +
	"\ts3_bucket\x18\x05 \x01(\tH\x00R\bs3Bucket\x88\x01\x01\x12 \n" +
	"\ts3_region\x18\x06 \x01(\tH\x01R\bs3Region\x88\x01\x01\x12'\n" +
	"\rs3_access_key\x18\a \x01(\tH\x02R\vs3AccessKey\x88\x01\x01\x120\n" +
	"\x12s3_access_key_path\x18\b \x01(\tH\x03R\x0fs3AccessKeyPath\x88\x01\x01\x12'\n" +
	"\rs3_secret_key\x18\t \x01(\tH\x04R\vs3SecretKey\x88\x01\x01\x120\n" +
	"\x12s3_secret_key_path\x18\n" +
	" \x01(\tH\x05R\x0fs3SecretKeyPath\x88\x01\x01\x12\x1a\n" +
	"\x06s3_url\x18\v \x01(\tH\x06R\x05s3Url\x88\x01\x01\x12-\n" +
	"\x13s3_force_path_style\x18\f \x01(\bR\x10s3ForcePathStyle\x12/\n" +
	"\x11s3_security_token\x18\r \x01(\tH\aR\x0fs3SecurityToken\x88\x01\x01\x12-\n" +
	"\x10s3_session_token\x18\x0e \x01(\tH\bR\x0es3SessionToken\x88\x01\x01\x12\"\n" +
	"\n" +
	"s3_profile\x18\x0f \x01(\tH\tR\ts3Profile\x88\x01\x01\x12\"\n" +
	"\n" +
	"s3_headers\x18\x10 \x01(\tH\n" +
	"R\ts3Headers\x88\x01\x01\x12C\n" +
	"\x1es3_concat_concurrent_downloads\x18\x11 \x01(\rR\x1bs3ConcatConcurrentDownloadsB\f\n" +
	"\n" +
	"_s3_bucketB\f\n" +
	"\n" +
	"_s3_regionB\x10\n" +
	"\x0e_s3_access_keyB\x15\n" +
	"\x13_s3_access_key_pathB\x10\n" +
	"\x0e_s3_secret_keyB\x15\n" +
	"\x13_s3_secret_key_pathB\t\n" +
	"\a_s3_urlB\x14\n" +
	"\x12_s3_security_tokenB\x13\n" +
	"\x11_s3_session_tokenB\r\n" +
	"\v_s3_profileB\r\n" +
	"\v_s3_headers\"\xfc\x01\n" +
	"\x10InfoStoreOptions\x12E\n" +
	"\finfo_storage\x18\x01 \x01(\x0e2\".uploader.v1.AvailableInfoStoragesR\vinfoStorage\x12\x19\n" +
	"\binfo_dir\x18\x02 \x01(\tR\ainfoDir\x12#\n" +
	"\vinfo_db_dsn\x18\x03 \x01(\tH\x00R\tinfoDbDsn\x88\x01\x01\x127\n" +
	"\x15redis_info_expiration\x18\x04 \x01(\rH\x01R\x13redisInfoExpiration\x88\x01\x01B\x0e\n" +
	"\f_info_db_dsnB\x18\n" +
	"\x16_redis_info_expiration\"\xb4\x05\n" +
	"\x10AMQPHooksOptions\x12\x15\n" +
	"\x03url\x18\x01 \x01(\tH\x00R\x03url\x88\x01\x01\x12)\n" +
	"\x10declare_exchange\x18\x02 \x01(\bR\x0fdeclareExchange\x12%\n" +
	"\x0edeclare_queues\x18\x03 \x01(\bR\rdeclareQueues\x12)\n" +
	"\x10durable_exchange\x18\x04 \x01(\bR\x0fdurableExchange\x12%\n" +
	"\x0edurable_queues\x18\x05 \x01(\bR\rdurableQueues\x12\x16\n" +
	"\x06celery\x18\x06 \x01(\bR\x06celery\x12\x1a\n" +
	"\bexchange\x18\a \x01(\tR\bexchange\x12#\n" +
	"\rexchange_kind\x18\b \x01(\tR\fexchangeKind\x12$\n" +
	"\vrouting_key\x18\t \x01(\tH\x01R\n" +
	"routingKey\x88\x01\x01\x12#\n" +
	"\rqueues_prefix\x18\n" +
	" \x01(\tR\fqueuesPrefix\x120\n" +
	"\x14connection_pool_size\x18\v \x01(\x04R\x12connectionPoolSize\x12*\n" +
	"\x11channel_pool_size\x18\f \x01(\x04R\x0fchannelPoolSize\x12;\n" +
	"\x17idle_connection_timeout\x18\r \x01(\x04H\x02R\x15idleConnectionTimeout\x88\x01\x01\x127\n" +
	"\x15idle_channels_timeout\x18\x0e \x01(\x04H\x03R\x13idleChannelsTimeout\x88\x01\x01\x12\x1f\n" +
	"\vauto_delete\x18\x0f \x01(\bR\n" +
	"autoDeleteB\x06\n" +
	"\x04_urlB\x0e\n" +
	"\f_routing_keyB\x1a\n" +
	"\x18_idle_connection_timeoutB\x18\n" +
	"\x16_idle_channels_timeout\"\xfa\x03\n" +
	"\x10KafkaHookOptions\x12\x17\n" +
	"\x04urls\x18\x01 \x01(\tH\x00R\x04urls\x88\x01\x01\x12 \n" +
	"\tclient_id\x18\x02 \x01(\tH\x01R\bclientId\x88\x01\x01\x12\x19\n" +
	"\x05topic\x18\x03 \x01(\tH\x02R\x05topic\x88\x01\x01\x12\x1b\n" +
	"\x06prefix\x18\x04 \x01(\tH\x03R\x06prefix\x88\x01\x01\x12(\n" +
	"\rrequired_acks\x18\x05 \x01(\tH\x04R\frequiredAcks\x88\x01\x01\x12%\n" +
	"\vcompression\x18\x06 \x01(\tH\x05R\vcompression\x88\x01\x01\x12&\n" +
	"\fidle_timeout\x18\a \x01(\x04H\x06R\vidleTimeout\x88\x01\x01\x12&\n" +
	"\fsend_timeout\x18\b \x01(\x04H\aR\vsendTimeout\x88\x01\x01\x12M\n" +
	"\x10extra_kafka_opts\x18\t \x01(\v2\x1e.uploader.v1.ExtraKafkaOptionsH\bR\x0eextraKafkaOpts\x88\x01\x01B\a\n" +
	"\x05_urlsB\f\n" +
	"\n" +
	"_client_idB\b\n" +
	"\x06_topicB\t\n" +
	"\a_prefixB\x10\n" +
	"\x0e_required_acksB\x0e\n" +
	"\f_compressionB\x0f\n" +
	"\r_idle_timeoutB\x0f\n" +
	"\r_send_timeoutB\x13\n" +
	"\x11_extra_kafka_opts\"\xa3\x02\n" +
	"\x0fNatsHookOptions\x12\x12\n" +
	"\x04urls\x18\x01 \x03(\tR\x04urls\x12\x1d\n" +
	"\asubject\x18\x02 \x01(\tH\x00R\asubject\x88\x01\x01\x12\x1b\n" +
	"\x06prefix\x18\x03 \x01(\tH\x01R\x06prefix\x88\x01\x01\x12(\n" +
	"\x10wait_for_replies\x18\x04 \x01(\bR\x0ewaitForReplies\x12\x1f\n" +
	"\busername\x18\x05 \x01(\tH\x02R\busername\x88\x01\x01\x12\x1f\n" +
	"\bpassword\x18\x06 \x01(\tH\x03R\bpassword\x88\x01\x01\x12\x19\n" +
	"\x05token\x18\a \x01(\tH\x04R\x05token\x88\x01\x01B\n" +
	"\n" +
	"\b_subjectB\t\n" +
	"\a_prefixB\v\n" +
	"\t_usernameB\v\n" +
	"\t_passwordB\b\n" +
	"\x06_token\"\xf5\x04\n" +
	"\x14NotificationsOptions\x126\n" +
	"\fhooks_format\x18\x01 \x01(\x0e2\x13.uploader.v1.FormatR\vhooksFormat\x12'\n" +
	"\x05hooks\x18\x02 \x03(\x0e2\x11.uploader.v1.HookR\x05hooks\x12!\n" +
	"\fbehind_proxy\x18\x03 \x01(\bR\vbehindProxy\x12&\n" +
	"\x0fhooks_http_urls\x18\x04 \x03(\tR\rhooksHttpUrls\x12/\n" +
	"\x11http_hook_timeout\x18\x05 \x01(\x04H\x00R\x0fhttpHookTimeout\x88\x01\x01\x127\n" +
	"\x18hooks_http_proxy_headers\x18\x06 \x03(\tR\x15hooksHttpProxyHeaders\x12 \n" +
	"\thooks_dir\x18\a \x01(\tH\x01R\bhooksDir\x88\x01\x01\x12\"\n" +
	"\n" +
	"hooks_file\x18\b \x01(\tH\x02R\thooksFile\x88\x01\x01\x12C\n" +
	"\x0eamqp_hook_opts\x18\t \x01(\v2\x1d.uploader.v1.AMQPHooksOptionsR\famqpHookOpts\x12E\n" +
	"\x0fkafka_hook_opts\x18\n" +
	" \x01(\v2\x1d.uploader.v1.KafkaHookOptionsR\rkafkaHookOpts\x12B\n" +
	"\x0enats_hook_opts\x18\v \x01(\v2\x1c.uploader.v1.NatsHookOptionsR\fnatsHookOptsB\x14\n" +
	"\x12_http_hook_timeoutB\f\n" +
	"\n" +
	"_hooks_dirB\r\n" +
	"\v_hooks_file\"O\n" +
	"\rSentryOptions\x12\x15\n" +
	"\x03dsn\x18\x01 \x01(\tH\x00R\x03dsn\x88\x01\x01\x12\x1f\n" +
	"\vsample_rate\x18\x02 \x01(\x02R\n" +
	"sampleRateB\x06\n" +
	"\x04_dsn\"\xdc\x05\n" +
	"\n" +
	"RustusConf\x12\x12\n" +
	"\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n" +
	"\x04port\x18\x02 \x01(\rR\x04port\x129\n" +
	"\x19disable_health_access_log\x18\x03 \x01(\bR\x16disableHealthAccessLog\x12\x10\n" +
	"\x03url\x18\x04 \x01(\tR\x03url\x12\x12\n" +
	"\x04cors\x18\x05 \x03(\tR\x04cors\x12\"\n" +
	"\rmax_body_size\x18\x06 \x01(\rR\vmaxBodySize\x12\x1b\n" +
	"\tlog_level\x18\a \x01(\tR\blogLevel\x12\x1d\n" +
	"\aworkers\x18\b \x01(\rH\x00R\aworkers\x88\x01\x01\x12>\n" +
	"\x0etus_extensions\x18\t \x03(\x0e2\x17.uploader.v1.ExtensionsR\rtusExtensions\x12\x1f\n" +
	"\vallow_empty\x18\n" +
	" \x01(\bR\n" +
	"allowEmpty\x12!\n" +
	"\fremove_parts\x18\v \x01(\bR\vremoveParts\x12'\n" +
	"\rmax_file_size\x18\f \x01(\rH\x01R\vmaxFileSize\x88\x01\x01\x12B\n" +
	"\fstorage_opts\x18\r \x01(\v2\x1f.uploader.v1.DataStorageOptionsR\vstorageOpts\x12I\n" +
	"\x11info_storage_opts\x18\x0e \x01(\v2\x1d.uploader.v1.InfoStoreOptionsR\x0finfoStorageOpts\x12N\n" +
	"\x11notification_opts\x18\x0f \x01(\v2!.uploader.v1.NotificationsOptionsR\x10notificationOpts\x12;\n" +
	"\vsentry_opts\x18\x10 \x01(\v2\x1a.uploader.v1.SentryOptionsR\n" +
	"sentryOptsB\n" +
	"\n" +
	"\b_workersB\x10\n" +
	"\x0e_max_file_size*@\n" +
	"\x15AvailableDataStorages\x12\x10\n" +
	"\fFILE_STORAGE\x10\x00\x12\r\n" +
	"\tHYBRID_S3\x10\x01\x12\x06\n" +
	"\x02S3\x10\x02*-\n" +
	"\x15AvailableInfoStorages\x12\t\n" +
	"\x05FILES\x10\x00\x12\t\n" +
	"\x05REDIS\x10\x01*'\n" +
	"\x06Format\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\b\n" +
	"\x04TUSD\x10\x01\x12\x06\n" +
	"\x02V2\x10\x02*q\n" +
	"\x04Hook\x12\x0e\n" +
	"\n" +
	"PRE_CREATE\x10\x00\x12\x0f\n" +
	"\vPOST_CREATE\x10\x01\x12\x10\n" +
	"\fPOST_RECEIVE\x10\x02\x12\x11\n" +
	"\rPRE_TERMINATE\x10\x03\x12\x12\n" +
	"\x0ePOST_TERMINATE\x10\x04\x12\x0f\n" +
	"\vPOST_FINISH\x10\x05*\x8e\x01\n" +
	"\n" +
	"Extensions\x12\v\n" +
	"\aGETTING\x10\x00\x12\f\n" +
	"\bCREATION\x10\x01\x12\x0f\n" +
	"\vTERMINATION\x10\x02\x12\x18\n" +
	"\x14CREATION_WITH_UPLOAD\x10\x03\x12\x19\n" +
	"\x15CREATION_DEFER_LENGTH\x10\x04\x12\x11\n" +
	"\rCONCATENATION\x10\x05\x12\f\n" +
	"\bCHECKSUM\x10\x06Bu\n" +
	"\x1corg.megacommerce.uploader.v1B\vConfigProtoZEgithub.com/ahmad-khatib0-org/megacommerce-proto/gen/go/uploader/v1;v1\xf8\x01\x01b\x06proto3"

var (
	file_uploader_v1_config_proto_rawDescOnce sync.Once
	file_uploader_v1_config_proto_rawDescData []byte
)

func file_uploader_v1_config_proto_rawDescGZIP() []byte {
	file_uploader_v1_config_proto_rawDescOnce.Do(func() {
		file_uploader_v1_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_uploader_v1_config_proto_rawDesc), len(file_uploader_v1_config_proto_rawDesc)))
	})
	return file_uploader_v1_config_proto_rawDescData
}

var file_uploader_v1_config_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_uploader_v1_config_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_uploader_v1_config_proto_goTypes = []any{
	(AvailableDataStorages)(0),   // 0: uploader.v1.AvailableDataStorages
	(AvailableInfoStorages)(0),   // 1: uploader.v1.AvailableInfoStorages
	(Format)(0),                  // 2: uploader.v1.Format
	(Hook)(0),                    // 3: uploader.v1.Hook
	(Extensions)(0),              // 4: uploader.v1.Extensions
	(*ExtraKafkaOptions)(nil),    // 5: uploader.v1.ExtraKafkaOptions
	(*DataStorageOptions)(nil),   // 6: uploader.v1.DataStorageOptions
	(*InfoStoreOptions)(nil),     // 7: uploader.v1.InfoStoreOptions
	(*AMQPHooksOptions)(nil),     // 8: uploader.v1.AMQPHooksOptions
	(*KafkaHookOptions)(nil),     // 9: uploader.v1.KafkaHookOptions
	(*NatsHookOptions)(nil),      // 10: uploader.v1.NatsHookOptions
	(*NotificationsOptions)(nil), // 11: uploader.v1.NotificationsOptions
	(*SentryOptions)(nil),        // 12: uploader.v1.SentryOptions
	(*RustusConf)(nil),           // 13: uploader.v1.RustusConf
	nil,                          // 14: uploader.v1.ExtraKafkaOptions.OptsEntry
}
var file_uploader_v1_config_proto_depIdxs = []int32{
	14, // 0: uploader.v1.ExtraKafkaOptions.opts:type_name -> uploader.v1.ExtraKafkaOptions.OptsEntry
	0,  // 1: uploader.v1.DataStorageOptions.storage:type_name -> uploader.v1.AvailableDataStorages
	1,  // 2: uploader.v1.InfoStoreOptions.info_storage:type_name -> uploader.v1.AvailableInfoStorages
	5,  // 3: uploader.v1.KafkaHookOptions.extra_kafka_opts:type_name -> uploader.v1.ExtraKafkaOptions
	2,  // 4: uploader.v1.NotificationsOptions.hooks_format:type_name -> uploader.v1.Format
	3,  // 5: uploader.v1.NotificationsOptions.hooks:type_name -> uploader.v1.Hook
	8,  // 6: uploader.v1.NotificationsOptions.amqp_hook_opts:type_name -> uploader.v1.AMQPHooksOptions
	9,  // 7: uploader.v1.NotificationsOptions.kafka_hook_opts:type_name -> uploader.v1.KafkaHookOptions
	10, // 8: uploader.v1.NotificationsOptions.nats_hook_opts:type_name -> uploader.v1.NatsHookOptions
	4,  // 9: uploader.v1.RustusConf.tus_extensions:type_name -> uploader.v1.Extensions
	6,  // 10: uploader.v1.RustusConf.storage_opts:type_name -> uploader.v1.DataStorageOptions
	7,  // 11: uploader.v1.RustusConf.info_storage_opts:type_name -> uploader.v1.InfoStoreOptions
	11, // 12: uploader.v1.RustusConf.notification_opts:type_name -> uploader.v1.NotificationsOptions
	12, // 13: uploader.v1.RustusConf.sentry_opts:type_name -> uploader.v1.SentryOptions
	14, // [14:14] is the sub-list for method output_type
	14, // [14:14] is the sub-list for method input_type
	14, // [14:14] is the sub-list for extension type_name
	14, // [14:14] is the sub-list for extension extendee
	0,  // [0:14] is the sub-list for field type_name
}

func init() { file_uploader_v1_config_proto_init() }
func file_uploader_v1_config_proto_init() {
	if File_uploader_v1_config_proto != nil {
		return
	}
	file_uploader_v1_config_proto_msgTypes[1].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[2].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[3].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[4].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[5].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[6].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[7].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[8].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_uploader_v1_config_proto_rawDesc), len(file_uploader_v1_config_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_uploader_v1_config_proto_goTypes,
		DependencyIndexes: file_uploader_v1_config_proto_depIdxs,
		EnumInfos:         file_uploader_v1_config_proto_enumTypes,
		MessageInfos:      file_uploader_v1_config_proto_msgTypes,
	}.Build()
	File_uploader_v1_config_proto = out.File
	file_uploader_v1_config_proto_goTypes = nil
	file_uploader_v1_config_proto_depIdxs = nil
}
