// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        (unknown)
// source: uploader/v1/config.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AvailableDataStorages int32

const (
	AvailableDataStorages_AVAILABLE_DATA_STORAGES_UNSPECIFIED AvailableDataStorages = 0
	AvailableDataStorages_FILE_STORAGE                        AvailableDataStorages = 1
	AvailableDataStorages_S3                                  AvailableDataStorages = 2
	AvailableDataStorages_HYBRID_S3                           AvailableDataStorages = 3
)

// Enum value maps for AvailableDataStorages.
var (
	AvailableDataStorages_name = map[int32]string{
		0: "AVAILABLE_DATA_STORAGES_UNSPECIFIED",
		1: "FILE_STORAGE",
		2: "S3",
		3: "HYBRID_S3",
	}
	AvailableDataStorages_value = map[string]int32{
		"AVAILABLE_DATA_STORAGES_UNSPECIFIED": 0,
		"FILE_STORAGE":                        1,
		"S3":                                  2,
		"HYBRID_S3":                           3,
	}
)

func (x AvailableDataStorages) Enum() *AvailableDataStorages {
	p := new(AvailableDataStorages)
	*p = x
	return p
}

func (x AvailableDataStorages) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AvailableDataStorages) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[0].Descriptor()
}

func (AvailableDataStorages) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[0]
}

func (x AvailableDataStorages) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AvailableDataStorages.Descriptor instead.
func (AvailableDataStorages) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{0}
}

type AvailableInfoStorages int32

const (
	AvailableInfoStorages_AVAILABLE_INFO_STORAGES_UNSPECIFIED AvailableInfoStorages = 0
	AvailableInfoStorages_FILES                               AvailableInfoStorages = 1
	AvailableInfoStorages_REDIS                               AvailableInfoStorages = 2
	AvailableInfoStorages_POSTGRES                            AvailableInfoStorages = 3
)

// Enum value maps for AvailableInfoStorages.
var (
	AvailableInfoStorages_name = map[int32]string{
		0: "AVAILABLE_INFO_STORAGES_UNSPECIFIED",
		1: "FILES",
		2: "REDIS",
		3: "POSTGRES",
	}
	AvailableInfoStorages_value = map[string]int32{
		"AVAILABLE_INFO_STORAGES_UNSPECIFIED": 0,
		"FILES":                               1,
		"REDIS":                               2,
		"POSTGRES":                            3,
	}
)

func (x AvailableInfoStorages) Enum() *AvailableInfoStorages {
	p := new(AvailableInfoStorages)
	*p = x
	return p
}

func (x AvailableInfoStorages) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AvailableInfoStorages) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[1].Descriptor()
}

func (AvailableInfoStorages) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[1]
}

func (x AvailableInfoStorages) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AvailableInfoStorages.Descriptor instead.
func (AvailableInfoStorages) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{1}
}

type Hook int32

const (
	Hook_HOOK_UNSPECIFIED Hook = 0
	Hook_PRE_CREATE       Hook = 1
	Hook_POST_CREATE      Hook = 2
	Hook_POST_RECEIVE     Hook = 3
	Hook_PRE_TERMINATE    Hook = 4
	Hook_POST_TERMINATE   Hook = 5
	Hook_POST_FINISH      Hook = 6
)

// Enum value maps for Hook.
var (
	Hook_name = map[int32]string{
		0: "HOOK_UNSPECIFIED",
		1: "PRE_CREATE",
		2: "POST_CREATE",
		3: "POST_RECEIVE",
		4: "PRE_TERMINATE",
		5: "POST_TERMINATE",
		6: "POST_FINISH",
	}
	Hook_value = map[string]int32{
		"HOOK_UNSPECIFIED": 0,
		"PRE_CREATE":       1,
		"POST_CREATE":      2,
		"POST_RECEIVE":     3,
		"PRE_TERMINATE":    4,
		"POST_TERMINATE":   5,
		"POST_FINISH":      6,
	}
)

func (x Hook) Enum() *Hook {
	p := new(Hook)
	*p = x
	return p
}

func (x Hook) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Hook) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[2].Descriptor()
}

func (Hook) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[2]
}

func (x Hook) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Hook.Descriptor instead.
func (Hook) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{2}
}

type Format int32

const (
	Format_FORMAT_UNSPECIFIED Format = 0
	Format_DEFAULT            Format = 1
	Format_V2                 Format = 2
)

// Enum value maps for Format.
var (
	Format_name = map[int32]string{
		0: "FORMAT_UNSPECIFIED",
		1: "DEFAULT",
		2: "V2",
	}
	Format_value = map[string]int32{
		"FORMAT_UNSPECIFIED": 0,
		"DEFAULT":            1,
		"V2":                 2,
	}
)

func (x Format) Enum() *Format {
	p := new(Format)
	*p = x
	return p
}

func (x Format) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Format) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[3].Descriptor()
}

func (Format) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[3]
}

func (x Format) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Format.Descriptor instead.
func (Format) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{3}
}

type Extension int32

const (
	Extension_EXTENSION_UNSPECIFIED Extension = 0
	Extension_GETTING               Extension = 1
	Extension_CREATION              Extension = 2
	Extension_CREATION_WITH_UPLOAD  Extension = 3
	Extension_CREATION_DEFER_LENGTH Extension = 4
	Extension_TERMINATION           Extension = 5
	Extension_CONCATENATION         Extension = 6
	Extension_CHECKSUM              Extension = 7
)

// Enum value maps for Extension.
var (
	Extension_name = map[int32]string{
		0: "EXTENSION_UNSPECIFIED",
		1: "GETTING",
		2: "CREATION",
		3: "CREATION_WITH_UPLOAD",
		4: "CREATION_DEFER_LENGTH",
		5: "TERMINATION",
		6: "CONCATENATION",
		7: "CHECKSUM",
	}
	Extension_value = map[string]int32{
		"EXTENSION_UNSPECIFIED": 0,
		"GETTING":               1,
		"CREATION":              2,
		"CREATION_WITH_UPLOAD":  3,
		"CREATION_DEFER_LENGTH": 4,
		"TERMINATION":           5,
		"CONCATENATION":         6,
		"CHECKSUM":              7,
	}
)

func (x Extension) Enum() *Extension {
	p := new(Extension)
	*p = x
	return p
}

func (x Extension) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Extension) Descriptor() protoreflect.EnumDescriptor {
	return file_uploader_v1_config_proto_enumTypes[4].Descriptor()
}

func (Extension) Type() protoreflect.EnumType {
	return &file_uploader_v1_config_proto_enumTypes[4]
}

func (x Extension) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Extension.Descriptor instead.
func (Extension) EnumDescriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{4}
}

type DataStorageOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Rustus storage type.
	//
	// Storages are used to store uploads.
	Storage AvailableDataStorages `protobuf:"varint,1,opt,name=storage,proto3,enum=uploader.v1.AvailableDataStorages" json:"storage,omitempty"` // NOTE: Rust default is `default_storage()` -> FileStorage. Apply this default if field absent.
	// Rustus data directory
	//
	// This directory is used to store files for all `file_storage` storages.
	// PathBuf in Rust -> string path here.
	DataDir string `protobuf:"bytes,2,opt,name=data_dir,json=dataDir,proto3" json:"data_dir,omitempty"` // NOTE: Rust default is `./data`.
	// Storage directory structure. This template shows inner directory structure.
	// You can use following variables: day, month, year or even environment variables.
	// Example: "/year/month/day/env[HOSTNAME]/".
	DirStructure string `protobuf:"bytes,3,opt,name=dir_structure,json=dirStructure,proto3" json:"dir_structure,omitempty"`
	// Forces fsync call after writing chunk to filesystem. Useful for network filesystems.
	ForceFsync bool `protobuf:"varint,4,opt,name=force_fsync,json=forceFsync,proto3" json:"force_fsync,omitempty"`
	// S3 bucket to upload files to.
	//
	// This parameter is required for s3-based storages.
	S3Bucket *string `protobuf:"bytes,10,opt,name=s3_bucket,json=s3Bucket,proto3,oneof" json:"s3_bucket,omitempty"`
	// S3 region.
	//
	// This parameter is required for s3-based storages.
	S3Region *string `protobuf:"bytes,11,opt,name=s3_region,json=s3Region,proto3,oneof" json:"s3_region,omitempty"`
	// S3 access key.
	//
	// This parameter is required for s3-based storages.
	S3AccessKey *string `protobuf:"bytes,12,opt,name=s3_access_key,json=s3AccessKey,proto3,oneof" json:"s3_access_key,omitempty"`
	// S3 access key path.
	//
	// path to file that has s3-access-key inside.
	//
	// This parameter is used for s3-based storages.
	S3AccessKeyPath *string `protobuf:"bytes,13,opt,name=s3_access_key_path,json=s3AccessKeyPath,proto3,oneof" json:"s3_access_key_path,omitempty"`
	// S3 secret key.
	//
	// This parameter is required for s3-based storages.
	S3SecretKey *string `protobuf:"bytes,14,opt,name=s3_secret_key,json=s3SecretKey,proto3,oneof" json:"s3_secret_key,omitempty"`
	// S3 secret key path.
	//
	// path to file that has s3-secret-key inside.
	//
	// This parameter is required for s3-based storages.
	S3SecretKeyPath *string `protobuf:"bytes,15,opt,name=s3_secret_key_path,json=s3SecretKeyPath,proto3,oneof" json:"s3_secret_key_path,omitempty"`
	// S3 URL.
	//
	// This parameter is required for s3-based storages.
	S3Url *string `protobuf:"bytes,16,opt,name=s3_url,json=s3Url,proto3,oneof" json:"s3_url,omitempty"`
	// S3 force path style.
	//
	// This parameter is required for some s3-based storages (e.g. MinIO).
	S3ForcePathStyle bool `protobuf:"varint,17,opt,name=s3_force_path_style,json=s3ForcePathStyle,proto3" json:"s3_force_path_style,omitempty"`
	// S3 security token.
	//
	// This parameter is used for temporary credentials.
	S3SecurityToken *string `protobuf:"bytes,18,opt,name=s3_security_token,json=s3SecurityToken,proto3,oneof" json:"s3_security_token,omitempty"`
	// S3 session token.
	S3SessionToken *string `protobuf:"bytes,19,opt,name=s3_session_token,json=s3SessionToken,proto3,oneof" json:"s3_session_token,omitempty"`
	// S3 profile.
	S3Profile *string `protobuf:"bytes,20,opt,name=s3_profile,json=s3Profile,proto3,oneof" json:"s3_profile,omitempty"`
	// Additional S3 headers. These headers are passed to every request to s3.
	// Useful for configuring ACLs.
	S3Headers *string `protobuf:"bytes,21,opt,name=s3_headers,json=s3Headers,proto3,oneof" json:"s3_headers,omitempty"`
	// Number of concurrent downloads of partial files from S3.
	// When performing concatenation, Rustus downloads all partial files
	// from S3 and concatenates them into a single file.
	//
	// This parameter controls the number of concurrent downloads.
	S3ConcatConcurrentDownloads uint32 `protobuf:"varint,22,opt,name=s3_concat_concurrent_downloads,json=s3ConcatConcurrentDownloads,proto3" json:"s3_concat_concurrent_downloads,omitempty"` // NOTE: Rust default = 10
	unknownFields               protoimpl.UnknownFields
	sizeCache                   protoimpl.SizeCache
}

func (x *DataStorageOptions) Reset() {
	*x = DataStorageOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DataStorageOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DataStorageOptions) ProtoMessage() {}

func (x *DataStorageOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DataStorageOptions.ProtoReflect.Descriptor instead.
func (*DataStorageOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{0}
}

func (x *DataStorageOptions) GetStorage() AvailableDataStorages {
	if x != nil {
		return x.Storage
	}
	return AvailableDataStorages_AVAILABLE_DATA_STORAGES_UNSPECIFIED
}

func (x *DataStorageOptions) GetDataDir() string {
	if x != nil {
		return x.DataDir
	}
	return ""
}

func (x *DataStorageOptions) GetDirStructure() string {
	if x != nil {
		return x.DirStructure
	}
	return ""
}

func (x *DataStorageOptions) GetForceFsync() bool {
	if x != nil {
		return x.ForceFsync
	}
	return false
}

func (x *DataStorageOptions) GetS3Bucket() string {
	if x != nil && x.S3Bucket != nil {
		return *x.S3Bucket
	}
	return ""
}

func (x *DataStorageOptions) GetS3Region() string {
	if x != nil && x.S3Region != nil {
		return *x.S3Region
	}
	return ""
}

func (x *DataStorageOptions) GetS3AccessKey() string {
	if x != nil && x.S3AccessKey != nil {
		return *x.S3AccessKey
	}
	return ""
}

func (x *DataStorageOptions) GetS3AccessKeyPath() string {
	if x != nil && x.S3AccessKeyPath != nil {
		return *x.S3AccessKeyPath
	}
	return ""
}

func (x *DataStorageOptions) GetS3SecretKey() string {
	if x != nil && x.S3SecretKey != nil {
		return *x.S3SecretKey
	}
	return ""
}

func (x *DataStorageOptions) GetS3SecretKeyPath() string {
	if x != nil && x.S3SecretKeyPath != nil {
		return *x.S3SecretKeyPath
	}
	return ""
}

func (x *DataStorageOptions) GetS3Url() string {
	if x != nil && x.S3Url != nil {
		return *x.S3Url
	}
	return ""
}

func (x *DataStorageOptions) GetS3ForcePathStyle() bool {
	if x != nil {
		return x.S3ForcePathStyle
	}
	return false
}

func (x *DataStorageOptions) GetS3SecurityToken() string {
	if x != nil && x.S3SecurityToken != nil {
		return *x.S3SecurityToken
	}
	return ""
}

func (x *DataStorageOptions) GetS3SessionToken() string {
	if x != nil && x.S3SessionToken != nil {
		return *x.S3SessionToken
	}
	return ""
}

func (x *DataStorageOptions) GetS3Profile() string {
	if x != nil && x.S3Profile != nil {
		return *x.S3Profile
	}
	return ""
}

func (x *DataStorageOptions) GetS3Headers() string {
	if x != nil && x.S3Headers != nil {
		return *x.S3Headers
	}
	return ""
}

func (x *DataStorageOptions) GetS3ConcatConcurrentDownloads() uint32 {
	if x != nil {
		return x.S3ConcatConcurrentDownloads
	}
	return 0
}

type InfoStoreOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Type of info storage.
	// /
	// / Info storages are used to store information about uploads.
	// /
	// / This information is used in HEAD requests.
	InfoStorage AvailableInfoStorages `protobuf:"varint,1,opt,name=info_storage,json=infoStorage,proto3,enum=uploader.v1.AvailableInfoStorages" json:"info_storage,omitempty"` // NOTE: Rust default = Files
	// / Rustus info directory
	// /
	// / This directory is used to store .info files for `file_info_storage`.
	InfoDir string `protobuf:"bytes,2,opt,name=info_dir,json=infoDir,proto3" json:"info_dir,omitempty"` // NOTE: Rust default = "./data"
	// / Connection string for remote info storages.
	// /
	// / This connection string is used for storages which require connection.
	// / Examples of such storages are `Postgres`, `MySQL` or `Redis`.
	// /
	// / Value must include all connection details.
	InfoDbDsn *string `protobuf:"bytes,3,opt,name=info_db_dsn,json=infoDbDsn,proto3,oneof" json:"info_db_dsn,omitempty"`
	// redis_info_expiration: Option<usize> in Rust -> optional uint64 here
	RedisInfoExpiration *uint64 `protobuf:"varint,4,opt,name=redis_info_expiration,json=redisInfoExpiration,proto3,oneof" json:"redis_info_expiration,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *InfoStoreOptions) Reset() {
	*x = InfoStoreOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InfoStoreOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InfoStoreOptions) ProtoMessage() {}

func (x *InfoStoreOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InfoStoreOptions.ProtoReflect.Descriptor instead.
func (*InfoStoreOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{1}
}

func (x *InfoStoreOptions) GetInfoStorage() AvailableInfoStorages {
	if x != nil {
		return x.InfoStorage
	}
	return AvailableInfoStorages_AVAILABLE_INFO_STORAGES_UNSPECIFIED
}

func (x *InfoStoreOptions) GetInfoDir() string {
	if x != nil {
		return x.InfoDir
	}
	return ""
}

func (x *InfoStoreOptions) GetInfoDbDsn() string {
	if x != nil && x.InfoDbDsn != nil {
		return *x.InfoDbDsn
	}
	return ""
}

func (x *InfoStoreOptions) GetRedisInfoExpiration() uint64 {
	if x != nil && x.RedisInfoExpiration != nil {
		return *x.RedisInfoExpiration
	}
	return 0
}

type AMQPHooksOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Url for AMQP server.
	Url *string `protobuf:"bytes,1,opt,name=url,proto3,oneof" json:"url,omitempty"`
	// / Rustus will create exchange if enabled.
	DeclareExchange bool `protobuf:"varint,2,opt,name=declare_exchange,json=declareExchange,proto3" json:"declare_exchange,omitempty"`
	// / Rustus will create all queues for communication and bind them
	// / to exchange if enabled.
	DeclareQueues bool `protobuf:"varint,3,opt,name=declare_queues,json=declareQueues,proto3" json:"declare_queues,omitempty"`
	// / Durability type of exchange.
	DurableExchange bool `protobuf:"varint,4,opt,name=durable_exchange,json=durableExchange,proto3" json:"durable_exchange,omitempty"`
	// / Durability type of queues.
	DurableQueues bool `protobuf:"varint,5,opt,name=durable_queues,json=durableQueues,proto3" json:"durable_queues,omitempty"`
	// / Adds celery specific headers.
	Celery bool `protobuf:"varint,6,opt,name=celery,proto3" json:"celery,omitempty"`
	// / Name of amqp exchange.
	Exchange string `protobuf:"bytes,10,opt,name=exchange,proto3" json:"exchange,omitempty"` // default "rustus" in Rust
	// / Exchange kind.
	ExchangeKind string `protobuf:"bytes,11,opt,name=exchange_kind,json=exchangeKind,proto3" json:"exchange_kind,omitempty"` // default "topic" in Rust
	// / Routing key to use when sending message to an exchange.
	RoutingKey *string `protobuf:"bytes,12,opt,name=routing_key,json=routingKey,proto3,oneof" json:"routing_key,omitempty"`
	// / Prefix for all AMQP queues.
	QueuesPrefix string `protobuf:"bytes,13,opt,name=queues_prefix,json=queuesPrefix,proto3" json:"queues_prefix,omitempty"` // default "rustus" in Rust
	// / Maximum number of connections for `RabbitMQ`.
	ConnectionPoolSize uint64 `protobuf:"varint,14,opt,name=connection_pool_size,json=connectionPoolSize,proto3" json:"connection_pool_size,omitempty"` // default 10
	// / Maximum number of opened channels for each connection.
	ChannelPoolSize uint64 `protobuf:"varint,15,opt,name=channel_pool_size,json=channelPoolSize,proto3" json:"channel_pool_size,omitempty"` // default 10
	// / After this amount of time the connection will be dropped.
	IdleConnectionTimeout *uint64 `protobuf:"varint,16,opt,name=idle_connection_timeout,json=idleConnectionTimeout,proto3,oneof" json:"idle_connection_timeout,omitempty"`
	// / After this amount of time in seconds, the channel will be closed.
	IdleChannelsTimeout *uint64 `protobuf:"varint,17,opt,name=idle_channels_timeout,json=idleChannelsTimeout,proto3,oneof" json:"idle_channels_timeout,omitempty"`
	// / Declares all objects with auto-delete property set.
	AutoDelete    bool `protobuf:"varint,18,opt,name=auto_delete,json=autoDelete,proto3" json:"auto_delete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AMQPHooksOptions) Reset() {
	*x = AMQPHooksOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AMQPHooksOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AMQPHooksOptions) ProtoMessage() {}

func (x *AMQPHooksOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AMQPHooksOptions.ProtoReflect.Descriptor instead.
func (*AMQPHooksOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{2}
}

func (x *AMQPHooksOptions) GetUrl() string {
	if x != nil && x.Url != nil {
		return *x.Url
	}
	return ""
}

func (x *AMQPHooksOptions) GetDeclareExchange() bool {
	if x != nil {
		return x.DeclareExchange
	}
	return false
}

func (x *AMQPHooksOptions) GetDeclareQueues() bool {
	if x != nil {
		return x.DeclareQueues
	}
	return false
}

func (x *AMQPHooksOptions) GetDurableExchange() bool {
	if x != nil {
		return x.DurableExchange
	}
	return false
}

func (x *AMQPHooksOptions) GetDurableQueues() bool {
	if x != nil {
		return x.DurableQueues
	}
	return false
}

func (x *AMQPHooksOptions) GetCelery() bool {
	if x != nil {
		return x.Celery
	}
	return false
}

func (x *AMQPHooksOptions) GetExchange() string {
	if x != nil {
		return x.Exchange
	}
	return ""
}

func (x *AMQPHooksOptions) GetExchangeKind() string {
	if x != nil {
		return x.ExchangeKind
	}
	return ""
}

func (x *AMQPHooksOptions) GetRoutingKey() string {
	if x != nil && x.RoutingKey != nil {
		return *x.RoutingKey
	}
	return ""
}

func (x *AMQPHooksOptions) GetQueuesPrefix() string {
	if x != nil {
		return x.QueuesPrefix
	}
	return ""
}

func (x *AMQPHooksOptions) GetConnectionPoolSize() uint64 {
	if x != nil {
		return x.ConnectionPoolSize
	}
	return 0
}

func (x *AMQPHooksOptions) GetChannelPoolSize() uint64 {
	if x != nil {
		return x.ChannelPoolSize
	}
	return 0
}

func (x *AMQPHooksOptions) GetIdleConnectionTimeout() uint64 {
	if x != nil && x.IdleConnectionTimeout != nil {
		return *x.IdleConnectionTimeout
	}
	return 0
}

func (x *AMQPHooksOptions) GetIdleChannelsTimeout() uint64 {
	if x != nil && x.IdleChannelsTimeout != nil {
		return *x.IdleChannelsTimeout
	}
	return 0
}

func (x *AMQPHooksOptions) GetAutoDelete() bool {
	if x != nil {
		return x.AutoDelete
	}
	return false
}

type KafkaHookOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Kafka urls.
	// / List of brokers to connect to in the format `host:port`.
	// / If you have multiple brokers, separate them with commas.
	// / Corresponds to `bootstrap.servers` in Kafka configuration.
	Urls *string `protobuf:"bytes,1,opt,name=urls,proto3,oneof" json:"urls,omitempty"`
	// / Kafka producer client.id.
	ClientId *string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3,oneof" json:"client_id,omitempty"`
	// Mutual exclusion: topic OR prefix (Rust validate enforces this).
	//
	// Types that are valid to be assigned to TopicOrPrefix:
	//
	//	*KafkaHookOptions_Topic
	//	*KafkaHookOptions_Prefix
	TopicOrPrefix isKafkaHookOptions_TopicOrPrefix `protobuf_oneof:"topic_or_prefix"`
	// / Kafka required acks.
	RequiredAcks *string `protobuf:"bytes,5,opt,name=required_acks,json=requiredAcks,proto3,oneof" json:"required_acks,omitempty"`
	// / Compression codec.
	Compression *string `protobuf:"bytes,6,opt,name=compression,proto3,oneof" json:"compression,omitempty"`
	// / Kafka idle timeout in seconds.
	IdleTimeout *uint64 `protobuf:"varint,7,opt,name=idle_timeout,json=idleTimeout,proto3,oneof" json:"idle_timeout,omitempty"`
	// / Kafka send timeout in seconds.
	SendTimeout *uint64 `protobuf:"varint,8,opt,name=send_timeout,json=sendTimeout,proto3,oneof" json:"send_timeout,omitempty"`
	// / Extra options for Kafka.
	// / In Rust this is ExtraKafkaOptions; here it's a map of strings.
	ExtraKafkaOpts map[string]string `protobuf:"bytes,20,rep,name=extra_kafka_opts,json=extraKafkaOpts,proto3" json:"extra_kafka_opts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *KafkaHookOptions) Reset() {
	*x = KafkaHookOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KafkaHookOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KafkaHookOptions) ProtoMessage() {}

func (x *KafkaHookOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KafkaHookOptions.ProtoReflect.Descriptor instead.
func (*KafkaHookOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{3}
}

func (x *KafkaHookOptions) GetUrls() string {
	if x != nil && x.Urls != nil {
		return *x.Urls
	}
	return ""
}

func (x *KafkaHookOptions) GetClientId() string {
	if x != nil && x.ClientId != nil {
		return *x.ClientId
	}
	return ""
}

func (x *KafkaHookOptions) GetTopicOrPrefix() isKafkaHookOptions_TopicOrPrefix {
	if x != nil {
		return x.TopicOrPrefix
	}
	return nil
}

func (x *KafkaHookOptions) GetTopic() string {
	if x != nil {
		if x, ok := x.TopicOrPrefix.(*KafkaHookOptions_Topic); ok {
			return x.Topic
		}
	}
	return ""
}

func (x *KafkaHookOptions) GetPrefix() string {
	if x != nil {
		if x, ok := x.TopicOrPrefix.(*KafkaHookOptions_Prefix); ok {
			return x.Prefix
		}
	}
	return ""
}

func (x *KafkaHookOptions) GetRequiredAcks() string {
	if x != nil && x.RequiredAcks != nil {
		return *x.RequiredAcks
	}
	return ""
}

func (x *KafkaHookOptions) GetCompression() string {
	if x != nil && x.Compression != nil {
		return *x.Compression
	}
	return ""
}

func (x *KafkaHookOptions) GetIdleTimeout() uint64 {
	if x != nil && x.IdleTimeout != nil {
		return *x.IdleTimeout
	}
	return 0
}

func (x *KafkaHookOptions) GetSendTimeout() uint64 {
	if x != nil && x.SendTimeout != nil {
		return *x.SendTimeout
	}
	return 0
}

func (x *KafkaHookOptions) GetExtraKafkaOpts() map[string]string {
	if x != nil {
		return x.ExtraKafkaOpts
	}
	return nil
}

type isKafkaHookOptions_TopicOrPrefix interface {
	isKafkaHookOptions_TopicOrPrefix()
}

type KafkaHookOptions_Topic struct {
	Topic string `protobuf:"bytes,3,opt,name=topic,proto3,oneof"`
}

type KafkaHookOptions_Prefix struct {
	Prefix string `protobuf:"bytes,4,opt,name=prefix,proto3,oneof"`
}

func (*KafkaHookOptions_Topic) isKafkaHookOptions_TopicOrPrefix() {}

func (*KafkaHookOptions_Prefix) isKafkaHookOptions_TopicOrPrefix() {}

type NatsHookOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / List of URLs to connect to NATS. Commas are used as delimiters.
	Urls []string `protobuf:"bytes,1,rep,name=urls,proto3" json:"urls,omitempty"`
	// Mutual exclusion: subject OR prefix (Rust validate enforces this).
	//
	// Types that are valid to be assigned to SubjectOrPrefix:
	//
	//	*NatsHookOptions_Subject
	//	*NatsHookOptions_Prefix
	SubjectOrPrefix isNatsHookOptions_SubjectOrPrefix `protobuf_oneof:"subject_or_prefix"`
	// / Wait for replies from NATS.
	WaitForReplies bool `protobuf:"varint,4,opt,name=wait_for_replies,json=waitForReplies,proto3" json:"wait_for_replies,omitempty"`
	// / NATS user to connect to the server.
	Username *string `protobuf:"bytes,10,opt,name=username,proto3,oneof" json:"username,omitempty"`
	// / NATS password to connect to the server.
	Password *string `protobuf:"bytes,11,opt,name=password,proto3,oneof" json:"password,omitempty"`
	// / NATS token to connect to the server.
	Token         *string `protobuf:"bytes,12,opt,name=token,proto3,oneof" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NatsHookOptions) Reset() {
	*x = NatsHookOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NatsHookOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NatsHookOptions) ProtoMessage() {}

func (x *NatsHookOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NatsHookOptions.ProtoReflect.Descriptor instead.
func (*NatsHookOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{4}
}

func (x *NatsHookOptions) GetUrls() []string {
	if x != nil {
		return x.Urls
	}
	return nil
}

func (x *NatsHookOptions) GetSubjectOrPrefix() isNatsHookOptions_SubjectOrPrefix {
	if x != nil {
		return x.SubjectOrPrefix
	}
	return nil
}

func (x *NatsHookOptions) GetSubject() string {
	if x != nil {
		if x, ok := x.SubjectOrPrefix.(*NatsHookOptions_Subject); ok {
			return x.Subject
		}
	}
	return ""
}

func (x *NatsHookOptions) GetPrefix() string {
	if x != nil {
		if x, ok := x.SubjectOrPrefix.(*NatsHookOptions_Prefix); ok {
			return x.Prefix
		}
	}
	return ""
}

func (x *NatsHookOptions) GetWaitForReplies() bool {
	if x != nil {
		return x.WaitForReplies
	}
	return false
}

func (x *NatsHookOptions) GetUsername() string {
	if x != nil && x.Username != nil {
		return *x.Username
	}
	return ""
}

func (x *NatsHookOptions) GetPassword() string {
	if x != nil && x.Password != nil {
		return *x.Password
	}
	return ""
}

func (x *NatsHookOptions) GetToken() string {
	if x != nil && x.Token != nil {
		return *x.Token
	}
	return ""
}

type isNatsHookOptions_SubjectOrPrefix interface {
	isNatsHookOptions_SubjectOrPrefix()
}

type NatsHookOptions_Subject struct {
	Subject string `protobuf:"bytes,2,opt,name=subject,proto3,oneof"`
}

type NatsHookOptions_Prefix struct {
	Prefix string `protobuf:"bytes,3,opt,name=prefix,proto3,oneof"`
}

func (*NatsHookOptions_Subject) isNatsHookOptions_SubjectOrPrefix() {}

func (*NatsHookOptions_Prefix) isNatsHookOptions_SubjectOrPrefix() {}

type NotificationsOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Notifications format.
	// /
	// / This format will be used in all messages about hooks.
	HooksFormat Format `protobuf:"varint,1,opt,name=hooks_format,json=hooksFormat,proto3,enum=uploader.v1.Format" json:"hooks_format,omitempty"` // default Format::Default in Rust
	// / Enabled hooks for notifications.
	Hooks []Hook `protobuf:"varint,2,rep,packed,name=hooks,proto3,enum=uploader.v1.Hook" json:"hooks,omitempty"` // default set in Rust (pre-create, post-create, ...)
	// / Use this option if you use rustus behind any proxy. Like Nginx or Traefik.
	BehindProxy bool `protobuf:"varint,3,opt,name=behind_proxy,json=behindProxy,proto3" json:"behind_proxy,omitempty"`
	// / List of URLS to send webhooks to.
	HooksHttpUrls []string `protobuf:"bytes,4,rep,name=hooks_http_urls,json=hooksHttpUrls,proto3" json:"hooks_http_urls,omitempty"`
	// / Timeout for all HTTP requests in seconds.
	HttpHookTimeout *uint64 `protobuf:"varint,5,opt,name=http_hook_timeout,json=httpHookTimeout,proto3,oneof" json:"http_hook_timeout,omitempty"`
	// List of headers to forward from client.
	HooksHttpProxyHeaders []string `protobuf:"bytes,6,rep,name=hooks_http_proxy_headers,json=hooksHttpProxyHeaders,proto3" json:"hooks_http_proxy_headers,omitempty"`
	// / Directory for executable hook files.
	HooksDir *string `protobuf:"bytes,10,opt,name=hooks_dir,json=hooksDir,proto3,oneof" json:"hooks_dir,omitempty"`
	// / Executable file which must be called for notifying about upload status.
	HooksFile     *string           `protobuf:"bytes,11,opt,name=hooks_file,json=hooksFile,proto3,oneof" json:"hooks_file,omitempty"`
	AmqpHookOpts  *AMQPHooksOptions `protobuf:"bytes,20,opt,name=amqp_hook_opts,json=amqpHookOpts,proto3" json:"amqp_hook_opts,omitempty"`
	KafkaHookOpts *KafkaHookOptions `protobuf:"bytes,21,opt,name=kafka_hook_opts,json=kafkaHookOpts,proto3" json:"kafka_hook_opts,omitempty"`
	NatsHookOpts  *NatsHookOptions  `protobuf:"bytes,22,opt,name=nats_hook_opts,json=natsHookOpts,proto3" json:"nats_hook_opts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NotificationsOptions) Reset() {
	*x = NotificationsOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NotificationsOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NotificationsOptions) ProtoMessage() {}

func (x *NotificationsOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NotificationsOptions.ProtoReflect.Descriptor instead.
func (*NotificationsOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{5}
}

func (x *NotificationsOptions) GetHooksFormat() Format {
	if x != nil {
		return x.HooksFormat
	}
	return Format_FORMAT_UNSPECIFIED
}

func (x *NotificationsOptions) GetHooks() []Hook {
	if x != nil {
		return x.Hooks
	}
	return nil
}

func (x *NotificationsOptions) GetBehindProxy() bool {
	if x != nil {
		return x.BehindProxy
	}
	return false
}

func (x *NotificationsOptions) GetHooksHttpUrls() []string {
	if x != nil {
		return x.HooksHttpUrls
	}
	return nil
}

func (x *NotificationsOptions) GetHttpHookTimeout() uint64 {
	if x != nil && x.HttpHookTimeout != nil {
		return *x.HttpHookTimeout
	}
	return 0
}

func (x *NotificationsOptions) GetHooksHttpProxyHeaders() []string {
	if x != nil {
		return x.HooksHttpProxyHeaders
	}
	return nil
}

func (x *NotificationsOptions) GetHooksDir() string {
	if x != nil && x.HooksDir != nil {
		return *x.HooksDir
	}
	return ""
}

func (x *NotificationsOptions) GetHooksFile() string {
	if x != nil && x.HooksFile != nil {
		return *x.HooksFile
	}
	return ""
}

func (x *NotificationsOptions) GetAmqpHookOpts() *AMQPHooksOptions {
	if x != nil {
		return x.AmqpHookOpts
	}
	return nil
}

func (x *NotificationsOptions) GetKafkaHookOpts() *KafkaHookOptions {
	if x != nil {
		return x.KafkaHookOpts
	}
	return nil
}

func (x *NotificationsOptions) GetNatsHookOpts() *NatsHookOptions {
	if x != nil {
		return x.NatsHookOpts
	}
	return nil
}

type SentryOptions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Dsn   *string                `protobuf:"bytes,1,opt,name=dsn,proto3,oneof" json:"dsn,omitempty"`
	// sample_rate: f32 in Rust -> float here (no presence tracking for float in proto3
	// unless you use wrapper; we keep it as scalar and document default)
	SampleRate    float32 `protobuf:"fixed32,2,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"` // Rust default = 1.0; consumers should apply if zero/absent
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SentryOptions) Reset() {
	*x = SentryOptions{}
	mi := &file_uploader_v1_config_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SentryOptions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SentryOptions) ProtoMessage() {}

func (x *SentryOptions) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SentryOptions.ProtoReflect.Descriptor instead.
func (*SentryOptions) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{6}
}

func (x *SentryOptions) GetDsn() string {
	if x != nil && x.Dsn != nil {
		return *x.Dsn
	}
	return ""
}

func (x *SentryOptions) GetSampleRate() float32 {
	if x != nil {
		return x.SampleRate
	}
	return 0
}

type RustusConf struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// / Rustus server host
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	// / Rustus server port
	Port                   uint32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	DisableHealthAccessLog bool   `protobuf:"varint,3,opt,name=disable_health_access_log,json=disableHealthAccessLog,proto3" json:"disable_health_access_log,omitempty"`
	// / Rustus base API url
	Url string `protobuf:"bytes,4,opt,name=url,proto3" json:"url,omitempty"`
	// / Allowed hosts for CORS protocol.
	Cors []string `protobuf:"bytes,10,rep,name=cors,proto3" json:"cors,omitempty"`
	// / Maximum payload size.
	MaxBodySize uint64 `protobuf:"varint,11,opt,name=max_body_size,json=maxBodySize,proto3" json:"max_body_size,omitempty"`
	// / Rustus maximum log level (string; maps to log::LevelFilter in Rust)
	LogLevel string `protobuf:"bytes,12,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`
	// / Number of actix workers (optional: None -> auto)
	Workers *uint64 `protobuf:"varint,13,opt,name=workers,proto3,oneof" json:"workers,omitempty"`
	// / Enabled extensions for TUS protocol.
	TusExtensions []Extension `protobuf:"varint,14,rep,packed,name=tus_extensions,json=tusExtensions,proto3,enum=uploader.v1.Extension" json:"tus_extensions,omitempty"`
	// / Allow creation of empty files when Upload-Length header equals 0.
	AllowEmpty bool `protobuf:"varint,15,opt,name=allow_empty,json=allowEmpty,proto3" json:"allow_empty,omitempty"`
	// / Remove part files after concatenation is done.
	RemoveParts bool `protobuf:"varint,16,opt,name=remove_parts,json=removeParts,proto3" json:"remove_parts,omitempty"`
	// / Maximum size of file that can be uploaded. Optional -> presence matters.
	MaxFileSize *uint64 `protobuf:"varint,17,opt,name=max_file_size,json=maxFileSize,proto3,oneof" json:"max_file_size,omitempty"`
	// Nested option messages
	StorageOpts      *DataStorageOptions   `protobuf:"bytes,20,opt,name=storage_opts,json=storageOpts,proto3" json:"storage_opts,omitempty"`
	InfoStorageOpts  *InfoStoreOptions     `protobuf:"bytes,21,opt,name=info_storage_opts,json=infoStorageOpts,proto3" json:"info_storage_opts,omitempty"`
	NotificationOpts *NotificationsOptions `protobuf:"bytes,22,opt,name=notification_opts,json=notificationOpts,proto3" json:"notification_opts,omitempty"`
	SentryOpts       *SentryOptions        `protobuf:"bytes,23,opt,name=sentry_opts,json=sentryOpts,proto3" json:"sentry_opts,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RustusConf) Reset() {
	*x = RustusConf{}
	mi := &file_uploader_v1_config_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RustusConf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RustusConf) ProtoMessage() {}

func (x *RustusConf) ProtoReflect() protoreflect.Message {
	mi := &file_uploader_v1_config_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RustusConf.ProtoReflect.Descriptor instead.
func (*RustusConf) Descriptor() ([]byte, []int) {
	return file_uploader_v1_config_proto_rawDescGZIP(), []int{7}
}

func (x *RustusConf) GetHost() string {
	if x != nil {
		return x.Host
	}
	return ""
}

func (x *RustusConf) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *RustusConf) GetDisableHealthAccessLog() bool {
	if x != nil {
		return x.DisableHealthAccessLog
	}
	return false
}

func (x *RustusConf) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *RustusConf) GetCors() []string {
	if x != nil {
		return x.Cors
	}
	return nil
}

func (x *RustusConf) GetMaxBodySize() uint64 {
	if x != nil {
		return x.MaxBodySize
	}
	return 0
}

func (x *RustusConf) GetLogLevel() string {
	if x != nil {
		return x.LogLevel
	}
	return ""
}

func (x *RustusConf) GetWorkers() uint64 {
	if x != nil && x.Workers != nil {
		return *x.Workers
	}
	return 0
}

func (x *RustusConf) GetTusExtensions() []Extension {
	if x != nil {
		return x.TusExtensions
	}
	return nil
}

func (x *RustusConf) GetAllowEmpty() bool {
	if x != nil {
		return x.AllowEmpty
	}
	return false
}

func (x *RustusConf) GetRemoveParts() bool {
	if x != nil {
		return x.RemoveParts
	}
	return false
}

func (x *RustusConf) GetMaxFileSize() uint64 {
	if x != nil && x.MaxFileSize != nil {
		return *x.MaxFileSize
	}
	return 0
}

func (x *RustusConf) GetStorageOpts() *DataStorageOptions {
	if x != nil {
		return x.StorageOpts
	}
	return nil
}

func (x *RustusConf) GetInfoStorageOpts() *InfoStoreOptions {
	if x != nil {
		return x.InfoStorageOpts
	}
	return nil
}

func (x *RustusConf) GetNotificationOpts() *NotificationsOptions {
	if x != nil {
		return x.NotificationOpts
	}
	return nil
}

func (x *RustusConf) GetSentryOpts() *SentryOptions {
	if x != nil {
		return x.SentryOpts
	}
	return nil
}

var File_uploader_v1_config_proto protoreflect.FileDescriptor

const file_uploader_v1_config_proto_rawDesc = "" +
	"\n" +
	"\x18uploader/v1/config.proto\x12\vuploader.v1\"\xa7\a\n" +
	"\x12DataStorageOptions\x12<\n" +
	"\astorage\x18\x01 \x01(\x0e2\".uploader.v1.AvailableDataStoragesR\astorage\x12\x19\n" +
	"\bdata_dir\x18\x02 \x01(\tR\adataDir\x12#\n" +
	"\rdir_structure\x18\x03 \x01(\tR\fdirStructure\x12\x1f\n" +
	"\vforce_fsync\x18\x04 \x01(\bR\n" +
	"forceFsync\x12 \n" +
	"\ts3_bucket\x18\n" +
	" \x01(\tH\x00R\bs3Bucket\x88\x01\x01\x12 \n" +
	"\ts3_region\x18\v \x01(\tH\x01R\bs3Region\x88\x01\x01\x12'\n" +
	"\rs3_access_key\x18\f \x01(\tH\x02R\vs3AccessKey\x88\x01\x01\x120\n" +
	"\x12s3_access_key_path\x18\r \x01(\tH\x03R\x0fs3AccessKeyPath\x88\x01\x01\x12'\n" +
	"\rs3_secret_key\x18\x0e \x01(\tH\x04R\vs3SecretKey\x88\x01\x01\x120\n" +
	"\x12s3_secret_key_path\x18\x0f \x01(\tH\x05R\x0fs3SecretKeyPath\x88\x01\x01\x12\x1a\n" +
	"\x06s3_url\x18\x10 \x01(\tH\x06R\x05s3Url\x88\x01\x01\x12-\n" +
	"\x13s3_force_path_style\x18\x11 \x01(\bR\x10s3ForcePathStyle\x12/\n" +
	"\x11s3_security_token\x18\x12 \x01(\tH\aR\x0fs3SecurityToken\x88\x01\x01\x12-\n" +
	"\x10s3_session_token\x18\x13 \x01(\tH\bR\x0es3SessionToken\x88\x01\x01\x12\"\n" +
	"\n" +
	"s3_profile\x18\x14 \x01(\tH\tR\ts3Profile\x88\x01\x01\x12\"\n" +
	"\n" +
	"s3_headers\x18\x15 \x01(\tH\n" +
	"R\ts3Headers\x88\x01\x01\x12C\n" +
	"\x1es3_concat_concurrent_downloads\x18\x16 \x01(\rR\x1bs3ConcatConcurrentDownloadsB\f\n" +
	"\n" +
	"_s3_bucketB\f\n" +
	"\n" +
	"_s3_regionB\x10\n" +
	"\x0e_s3_access_keyB\x15\n" +
	"\x13_s3_access_key_pathB\x10\n" +
	"\x0e_s3_secret_keyB\x15\n" +
	"\x13_s3_secret_key_pathB\t\n" +
	"\a_s3_urlB\x14\n" +
	"\x12_s3_security_tokenB\x13\n" +
	"\x11_s3_session_tokenB\r\n" +
	"\v_s3_profileB\r\n" +
	"\v_s3_headers\"\xfc\x01\n" +
	"\x10InfoStoreOptions\x12E\n" +
	"\finfo_storage\x18\x01 \x01(\x0e2\".uploader.v1.AvailableInfoStoragesR\vinfoStorage\x12\x19\n" +
	"\binfo_dir\x18\x02 \x01(\tR\ainfoDir\x12#\n" +
	"\vinfo_db_dsn\x18\x03 \x01(\tH\x00R\tinfoDbDsn\x88\x01\x01\x127\n" +
	"\x15redis_info_expiration\x18\x04 \x01(\x04H\x01R\x13redisInfoExpiration\x88\x01\x01B\x0e\n" +
	"\f_info_db_dsnB\x18\n" +
	"\x16_redis_info_expiration\"\xb4\x05\n" +
	"\x10AMQPHooksOptions\x12\x15\n" +
	"\x03url\x18\x01 \x01(\tH\x00R\x03url\x88\x01\x01\x12)\n" +
	"\x10declare_exchange\x18\x02 \x01(\bR\x0fdeclareExchange\x12%\n" +
	"\x0edeclare_queues\x18\x03 \x01(\bR\rdeclareQueues\x12)\n" +
	"\x10durable_exchange\x18\x04 \x01(\bR\x0fdurableExchange\x12%\n" +
	"\x0edurable_queues\x18\x05 \x01(\bR\rdurableQueues\x12\x16\n" +
	"\x06celery\x18\x06 \x01(\bR\x06celery\x12\x1a\n" +
	"\bexchange\x18\n" +
	" \x01(\tR\bexchange\x12#\n" +
	"\rexchange_kind\x18\v \x01(\tR\fexchangeKind\x12$\n" +
	"\vrouting_key\x18\f \x01(\tH\x01R\n" +
	"routingKey\x88\x01\x01\x12#\n" +
	"\rqueues_prefix\x18\r \x01(\tR\fqueuesPrefix\x120\n" +
	"\x14connection_pool_size\x18\x0e \x01(\x04R\x12connectionPoolSize\x12*\n" +
	"\x11channel_pool_size\x18\x0f \x01(\x04R\x0fchannelPoolSize\x12;\n" +
	"\x17idle_connection_timeout\x18\x10 \x01(\x04H\x02R\x15idleConnectionTimeout\x88\x01\x01\x127\n" +
	"\x15idle_channels_timeout\x18\x11 \x01(\x04H\x03R\x13idleChannelsTimeout\x88\x01\x01\x12\x1f\n" +
	"\vauto_delete\x18\x12 \x01(\bR\n" +
	"autoDeleteB\x06\n" +
	"\x04_urlB\x0e\n" +
	"\f_routing_keyB\x1a\n" +
	"\x18_idle_connection_timeoutB\x18\n" +
	"\x16_idle_channels_timeout\"\xae\x04\n" +
	"\x10KafkaHookOptions\x12\x17\n" +
	"\x04urls\x18\x01 \x01(\tH\x01R\x04urls\x88\x01\x01\x12 \n" +
	"\tclient_id\x18\x02 \x01(\tH\x02R\bclientId\x88\x01\x01\x12\x16\n" +
	"\x05topic\x18\x03 \x01(\tH\x00R\x05topic\x12\x18\n" +
	"\x06prefix\x18\x04 \x01(\tH\x00R\x06prefix\x12(\n" +
	"\rrequired_acks\x18\x05 \x01(\tH\x03R\frequiredAcks\x88\x01\x01\x12%\n" +
	"\vcompression\x18\x06 \x01(\tH\x04R\vcompression\x88\x01\x01\x12&\n" +
	"\fidle_timeout\x18\a \x01(\x04H\x05R\vidleTimeout\x88\x01\x01\x12&\n" +
	"\fsend_timeout\x18\b \x01(\x04H\x06R\vsendTimeout\x88\x01\x01\x12[\n" +
	"\x10extra_kafka_opts\x18\x14 \x03(\v21.uploader.v1.KafkaHookOptions.ExtraKafkaOptsEntryR\x0eextraKafkaOpts\x1aA\n" +
	"\x13ExtraKafkaOptsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x11\n" +
	"\x0ftopic_or_prefixB\a\n" +
	"\x05_urlsB\f\n" +
	"\n" +
	"_client_idB\x10\n" +
	"\x0e_required_acksB\x0e\n" +
	"\f_compressionB\x0f\n" +
	"\r_idle_timeoutB\x0f\n" +
	"\r_send_timeout\"\x9b\x02\n" +
	"\x0fNatsHookOptions\x12\x12\n" +
	"\x04urls\x18\x01 \x03(\tR\x04urls\x12\x1a\n" +
	"\asubject\x18\x02 \x01(\tH\x00R\asubject\x12\x18\n" +
	"\x06prefix\x18\x03 \x01(\tH\x00R\x06prefix\x12(\n" +
	"\x10wait_for_replies\x18\x04 \x01(\bR\x0ewaitForReplies\x12\x1f\n" +
	"\busername\x18\n" +
	" \x01(\tH\x01R\busername\x88\x01\x01\x12\x1f\n" +
	"\bpassword\x18\v \x01(\tH\x02R\bpassword\x88\x01\x01\x12\x19\n" +
	"\x05token\x18\f \x01(\tH\x03R\x05token\x88\x01\x01B\x13\n" +
	"\x11subject_or_prefixB\v\n" +
	"\t_usernameB\v\n" +
	"\t_passwordB\b\n" +
	"\x06_token\"\xf5\x04\n" +
	"\x14NotificationsOptions\x126\n" +
	"\fhooks_format\x18\x01 \x01(\x0e2\x13.uploader.v1.FormatR\vhooksFormat\x12'\n" +
	"\x05hooks\x18\x02 \x03(\x0e2\x11.uploader.v1.HookR\x05hooks\x12!\n" +
	"\fbehind_proxy\x18\x03 \x01(\bR\vbehindProxy\x12&\n" +
	"\x0fhooks_http_urls\x18\x04 \x03(\tR\rhooksHttpUrls\x12/\n" +
	"\x11http_hook_timeout\x18\x05 \x01(\x04H\x00R\x0fhttpHookTimeout\x88\x01\x01\x127\n" +
	"\x18hooks_http_proxy_headers\x18\x06 \x03(\tR\x15hooksHttpProxyHeaders\x12 \n" +
	"\thooks_dir\x18\n" +
	" \x01(\tH\x01R\bhooksDir\x88\x01\x01\x12\"\n" +
	"\n" +
	"hooks_file\x18\v \x01(\tH\x02R\thooksFile\x88\x01\x01\x12C\n" +
	"\x0eamqp_hook_opts\x18\x14 \x01(\v2\x1d.uploader.v1.AMQPHooksOptionsR\famqpHookOpts\x12E\n" +
	"\x0fkafka_hook_opts\x18\x15 \x01(\v2\x1d.uploader.v1.KafkaHookOptionsR\rkafkaHookOpts\x12B\n" +
	"\x0enats_hook_opts\x18\x16 \x01(\v2\x1c.uploader.v1.NatsHookOptionsR\fnatsHookOptsB\x14\n" +
	"\x12_http_hook_timeoutB\f\n" +
	"\n" +
	"_hooks_dirB\r\n" +
	"\v_hooks_file\"O\n" +
	"\rSentryOptions\x12\x15\n" +
	"\x03dsn\x18\x01 \x01(\tH\x00R\x03dsn\x88\x01\x01\x12\x1f\n" +
	"\vsample_rate\x18\x02 \x01(\x02R\n" +
	"sampleRateB\x06\n" +
	"\x04_dsn\"\xdb\x05\n" +
	"\n" +
	"RustusConf\x12\x12\n" +
	"\x04host\x18\x01 \x01(\tR\x04host\x12\x12\n" +
	"\x04port\x18\x02 \x01(\rR\x04port\x129\n" +
	"\x19disable_health_access_log\x18\x03 \x01(\bR\x16disableHealthAccessLog\x12\x10\n" +
	"\x03url\x18\x04 \x01(\tR\x03url\x12\x12\n" +
	"\x04cors\x18\n" +
	" \x03(\tR\x04cors\x12\"\n" +
	"\rmax_body_size\x18\v \x01(\x04R\vmaxBodySize\x12\x1b\n" +
	"\tlog_level\x18\f \x01(\tR\blogLevel\x12\x1d\n" +
	"\aworkers\x18\r \x01(\x04H\x00R\aworkers\x88\x01\x01\x12=\n" +
	"\x0etus_extensions\x18\x0e \x03(\x0e2\x16.uploader.v1.ExtensionR\rtusExtensions\x12\x1f\n" +
	"\vallow_empty\x18\x0f \x01(\bR\n" +
	"allowEmpty\x12!\n" +
	"\fremove_parts\x18\x10 \x01(\bR\vremoveParts\x12'\n" +
	"\rmax_file_size\x18\x11 \x01(\x04H\x01R\vmaxFileSize\x88\x01\x01\x12B\n" +
	"\fstorage_opts\x18\x14 \x01(\v2\x1f.uploader.v1.DataStorageOptionsR\vstorageOpts\x12I\n" +
	"\x11info_storage_opts\x18\x15 \x01(\v2\x1d.uploader.v1.InfoStoreOptionsR\x0finfoStorageOpts\x12N\n" +
	"\x11notification_opts\x18\x16 \x01(\v2!.uploader.v1.NotificationsOptionsR\x10notificationOpts\x12;\n" +
	"\vsentry_opts\x18\x17 \x01(\v2\x1a.uploader.v1.SentryOptionsR\n" +
	"sentryOptsB\n" +
	"\n" +
	"\b_workersB\x10\n" +
	"\x0e_max_file_size*i\n" +
	"\x15AvailableDataStorages\x12'\n" +
	"#AVAILABLE_DATA_STORAGES_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fFILE_STORAGE\x10\x01\x12\x06\n" +
	"\x02S3\x10\x02\x12\r\n" +
	"\tHYBRID_S3\x10\x03*d\n" +
	"\x15AvailableInfoStorages\x12'\n" +
	"#AVAILABLE_INFO_STORAGES_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05FILES\x10\x01\x12\t\n" +
	"\x05REDIS\x10\x02\x12\f\n" +
	"\bPOSTGRES\x10\x03*\x87\x01\n" +
	"\x04Hook\x12\x14\n" +
	"\x10HOOK_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"PRE_CREATE\x10\x01\x12\x0f\n" +
	"\vPOST_CREATE\x10\x02\x12\x10\n" +
	"\fPOST_RECEIVE\x10\x03\x12\x11\n" +
	"\rPRE_TERMINATE\x10\x04\x12\x12\n" +
	"\x0ePOST_TERMINATE\x10\x05\x12\x0f\n" +
	"\vPOST_FINISH\x10\x06*5\n" +
	"\x06Format\x12\x16\n" +
	"\x12FORMAT_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aDEFAULT\x10\x01\x12\x06\n" +
	"\x02V2\x10\x02*\xa8\x01\n" +
	"\tExtension\x12\x19\n" +
	"\x15EXTENSION_UNSPECIFIED\x10\x00\x12\v\n" +
	"\aGETTING\x10\x01\x12\f\n" +
	"\bCREATION\x10\x02\x12\x18\n" +
	"\x14CREATION_WITH_UPLOAD\x10\x03\x12\x19\n" +
	"\x15CREATION_DEFER_LENGTH\x10\x04\x12\x0f\n" +
	"\vTERMINATION\x10\x05\x12\x11\n" +
	"\rCONCATENATION\x10\x06\x12\f\n" +
	"\bCHECKSUM\x10\aBu\n" +
	"\x1corg.megacommerce.uploader.v1B\vConfigProtoZEgithub.com/ahmad-khatib0-org/megacommerce-proto/gen/go/uploader/v1;v1\xf8\x01\x01b\x06proto3"

var (
	file_uploader_v1_config_proto_rawDescOnce sync.Once
	file_uploader_v1_config_proto_rawDescData []byte
)

func file_uploader_v1_config_proto_rawDescGZIP() []byte {
	file_uploader_v1_config_proto_rawDescOnce.Do(func() {
		file_uploader_v1_config_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_uploader_v1_config_proto_rawDesc), len(file_uploader_v1_config_proto_rawDesc)))
	})
	return file_uploader_v1_config_proto_rawDescData
}

var file_uploader_v1_config_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_uploader_v1_config_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_uploader_v1_config_proto_goTypes = []any{
	(AvailableDataStorages)(0),   // 0: uploader.v1.AvailableDataStorages
	(AvailableInfoStorages)(0),   // 1: uploader.v1.AvailableInfoStorages
	(Hook)(0),                    // 2: uploader.v1.Hook
	(Format)(0),                  // 3: uploader.v1.Format
	(Extension)(0),               // 4: uploader.v1.Extension
	(*DataStorageOptions)(nil),   // 5: uploader.v1.DataStorageOptions
	(*InfoStoreOptions)(nil),     // 6: uploader.v1.InfoStoreOptions
	(*AMQPHooksOptions)(nil),     // 7: uploader.v1.AMQPHooksOptions
	(*KafkaHookOptions)(nil),     // 8: uploader.v1.KafkaHookOptions
	(*NatsHookOptions)(nil),      // 9: uploader.v1.NatsHookOptions
	(*NotificationsOptions)(nil), // 10: uploader.v1.NotificationsOptions
	(*SentryOptions)(nil),        // 11: uploader.v1.SentryOptions
	(*RustusConf)(nil),           // 12: uploader.v1.RustusConf
	nil,                          // 13: uploader.v1.KafkaHookOptions.ExtraKafkaOptsEntry
}
var file_uploader_v1_config_proto_depIdxs = []int32{
	0,  // 0: uploader.v1.DataStorageOptions.storage:type_name -> uploader.v1.AvailableDataStorages
	1,  // 1: uploader.v1.InfoStoreOptions.info_storage:type_name -> uploader.v1.AvailableInfoStorages
	13, // 2: uploader.v1.KafkaHookOptions.extra_kafka_opts:type_name -> uploader.v1.KafkaHookOptions.ExtraKafkaOptsEntry
	3,  // 3: uploader.v1.NotificationsOptions.hooks_format:type_name -> uploader.v1.Format
	2,  // 4: uploader.v1.NotificationsOptions.hooks:type_name -> uploader.v1.Hook
	7,  // 5: uploader.v1.NotificationsOptions.amqp_hook_opts:type_name -> uploader.v1.AMQPHooksOptions
	8,  // 6: uploader.v1.NotificationsOptions.kafka_hook_opts:type_name -> uploader.v1.KafkaHookOptions
	9,  // 7: uploader.v1.NotificationsOptions.nats_hook_opts:type_name -> uploader.v1.NatsHookOptions
	4,  // 8: uploader.v1.RustusConf.tus_extensions:type_name -> uploader.v1.Extension
	5,  // 9: uploader.v1.RustusConf.storage_opts:type_name -> uploader.v1.DataStorageOptions
	6,  // 10: uploader.v1.RustusConf.info_storage_opts:type_name -> uploader.v1.InfoStoreOptions
	10, // 11: uploader.v1.RustusConf.notification_opts:type_name -> uploader.v1.NotificationsOptions
	11, // 12: uploader.v1.RustusConf.sentry_opts:type_name -> uploader.v1.SentryOptions
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_uploader_v1_config_proto_init() }
func file_uploader_v1_config_proto_init() {
	if File_uploader_v1_config_proto != nil {
		return
	}
	file_uploader_v1_config_proto_msgTypes[0].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[1].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[2].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[3].OneofWrappers = []any{
		(*KafkaHookOptions_Topic)(nil),
		(*KafkaHookOptions_Prefix)(nil),
	}
	file_uploader_v1_config_proto_msgTypes[4].OneofWrappers = []any{
		(*NatsHookOptions_Subject)(nil),
		(*NatsHookOptions_Prefix)(nil),
	}
	file_uploader_v1_config_proto_msgTypes[5].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[6].OneofWrappers = []any{}
	file_uploader_v1_config_proto_msgTypes[7].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_uploader_v1_config_proto_rawDesc), len(file_uploader_v1_config_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_uploader_v1_config_proto_goTypes,
		DependencyIndexes: file_uploader_v1_config_proto_depIdxs,
		EnumInfos:         file_uploader_v1_config_proto_enumTypes,
		MessageInfos:      file_uploader_v1_config_proto_msgTypes,
	}.Build()
	File_uploader_v1_config_proto = out.File
	file_uploader_v1_config_proto_goTypes = nil
	file_uploader_v1_config_proto_depIdxs = nil
}
